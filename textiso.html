<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Isometric Game Engine – Mobile Controls (Enhanced Gameboy D-pad)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #505050;
      touch-action: none;
    }
    canvas {
      display: block;
      background: #505050;
    }
    /* --- D-pad Container: enlarged for easier touch --- */
    #dpadContainer {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 150px;
      height: 150px;
      z-index: 10;
      user-select: none;
    }
    /* --- Plus-shaped D-pad background --- */
    #dpad {
      position: relative;
      width: 100%;
      height: 100%;
      /* Optional background styling for the plus shape */
    }
    /* Directional touch areas */
    .dpad-arm {
      position: absolute;
      background: rgba(200,200,200,0.6);
      border: 2px solid #888;
      border-radius: 5px;
    }
    /* Up area */
    #dpad-up {
      top: 0;
      left: 25%;
      width: 50%;
      height: 40px;
    }
    /* Down area */
    #dpad-down {
      bottom: 0;
      left: 25%;
      width: 50%;
      height: 40px;
    }
    /* Left area */
    #dpad-left {
      left: 0;
      top: 25%;
      width: 40px;
      height: 50px;
    }
    /* Right area */
    #dpad-right {
      right: 0;
      top: 25%;
      width: 40px;
      height: 50px;
    }
    /* Center disc for refined attacking (small, draggable) */
    #dpad-center {
      position: absolute;
      width: 40px;
      height: 40px;
      background: #666;
      border: 2px solid #444;
      border-radius: 50%;
      left: calc(50% - 20px);
      top: calc(50% - 20px);
      z-index: 1;
      touch-action: none;
    }
    /* Shoot Button Styling */
    #shootBtn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 10;
      width: 80px;
      height: 80px;
      background: rgba(255, 255, 255, 0.7);
      border: none;
      border-radius: 8px;
      font-size: 24px;
      user-select: none;
    }
    #shootBtn:active {
      background: rgba(255, 255, 255, 0.9);
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <!-- Enlarged, plus-shaped D-pad with four arms and a small center disc -->
  <div id="dpadContainer">
    <div id="dpad">
      <div id="dpad-up" class="dpad-arm"></div>
      <div id="dpad-down" class="dpad-arm"></div>
      <div id="dpad-left" class="dpad-arm"></div>
      <div id="dpad-right" class="dpad-arm"></div>
      <div id="dpad-center"></div>
    </div>
  </div>
  
  <!-- Shoot Button -->
  <button id="shootBtn">Shoot</button>

  <script>
    "use strict";

    // Global pixel size for upscaling.
    const PIXEL_SIZE = 4;
    let timeScale = 1.0;
    let slowMotionTimer = 0;
    let killCount = 0;

    // Utility: clamp a value between min and max.
    function clamp(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }

    // ---------------------------
    // Vector2 Class
    // ---------------------------
    class Vector2 {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      add(v) {
        return new Vector2(this.x + v.x, this.y + v.y);
      }
      subtract(v) {
        return new Vector2(this.x - v.x, this.y - v.y);
      }
      scale(s) {
        return new Vector2(this.x * s, this.y * s);
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      normalize() {
        let len = this.length();
        return new Vector2(this.x / (len || 1), this.y / (len || 1));
      }
    }

    // ---------------------------
    // Camera Class – Follows player and clamps to board bounds.
    // ---------------------------
    class Camera {
      constructor(screenWidth, screenHeight) {
        this.position = new Vector2(0, 0);
        this.zoom = 1.0;
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
      }
      worldToScreen(worldPos) {
        return new Vector2(
          (worldPos.x - this.position.x) * this.zoom + this.screenWidth / 2,
          (worldPos.y - this.position.y) * this.zoom + this.screenHeight / 2
        );
      }
      screenToWorld(screenPos) {
        return new Vector2(
          (screenPos.x - this.screenWidth / 2) / this.zoom + this.position.x,
          (screenPos.y - this.screenHeight / 2) / this.zoom + this.position.y
        );
      }
    }

    // ---------------------------
    // Tile and TileMap Classes
    // ---------------------------
    class Tile {
      constructor(gridX, gridY, tileType, color) {
        this.gridX = gridX;
        this.gridY = gridY;
        this.tileType = tileType;
        this.color = color;
      }
    }
    class TileMap {
      constructor(width, height, tileWidth, tileHeight) {
        this.width = width;
        this.height = height;
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;
        this.tiles = [];
        for (let y = 0; y < height; y++) {
          let row = [];
          for (let x = 0; x < width; x++) {
            row.push(new Tile(x, y, 0, "#64dd64"));
          }
          this.tiles.push(row);
        }
      }
      gridToWorld(gridX, gridY) {
        return new Vector2(
          (gridX - gridY) * (this.tileWidth / 2),
          (gridX + gridY) * (this.tileHeight / 2)
        );
      }
      render(ctx, camera) {
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            let worldPos = this.gridToWorld(x, y);
            let screenPos = camera.worldToScreen(worldPos);
            let halfW = this.tileWidth / 2;
            let halfH = this.tileHeight / 2;
            ctx.beginPath();
            ctx.moveTo(screenPos.x, screenPos.y + halfH);
            ctx.lineTo(screenPos.x + halfW, screenPos.y);
            ctx.lineTo(screenPos.x + this.tileWidth, screenPos.y + halfH);
            ctx.lineTo(screenPos.x + halfW, screenPos.y + this.tileHeight);
            ctx.closePath();
            ctx.fillStyle = this.tiles[y][x].color;
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.stroke();
          }
        }
      }
    }

    // ---------------------------
    // Particle Class – For blood and pickup burst effects.
    // ---------------------------
    class Particle {
      constructor(position, velocity, life, color, size) {
        this.position = position;
        this.velocity = velocity;
        this.life = life;
        this.maxLife = life;
        this.color = color;
        this.size = size;
      }
      update(deltaTime) {
        this.position = this.position.add(this.velocity.scale(deltaTime));
        this.life -= deltaTime;
      }
      render(ctx, camera) {
        let alpha = Math.max(this.life / this.maxLife, 0);
        let screenPos = camera.worldToScreen(this.position);
        ctx.fillStyle = this.color.replace("ALPHA", alpha);
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    let effects = [];
    function spawnPickupEffect(position) {
      const count = 10;
      for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = Math.random() * 50 + 50;
        let velocity = new Vector2(Math.cos(angle), Math.sin(angle)).scale(speed);
        let life = Math.random() * 0.5 + 0.5;
        let size = Math.random() * 2 + 2;
        effects.push(new Particle(new Vector2(position.x, position.y), velocity, life, "rgba(255,215,0,ALPHA)", size));
      }
    }
    function spawnBloodEffect(position) {
      const count = 20;
      for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = Math.random() * 100 + 50;
        let velocity = new Vector2(Math.cos(angle), Math.sin(angle)).scale(speed);
        let life = Math.random() * 0.5 + 0.5;
        let size = Math.random() * 1 + 1;
        effects.push(new Particle(new Vector2(position.x, position.y), velocity, life, "rgba(200,0,0,ALPHA)", size));
      }
    }
    function updateEffects(deltaTime) {
      for (let i = effects.length - 1; i >= 0; i--) {
        effects[i].update(deltaTime);
        if (effects[i].life <= 0) effects.splice(i, 1);
      }
    }
    function renderEffects(ctx, camera) {
      for (let eff of effects) {
        eff.render(ctx, camera);
      }
    }

    // ---------------------------
    // Health Pickup Class – Renders a heart emoji.
    // ---------------------------
    class HealthPickup {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap;
        this.gridX = tileX;
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.size = tileMap.tileWidth / 2;
      }
      render(ctx, camera) {
        let screenPos = camera.worldToScreen(this.position);
        ctx.font = `${this.size}px sans-serif`;
        ctx.fillText("❤️", screenPos.x, screenPos.y + this.size);
      }
    }

    // ---------------------------
    // Bullet Class – Clamped to travel one tile's distance.
    // ---------------------------
    class Bullet {
      constructor(position, velocity, owner) {
        this.position = new Vector2(position.x, position.y);
        this.startPosition = new Vector2(position.x, position.y);
        this.velocity = velocity;
        this.radius = 5;
        this.alive = true;
        this.owner = owner;
        this.maxDistance = Math.sqrt(Math.pow(tileMap.tileWidth / 2, 2) +
                                     Math.pow(tileMap.tileHeight / 2, 2));
      }
      update(deltaTime) {
        this.position = this.position.add(this.velocity.scale(deltaTime));
        if (this.position.subtract(this.startPosition).length() >= this.maxDistance) {
          this.alive = false;
        }
        if (
          this.position.x < -50 || this.position.x > canvas.width + 50 ||
          this.position.y < -50 || this.position.y > canvas.height + 50
        ) {
          this.alive = false;
        }
      }
      render(ctx, camera) {
        let screenPos = camera.worldToScreen(this.position);
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "yellow";
        ctx.fill();
      }
    }

    // ---------------------------
    // Player Class – With HP, shooting, animation, knockback, and death effects.
    // ---------------------------
    class Player {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap;
        this.gridX = tileX;
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.pixelSize = PIXEL_SIZE * 0.5;
        this.width = 32 * this.pixelSize;
        this.height = 32 * this.pixelSize;
        this.moving = false;
        this.startPos = null;
        this.targetPos = null;
        this.moveDuration = 0.1;
        this.moveTime = 0;
        this.targetGridX = tileX;
        this.targetGridY = tileY;
        this.direction = "down";
        this.maxHP = 100;
        this.hp = 100;
        this.knockback = new Vector2(0, 0);
        this.isDead = false;

        this.spriteSheet = new Image();
        this.spriteLoaded = false;
        this.spriteSheet.onload = () => { this.spriteLoaded = true; };
        this.spriteSheet.src = "https://s3-us-west-2.amazonaws.com/s.cdpn.io/21542/WalkingDemo-SHIRMOND-SHEET.png";

        this.frameCount = 4;
        this.currentFrame = 0;
        this.frameTime = 0;
        this.frameDelay = 0.1;
      }
      update(deltaTime) {
        if (this.moving) {
          this.moveTime += deltaTime;
          let t = Math.min(this.moveTime / this.moveDuration, 1);
          this.position = new Vector2(
            this.startPos.x + (this.targetPos.x - this.startPos.x) * t,
            this.startPos.y + (this.targetPos.y - this.startPos.y) * t
          );
          this.frameTime += deltaTime;
          if (this.frameTime >= this.frameDelay) {
            this.currentFrame = (this.currentFrame + 1) % this.frameCount;
            this.frameTime = 0;
          }
          if (t >= 1) {
            this.moving = false;
            this.gridX = this.targetGridX;
            this.gridY = this.targetGridY;
            this.currentFrame = 0;
          }
        } else {
          this.currentFrame = 0;
        }
        this.knockback = this.knockback.scale(0.9);
      }
      render(ctx, camera) {
        let pos = this.position.add(this.knockback);
        let screenPos = camera.worldToScreen(pos);
        if (this.spriteLoaded) {
          let row = 0;
          switch (this.direction) {
            case "down": row = 0; break;
            case "right": row = 1; break;
            case "up": row = 2; break;
            case "left": row = 3; break;
            default: row = 0;
          }
          let srcX = this.currentFrame * 32;
          let srcY = row * 32;
          ctx.drawImage(
            this.spriteSheet,
            srcX, srcY, 32, 32,
            screenPos.x, screenPos.y, this.width, this.height
          );
        } else {
          ctx.fillStyle = "red";
          ctx.fillRect(screenPos.x, screenPos.y, this.width, this.height);
        }
      }
      move(direction) {
        if (this.moving) return;
        let newGridX = this.gridX;
        let newGridY = this.gridY;
        if (direction === "up") { newGridY -= 1; }
        else if (direction === "down") { newGridY += 1; }
        else if (direction === "left") { newGridX -= 1; }
        else if (direction === "right") { newGridX += 1; }
        if (newGridX < 0 || newGridX >= this.tileMap.width ||
            newGridY < 0 || newGridY >= this.tileMap.height) return;
        if (this.tileMap.tiles[newGridY][newGridX].tileType !== 0) return;
        this.moving = true;
        this.moveTime = 0;
        this.startPos = this.position;
        this.targetPos = this.tileMap.gridToWorld(newGridX, newGridY);
        this.targetGridX = newGridX;
        this.targetGridY = newGridY;
        this.direction = direction;
        this.frameTime = 0;
        this.currentFrame = 0;
      }
      keyDown(evt) {
        if (evt.key === " " || evt.key === "Spacebar") {
          this.shoot();
          return;
        }
        if (this.moving) return;
        if (evt.key === "ArrowUp" || evt.key === "w" || evt.key === "W") {
          this.move("up");
        } else if (evt.key === "ArrowDown" || evt.key === "s" || evt.key === "S") {
          this.move("down");
        } else if (evt.key === "ArrowLeft" || evt.key === "a" || evt.key === "A") {
          this.move("left");
        } else if (evt.key === "ArrowRight" || evt.key === "d" || evt.key === "D") {
          this.move("right");
        }
      }
      // Fires in facing direction.
      shoot() {
        let startPos = new Vector2(
          this.position.x + this.width / 2,
          this.position.y + this.height / 2
        );
        let directionVector;
        switch (this.direction) {
          case "up": directionVector = new Vector2(0, -1); break;
          case "down": directionVector = new Vector2(0, 1); break;
          case "left": directionVector = new Vector2(-1, 0); break;
          case "right": directionVector = new Vector2(1, 0); break;
          default: directionVector = new Vector2(0, -1);
        }
        let bulletSpeed = 600;
        let velocity = directionVector.scale(bulletSpeed);
        bullets.push(new Bullet(
          new Vector2(this.position.x + this.width / 2, this.position.y + this.height / 2),
          velocity,
          "player"
        ));
      }
      // Refined attack: fires toward a target world coordinate.
      shootAt(target) {
        let startPos = new Vector2(
          this.position.x + this.width / 2,
          this.position.y + this.height / 2
        );
        let diff = target.subtract(startPos);
        let norm = diff.normalize();
        let bulletSpeed = 600;
        let velocity = norm.scale(bulletSpeed);
        bullets.push(new Bullet(startPos, velocity, "player"));
      }
      respawn() {
        this.gridX = 5;
        this.gridY = 5;
        this.position = this.tileMap.gridToWorld(this.gridX, this.gridY);
        this.hp = this.maxHP;
        this.isDead = false;
      }
    }

    // ---------------------------
    // Enemy Class – With HP, knockback, and blood effect on death.
    // ---------------------------
    class Enemy {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap;
        this.gridX = tileX;
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.pixelSize = PIXEL_SIZE * 0.5;
        this.width = 32 * this.pixelSize;
        this.height = 32 * this.pixelSize;
        this.spriteSheet = new Image();
        this.spriteLoaded = false;
        this.spriteSheet.onload = () => { this.spriteLoaded = true; };
        this.spriteSheet.src = "https://s3-us-west-2.amazonaws.com/s.cdpn.io/21542/WalkingDemo-BEAR-SHEET.png";
        this.alive = true;
        this.maxHP = 40;
        this.hp = 40;
        this.moving = false;
        this.startPos = null;
        this.targetPos = null;
        this.moveDuration = 0.2;
        this.moveTime = 0;
        this.targetGridX = tileX;
        this.targetGridY = tileY;
        this.direction = "down";
        this.frameCount = 4;
        this.currentFrame = 0;
        this.frameTime = 0;
        this.frameDelay = 0.15;
        this.attackCooldown = 0;
        this.knockback = new Vector2(0, 0);
      }
      update(deltaTime) {
        if (this.moving) {
          this.moveTime += deltaTime;
          let t = Math.min(this.moveTime / this.moveDuration, 1);
          this.position = new Vector2(
            this.startPos.x + (this.targetPos.x - this.startPos.x) * t,
            this.startPos.y + (this.targetPos.y - this.startPos.y) * t
          );
          this.frameTime += deltaTime;
          if (this.frameTime >= this.frameDelay) {
            this.currentFrame = (this.currentFrame + 1) % this.frameCount;
            this.frameTime = 0;
          }
          if (t >= 1) {
            this.moving = false;
            this.gridX = this.targetGridX;
            this.gridY = this.targetGridY;
            this.currentFrame = 0;
          }
        } else {
          if (this.attackCooldown > 0) {
            this.attackCooldown -= deltaTime;
          }
          let dx = player.gridX - this.gridX;
          let dy = player.gridY - this.gridY;
          let manhattan = Math.abs(dx) + Math.abs(dy);
          if (manhattan <= 1 && this.attackCooldown <= 0) {
            this.shoot();
            this.attackCooldown = 1.0;
          } else if (manhattan > 1) {
            let direction;
            if (Math.abs(dx) >= Math.abs(dy)) {
              direction = dx > 0 ? "right" : "left";
            } else {
              direction = dy > 0 ? "down" : "up";
            }
            this.move(direction);
          }
        }
        this.knockback = this.knockback.scale(0.9);
      }
      render(ctx, camera) {
        let pos = this.position.add(this.knockback);
        let screenPos = camera.worldToScreen(pos);
        if (this.spriteLoaded) {
          let row = 0;
          switch (this.direction) {
            case "down": row = 0; break;
            case "right": row = 1; break;
            case "up": row = 2; break;
            case "left": row = 3; break;
            default: row = 0;
          }
          let srcX = this.currentFrame * 32;
          let srcY = row * 32;
          ctx.drawImage(
            this.spriteSheet,
            srcX, srcY, 32, 32,
            screenPos.x, screenPos.y, this.width, this.height
          );
        } else {
          ctx.fillStyle = "green";
          ctx.fillRect(screenPos.x, screenPos.y, this.width, this.height);
        }
      }
      move(direction) {
        if (this.moving) return;
        let newGridX = this.gridX;
        let newGridY = this.gridY;
        if (direction === "up") newGridY -= 1;
        else if (direction === "down") newGridY += 1;
        else if (direction === "left") newGridX -= 1;
        else if (direction === "right") newGridX += 1;
        if (newGridX < 0 || newGridX >= this.tileMap.width ||
            newGridY < 0 || newGridY >= this.tileMap.height) return;
        if (this.tileMap.tiles[newGridY][newGridX].tileType !== 0) return;
        this.moving = true;
        this.moveTime = 0;
        this.startPos = this.position;
        this.targetPos = this.tileMap.gridToWorld(newGridX, newGridY);
        this.targetGridX = newGridX;
        this.targetGridY = newGridY;
        this.direction = direction;
        this.frameTime = 0;
        this.currentFrame = 0;
      }
      shoot() {
        let startPos = new Vector2(
          this.position.x + this.width / 2,
          this.position.y + this.height / 2
        );
        let playerCenter = new Vector2(
          player.position.x + player.width / 2,
          player.position.y + player.height / 2
        );
        let diff = playerCenter.subtract(startPos);
        let norm = diff.normalize();
        let bulletSpeed = 600;
        let velocity = norm.scale(bulletSpeed);
        bullets.push(new Bullet(startPos, velocity, "enemy"));
      }
    }

    // ---------------------------
    // Global Variables for Screen Shake and Pickups
    // ---------------------------
    let pickups = [];
    let pickupSpawnTimer = 0;
    const pickupSpawnInterval = 10.0; // seconds.
    let screenShakeTime = 0;
    let screenShakeMagnitude = 0;
    let shakeOffset = new Vector2(0, 0);

    // ---------------------------
    // Collision Resolution (Knockback)
    // ---------------------------
    function resolveCollision(entityA, entityB) {
      let ax = entityA.position.x + entityA.knockback.x,
          ay = entityA.position.y + entityA.knockback.y,
          aw = entityA.width, ah = entityA.height;
      let bx = entityB.position.x + entityB.knockback.x,
          by = entityB.position.y + entityB.knockback.y,
          bw = entityB.width, bh = entityB.height;
      if (ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by) {
        let centerA = new Vector2(ax + aw / 2, ay + ah / 2);
        let centerB = new Vector2(bx + bw / 2, by + bh / 2);
        let diff = centerA.subtract(centerB);
        let distance = diff.length();
        if (distance === 0) { diff = new Vector2(1, 0); distance = 1; }
        let minDistance = (aw + bw) / 4;
        let overlap = minDistance - distance;
        if (overlap > 0) {
          let knock = diff.normalize().scale(overlap * 0.5);
          entityA.knockback = entityA.knockback.add(knock);
          entityB.knockback = entityB.knockback.subtract(knock);
        }
      }
    }

    // ---------------------------
    // Setup Canvas and Camera
    // ---------------------------
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const camera = new Camera(canvas.width, canvas.height);
    const tileMap = new TileMap(20, 20, 64, 32);
    let corners = [
      tileMap.gridToWorld(0, 0),
      tileMap.gridToWorld(tileMap.width - 1, 0),
      tileMap.gridToWorld(0, tileMap.height - 1),
      tileMap.gridToWorld(tileMap.width - 1, tileMap.height - 1)
    ];
    let worldMinX = Math.min(...corners.map(c => c.x));
    let worldMaxX = Math.max(...corners.map(c => c.x)) + tileMap.tileWidth;
    let worldMinY = Math.min(...corners.map(c => c.y));
    let worldMaxY = Math.max(...corners.map(c => c.y)) + tileMap.tileHeight;
    function updateCamera() {
      let halfWidth = (canvas.width / camera.zoom) / 2;
      let halfHeight = (canvas.height / camera.zoom) / 2;
      let worldWidth = worldMaxX - worldMinX;
      let worldHeight = worldMaxY - worldMinY;
      let targetX = player.position.x;
      let targetY = player.position.y;
      if (worldWidth < canvas.width / camera.zoom) {
        targetX = worldMinX + worldWidth / 2;
      } else {
        targetX = clamp(player.position.x, worldMinX + halfWidth, worldMaxX - halfWidth);
      }
      if (worldHeight < canvas.height / camera.zoom) {
        targetY = worldMinY + worldHeight / 2;
      } else {
        targetY = clamp(player.position.y, worldMinY + halfHeight, worldMaxY - halfHeight);
      }
      camera.position = new Vector2(targetX, targetY);
    }

    // ---------------------------
    // Create Player, Enemies, and Pickups
    // ---------------------------
    let player = new Player(5, 5, tileMap);
    const bullets = [];
    const enemies = [];
    let enemySpawnTimer = 0;
    const enemySpawnInterval = 3.0; // seconds.

    // ---------------------------
    // Input Listeners (Keyboard/Mouse)
    // ---------------------------
    document.addEventListener("keydown", (evt) => { player.keyDown(evt); });
    canvas.addEventListener("click", (evt) => {
      let rect = canvas.getBoundingClientRect();
      let mouseX = evt.clientX - rect.left;
      let mouseY = evt.clientY - rect.top;
      let worldTarget = camera.screenToWorld(new Vector2(mouseX, mouseY));
      player.shootAt(worldTarget);
    });

    // ---------------------------
    // Mobile Controls: Plus-shaped D-pad
    // ---------------------------
    // Coarse movement via four large touch areas.
    document.getElementById("dpad-up").addEventListener("touchstart", (evt) => {
      evt.preventDefault();
      if (!player.moving) player.move("up");
    });
    document.getElementById("dpad-down").addEventListener("touchstart", (evt) => {
      evt.preventDefault();
      if (!player.moving) player.move("down");
    });
    document.getElementById("dpad-left").addEventListener("touchstart", (evt) => {
      evt.preventDefault();
      if (!player.moving) player.move("left");
    });
    document.getElementById("dpad-right").addEventListener("touchstart", (evt) => {
      evt.preventDefault();
      if (!player.moving) player.move("right");
    });
    // Also support mouse events on the arms.
    document.getElementById("dpad-up").addEventListener("mousedown", () => { if (!player.moving) player.move("up"); });
    document.getElementById("dpad-down").addEventListener("mousedown", () => { if (!player.moving) player.move("down"); });
    document.getElementById("dpad-left").addEventListener("mousedown", () => { if (!player.moving) player.move("left"); });
    document.getElementById("dpad-right").addEventListener("mousedown", () => { if (!player.moving) player.move("right"); });

    // Refined attacking via dragging the small center disc.
    const centerDisc = document.getElementById("dpad-center");
    let refinedActive = false;
    const refinedThreshold = 8;  // Minimum displacement (in pixels) to trigger a refined shot.
    let startPosCenter = { x: 0, y: 0 };

    centerDisc.addEventListener("touchstart", (evt) => {
      evt.preventDefault();
      refinedActive = true;
      let rect = centerDisc.getBoundingClientRect();
      startPosCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    });
    centerDisc.addEventListener("touchmove", (evt) => {
      if (!refinedActive) return;
      evt.preventDefault();
      let touch = evt.touches[0];
      let offsetX = touch.clientX - startPosCenter.x;
      let offsetY = touch.clientY - startPosCenter.y;
      centerDisc.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
    });
    centerDisc.addEventListener("touchend", (evt) => {
      evt.preventDefault();
      if (!refinedActive) return;
      refinedActive = false;
      let style = window.getComputedStyle(centerDisc);
      let matrix = new DOMMatrixReadOnly(style.transform);
      let offsetX = matrix.m41;
      let offsetY = matrix.m42;
      // If movement exceeds threshold, fire a refined attack.
      if (Math.abs(offsetX) >= refinedThreshold || Math.abs(offsetY) >= refinedThreshold) {
        // Calculate target relative to player’s center.
        let playerCenter = new Vector2(player.position.x + player.width / 2, player.position.y + player.height / 2);
        let refinedTarget = playerCenter.add(new Vector2(offsetX, offsetY));
        player.shootAt(refinedTarget);
      }
      centerDisc.style.transition = "transform 0.2s";
      centerDisc.style.transform = "none";
      setTimeout(() => { centerDisc.style.transition = ""; }, 200);
    });
    // Also support mouse events for refined attack.
    centerDisc.addEventListener("mousedown", (evt) => {
      evt.preventDefault();
      refinedActive = true;
      let rect = centerDisc.getBoundingClientRect();
      startPosCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    });
    document.addEventListener("mousemove", (evt) => {
      if (!refinedActive) return;
      evt.preventDefault();
      let offsetX = evt.clientX - startPosCenter.x;
      let offsetY = evt.clientY - startPosCenter.y;
      centerDisc.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
    });
    document.addEventListener("mouseup", (evt) => {
      if (!refinedActive) return;
      refinedActive = false;
      let style = window.getComputedStyle(centerDisc);
      let matrix = new DOMMatrixReadOnly(style.transform);
      let offsetX = matrix.m41;
      let offsetY = matrix.m42;
      if (Math.abs(offsetX) >= refinedThreshold || Math.abs(offsetY) >= refinedThreshold) {
        let playerCenter = new Vector2(player.position.x + player.width / 2, player.position.y + player.height / 2);
        let refinedTarget = playerCenter.add(new Vector2(offsetX, offsetY));
        player.shootAt(refinedTarget);
      }
      centerDisc.style.transition = "transform 0.2s";
      centerDisc.style.transform = "none";
      setTimeout(() => { centerDisc.style.transition = ""; }, 200);
    });

    // Shoot button events.
    const shootBtn = document.getElementById("shootBtn");
    shootBtn.addEventListener("touchstart", (evt) => {
      evt.preventDefault();
      player.shoot();
    });
    shootBtn.addEventListener("mousedown", (evt) => {
      player.shoot();
    });

    // ---------------------------
    // Draw HUD – Display Player HP and Kill Count.
    // ---------------------------
    function drawHUD(ctx) {
      ctx.fillStyle = "black";
      ctx.fillRect(20, 20, 200, 24);
      ctx.fillStyle = "red";
      let hpWidth = (player.hp / player.maxHP) * 100;
      ctx.fillRect(22, 22, hpWidth, 20);
      ctx.strokeStyle = "white";
      ctx.strokeRect(20, 20, 200, 24);
      ctx.fillStyle = "white";
      ctx.font = "16px Arial";
      ctx.fillText("HP: " + player.hp, 30, 38);
      ctx.fillText("Kills: " + killCount, 130, 38);
    }

    // ---------------------------
    // Main Game Loop
    // ---------------------------
    let lastTime = performance.now();
    function gameLoop() {
      let currentTime = performance.now();
      let deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      let effectiveDelta = deltaTime * timeScale;

      player.update(effectiveDelta);
      enemies.forEach((enemy) => enemy.update(effectiveDelta));
      bullets.forEach((bullet) => bullet.update(effectiveDelta));
      updateEffects(effectiveDelta);

      // Bullet collision checks.
      bullets.forEach((bullet) => {
        if (bullet.owner === "player") {
          enemies.forEach((enemy) => {
            if (
              bullet.position.x >= enemy.position.x &&
              bullet.position.x <= enemy.position.x + enemy.width &&
              bullet.position.y >= enemy.position.y &&
              bullet.position.y <= enemy.position.y + enemy.height
            ) {
              bullet.alive = false;
              enemy.hp -= 20;
              let knockForce = bullet.velocity.normalize().scale(20);
              enemy.knockback = enemy.knockback.add(knockForce);
              screenShakeTime = 0.2;
              screenShakeMagnitude = 10;
              if (enemy.hp <= 0 && enemy.alive) {
                spawnBloodEffect(enemy.position);
                enemy.alive = false;
                killCount++;
              }
            }
          });
        } else if (bullet.owner === "enemy") {
          if (
            bullet.position.x >= player.position.x &&
            bullet.position.x <= player.position.x + player.width &&
            bullet.position.y >= player.position.y &&
            bullet.position.y <= player.position.y + player.height
          ) {
            bullet.alive = false;
            player.hp -= 20;
            screenShakeTime = 0.2;
            screenShakeMagnitude = 5;
            if (player.hp <= 0 && !player.isDead) {
              player.isDead = true;
              spawnBloodEffect(player.position);
              slowMotionTimer = 1.0;
              timeScale = 0.2;
              player.knockback = player.knockback.add(new Vector2(0, -50));
            }
          }
        }
      });

      // Remove dead bullets.
      for (let i = bullets.length - 1; i >= 0; i--) {
        if (!bullets[i].alive) bullets.splice(i, 1);
      }
      // Remove dead enemies.
      for (let i = enemies.length - 1; i >= 0; i--) {
        if (!enemies[i].alive) enemies.splice(i, 1);
      }

      enemySpawnTimer += effectiveDelta;
      if (enemySpawnTimer >= enemySpawnInterval) {
        enemySpawnTimer = 0;
        let edge = Math.floor(Math.random() * 4);
        let gridX, gridY;
        if (edge === 0) {
          gridX = 0;
          gridY = Math.floor(Math.random() * tileMap.height);
        } else if (edge === 1) {
          gridX = tileMap.width - 1;
          gridY = Math.floor(Math.random() * tileMap.height);
        } else if (edge === 2) {
          gridY = 0;
          gridX = Math.floor(Math.random() * tileMap.width);
        } else {
          gridY = tileMap.height - 1;
          gridX = Math.floor(Math.random() * tileMap.width);
        }
        enemies.push(new Enemy(gridX, gridY, tileMap));
      }

      pickupSpawnTimer += effectiveDelta;
      if (pickupSpawnTimer >= pickupSpawnInterval) {
        pickupSpawnTimer = 0;
        let gridX = Math.floor(Math.random() * tileMap.width);
        let gridY = Math.floor(Math.random() * tileMap.height);
        pickups.push(new HealthPickup(gridX, gridY, tileMap));
      }

      for (let i = pickups.length - 1; i >= 0; i--) {
        let pickup = pickups[i];
        if (
          player.position.x < pickup.position.x + pickup.size &&
          player.position.x + player.width > pickup.position.x &&
          player.position.y < pickup.position.y + pickup.size &&
          player.position.y + player.height > pickup.position.y
        ) {
          player.hp = Math.min(player.hp + 20, player.maxHP);
          spawnPickupEffect(pickup.position);
          pickups.splice(i, 1);
        }
      }

      enemies.forEach((enemy) => resolveCollision(player, enemy));
      for (let i = 0; i < enemies.length; i++) {
        for (let j = i + 1; j < enemies.length; j++) {
          resolveCollision(enemies[i], enemies[j]);
        }
      }

      if (screenShakeTime > 0) {
        screenShakeTime -= effectiveDelta;
        shakeOffset = new Vector2(
          (Math.random() * 2 - 1) * screenShakeMagnitude,
          (Math.random() * 2 - 1) * screenShakeMagnitude
        );
      } else {
        shakeOffset = new Vector2(0, 0);
      }

      updateCamera();
      let renderCamera = new Camera(camera.screenWidth, camera.screenHeight);
      renderCamera.zoom = camera.zoom;
      renderCamera.position = camera.position.add(shakeOffset);

      if (player.isDead) {
        slowMotionTimer -= deltaTime;
        if (slowMotionTimer <= 0) {
          player.respawn();
          player.isDead = false;
          timeScale = 1.0;
        }
      }

      ctx.fillStyle = "#505050";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      tileMap.render(ctx, renderCamera);
      enemies.forEach((enemy) => enemy.render(ctx, renderCamera));
      pickups.forEach((pickup) => pickup.render(ctx, renderCamera));
      bullets.forEach((bullet) => bullet.render(ctx, renderCamera));
      renderEffects(ctx, renderCamera);
      player.render(ctx, renderCamera);
      drawHUD(ctx);

      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
