<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- Prevent unwanted zooming -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Destructible World with AI, HP Bars & Bubble Busting</title>
  <style>
    /* Reset & Full-Screen Setup */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; touch-action: manipulation; }
    body {
      background: #666;
      font-family: sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    /* Game Shell */
    #gameboy {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #a3c1a3;
      overflow: hidden;
    }
    /* Screen */
    #screen {
      position: absolute;
      top: 0; left: 0;
      width: 100vw;
      height: calc(100vw * 1);
      background: #000;
      border-bottom: 8px solid #444;
      overflow: hidden;
    }
    /* Game World Container */
    #game {
      position: absolute;
      top: 0; left: 0;
    }
    /* Ground area below play area */
    #ground {
      position: absolute;
      left: 0;
      background: #855;
    }
    /* Controls (D-pad & A/B Buttons) */
    #controls { position: absolute; bottom: 5%; width: 100vw; height: 40vh; }
    #dpad {
      position: absolute; left: 5%; bottom: 5%;
      width: 150px; height: 150px;
    }
    #dpad button {
      position: absolute; background: #333;
      border: 3px solid #777; border-radius: 10px;
      cursor: pointer; touch-action: manipulation;
      font-size: 0;
    }
    #dpad button:active { background: #777; }
    #dpad .up    { top: 0; left: 45px; width: 60px; height: 60px; }
    #dpad .down  { bottom: 0; left: 45px; width: 60px; height: 60px; }
    #dpad .left  { top: 45px; left: 0; width: 60px; height: 60px; }
    #dpad .right { top: 45px; right: 0; width: 60px; height: 60px; }
    #ab-buttons {
      position: absolute; right: 5%; bottom: 5%;
      width: 150px; height: 150px;
    }
    #ab-buttons button {
      position: absolute; background: #333;
      border: 3px solid #777; border-radius: 50%;
      cursor: pointer; touch-action: manipulation;
      font-size: 0;
    }
    #ab-buttons button:active { background: #777; }
    #ab-buttons .A { width: 70px; height: 70px; top: 0; right: 0; }
    #ab-buttons .B { width: 70px; height: 70px; bottom: 0; left: 0; }
    /* In-Game Entity Styling */
    .entity {
      position: absolute;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      transition: transform 0.5s ease, opacity 0.5s ease;
    }
    /* HP Bar Styling */
    .hp-bar-container {
      position: absolute;
      width: 50px;
      height: 6px;
      background: rgba(0,0,0,0.5);
      border: 1px solid #000;
      border-radius: 3px;
      pointer-events: none;
    }
    .hp-bar {
      width: 100%;
      height: 100%;
      background: lime;
      border-radius: 3px;
    }
    /* Bubble style for player (green) */
    .player-part {
      background: radial-gradient(circle, rgba(0,255,0,0.7) 0%, rgba(0,255,0,0.3) 60%, rgba(0,255,0,0) 100%);
      border: 2px solid rgba(255,255,255,0.7);
      box-shadow: 0 0 8px rgba(0,255,0,0.7);
    }
    /* Bubble style for enemy (red) */
    .enemy-part {
      background: radial-gradient(circle, rgba(255,0,0,0.7) 0%, rgba(255,0,0,0.3) 60%, rgba(255,0,0,0) 100%);
      border: 2px solid rgba(255,255,255,0.7);
      box-shadow: 0 0 8px rgba(255,0,0,0.7);
    }
    /* Bubble burst effect */
    .bubble-burst {
      transform: translate(-50%, -50%) scale(2);
      opacity: 0;
    }
    .bullet { background: #fff; }
    .coin {
      background: gold;
      color: black;
      font-size: 14px;
      line-height: 16px;
      text-align: center;
      border-radius: 0;
    }
    .tv {
      position: absolute;
      background: #444;
      border: 2px solid #999;
      border-radius: 4px;
    }
    .platform {
      position: absolute;
      background: #555;
    }
  </style>
</head>
<body>
  <div id="gameboy">
    <div id="screen">
      <div id="game"></div>
    </div>
    <div id="controls">
      <div id="dpad">
        <button class="up"></button>
        <button class="down"></button>
        <button class="left"></button>
        <button class="right"></button>
      </div>
      <div id="ab-buttons">
        <button class="A"></button>
        <button class="B"></button>
      </div>
    </div>
  </div>

  <!-- Matter.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    // Destructure Matter modules.
    const { Engine, World, Bodies, Body, Constraint, Events } = Matter;
    const engine = Engine.create();
    engine.world.gravity.y = 3.2;
    const world = engine.world;
    const game = document.getElementById("game");

    // Game dimensions.
    const levelWidth = 3000;
    const playAreaHeight = document.getElementById("screen").getBoundingClientRect().height;
    const groundExtraHeight = 200;
    const gameHeight = playAreaHeight + groundExtraHeight;
    game.style.width = levelWidth + "px";
    game.style.height = gameHeight + "px";

    // Ground visual element.
    const groundEl = document.createElement("div");
    groundEl.id = "ground";
    groundEl.style.top = playAreaHeight + "px";
    groundEl.style.width = levelWidth + "px";
    groundEl.style.height = groundExtraHeight + "px";
    game.appendChild(groundEl);

    let domEntities = [], platforms = [], tvs = [], coins = [], bullets = [];

    // Helper: create a DOM element for a Matter body.
    function createDomElement(body, cls, w, h) {
      const el = document.createElement("div");
      el.className = "entity " + cls;
      el.style.width = w + "px";
      el.style.height = h + "px";
      game.appendChild(el);
      body.domElement = el;
      domEntities.push(body);
    }

    // Add static boundaries.
    const groundBody = Bodies.rectangle(levelWidth / 2, playAreaHeight, levelWidth, 40, { isStatic: true });
    const leftWall = Bodies.rectangle(0, playAreaHeight / 2, 40, playAreaHeight, { isStatic: true });
    const rightWall = Bodies.rectangle(levelWidth, playAreaHeight / 2, 40, playAreaHeight, { isStatic: true });
    World.add(world, [groundBody, leftWall, rightWall]);

    // Safety floor.
    const safetyFloorY = playAreaHeight + 50;
    const safetyFloor = Bodies.rectangle(levelWidth / 2, safetyFloorY, levelWidth, 40, {
      isStatic: true,
      label: "safetyFloor"
    });
    World.add(world, safetyFloor);

    // --- Character Factory ---
    // Creates a character (player or enemy) with bubble-style parts and an HP bar.
    function createCharacter(x, y, isEnemy) {
      const char = { hp: 100, alive: true, isEnemy: isEnemy, spawn: { x, y }, shootCooldown: 0 };
      const size = 20;
      const torsoOptions = { friction: 6.0, frictionAir: 0.01, restitution: 0 };
      const defaultOptions = { friction: 0.5, frictionAir: 0.01, restitution: 0 };
      const partClass = isEnemy ? "enemy-part" : "player-part";

      // Create an HP bar.
      const hpContainer = document.createElement("div");
      hpContainer.className = "hp-bar-container";
      const hpBar = document.createElement("div");
      hpBar.className = "hp-bar";
      hpContainer.appendChild(hpBar);
      game.appendChild(hpContainer);
      char.hpContainer = hpContainer;
      char.hpBar = hpBar;

      function addPart(body, cls, w, h) {
        createDomElement(body, cls, w, h);
        body.character = char;
        return body;
      }

      // Build parts.
      const head = Bodies.circle(x, y - 40, size / 2, defaultOptions);
      addPart(head, partClass, size, size);
      const torso = Bodies.circle(x, y - 20, size, torsoOptions);
      addPart(torso, partClass, size * 2, size * 2);
      const rightUpperArm = Bodies.circle(x + 30, y - 20, size / 2, defaultOptions);
      addPart(rightUpperArm, partClass, size, size);
      const rightHand = Bodies.circle(x + 30, y - 20 + 20, size / 2, defaultOptions);
      addPart(rightHand, partClass, size, size);
      const leftUpperArm = Bodies.circle(x - 30, y - 20, size / 2, defaultOptions);
      addPart(leftUpperArm, partClass, size, size);
      const leftHand = Bodies.circle(x - 30, y - 20 + 20, size / 2, defaultOptions);
      addPart(leftHand, partClass, size, size);
      const rightUpperLeg = Bodies.circle(x + 10, y + 10, size / 2, defaultOptions);
      addPart(rightUpperLeg, partClass, size, size);
      const rightFoot = Bodies.circle(x + 10, y + 10 + 20, size / 2, defaultOptions);
      addPart(rightFoot, partClass, size, size);
      const leftUpperLeg = Bodies.circle(x - 10, y + 10, size / 2, defaultOptions);
      addPart(leftUpperLeg, partClass, size, size);
      const leftFoot = Bodies.circle(x - 10, y + 10 + 20, size / 2, defaultOptions);
      addPart(leftFoot, partClass, size, size);

      World.add(world, [head, torso, rightUpperArm, rightHand, leftUpperArm, leftHand, rightUpperLeg, rightFoot, leftUpperLeg, leftFoot]);

      // Create constraints.
      function link(a, b, offA, offB) {
        const con = Constraint.create({
          bodyA: a, pointA: offA, bodyB: b, pointB: offB,
          stiffness: 1, length: 0.1
        });
        World.add(world, con);
      }
      link(head, torso, { x: 0, y: size / 2 }, { x: 0, y: -size });
      link(torso, rightUpperArm, { x: size, y: 0 }, { x: 0, y: 0 });
      link(rightUpperArm, rightHand, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, leftUpperArm, { x: -size, y: 0 }, { x: 0, y: 0 });
      link(leftUpperArm, leftHand, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, rightUpperLeg, { x: 10, y: size }, { x: 0, y: -size / 2 });
      link(rightUpperLeg, rightFoot, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, leftUpperLeg, { x: -10, y: size }, { x: 0, y: -size / 2 });
      link(leftUpperLeg, leftFoot, { x: 0, y: 0 }, { x: 0, y: -20 });

      char.head = head; char.torso = torso;
      char.rightUpperArm = rightUpperArm; char.rightHand = rightHand;
      char.leftUpperArm = leftUpperArm; char.leftHand = leftHand;
      char.rightUpperLeg = rightUpperLeg; char.rightFoot = rightFoot;
      char.leftUpperLeg = leftUpperLeg; char.leftFoot = leftFoot;
      return char;
    }

    // Global single instances.
    let playerChar = createCharacter(100, 100, false);
    let enemyChar = createCharacter(400, 100, true);

    // --- Bullet Shooting ---
    // Bullets record their owner to avoid friendly fire.
    function shootBullet(x, y, tx, ty, owner) {
      const bullet = Bodies.circle(x, y, 5, { friction: 0, frictionAir: 0.01, label: "bullet" });
      bullet.owner = owner;
      const angle = Math.atan2(ty - y, tx - x);
      const speed = 35;
      Body.setVelocity(bullet, { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed });
      World.add(world, bullet);
      createDomElement(bullet, "bullet", 10, 10);
      bullets.push(bullet);
    }
    // Player shooting.
    function playerShoot() {
      let dx = 0, dy = 0;
      if (keys["ArrowUp"])    dy = -1;
      if (keys["ArrowDown"])  dy =  1;
      if (keys["ArrowLeft"])  dx = -1;
      if (keys["ArrowRight"]) dx =  1;
      if (dx === 0 && dy === 0) dx = playerChar.facingDirection || 1;
      const mag = Math.hypot(dx, dy);
      dx /= mag; dy /= mag;
      let origin;
      if ((playerChar.facingDirection || 1) > 0) {
        Body.setPosition(playerChar.rightHand, { x: playerChar.rightUpperArm.position.x + 20, y: playerChar.rightUpperArm.position.y });
        origin = { x: playerChar.rightHand.position.x, y: playerChar.rightHand.position.y };
      } else {
        Body.setPosition(playerChar.leftHand, { x: playerChar.leftUpperArm.position.x - 20, y: playerChar.leftUpperArm.position.y });
        origin = { x: playerChar.leftHand.position.x, y: playerChar.leftHand.position.y };
      }
      shootBullet(origin.x, origin.y, origin.x + dx * 100, origin.y + dy * 100, playerChar);
    }
    // Enemy shooting aimed at the player.
    function enemyShoot() {
      const origin = { x: enemyChar.rightHand.position.x, y: enemyChar.rightHand.position.y };
      let dx = playerChar.torso.position.x - origin.x;
      let dy = playerChar.torso.position.y - origin.y;
      const mag = Math.hypot(dx, dy);
      dx /= mag; dy /= mag;
      shootBullet(origin.x, origin.y, origin.x + dx * 100, origin.y + dy * 100, enemyChar);
    }

    // --- Damage, Knockback & Bubble Busting ---
    // When a bullet hits a character (that isn’t its owner), damage is subtracted,
    // a knockback force (opposite bullet direction) is applied, and if HP is depleted,
    // the character bursts (each part gets a random force and the bubble-burst effect is applied).
    function takeDamage(character, damage, bullet) {
      if (!character.alive) return;
      character.hp -= damage;
      // Knockback effect.
      const knockbackFactor = 0.001;
      if (bullet && bullet.velocity) {
        Body.applyForce(character.torso, character.torso.position, {
          x: -bullet.velocity.x * knockbackFactor,
          y: -bullet.velocity.y * knockbackFactor
        });
      }
      // Update HP bar width.
      if (character.hpBar) {
        const percent = Math.max(character.hp, 0) / 100;
        character.hpBar.style.width = (percent * 100) + "%";
      }
      // If HP is depleted, burst the bubble.
      if (character.hp <= 0) {
        character.alive = false;
        [character.head, character.torso, character.rightUpperArm, character.rightHand,
         character.leftUpperArm, character.leftHand, character.rightUpperLeg, character.rightFoot,
         character.leftUpperLeg, character.leftFoot].forEach(part => {
          if (part) {
            // Apply random scattering force.
            Body.applyForce(part, part.position, {
              x: (Math.random() - 0.5) * 0.02,
              y: (Math.random() - 0.5) * 0.02
            });
            if (part.domElement) {
              part.domElement.classList.add("bubble-burst");
            }
          }
        });
        // Remove parts and HP bar after animation, then respawn.
        setTimeout(() => {
          [character.head, character.torso, character.rightUpperArm, character.rightHand,
           character.leftUpperArm, character.leftHand, character.rightUpperLeg, character.rightFoot,
           character.leftUpperLeg, character.leftFoot].forEach(part => {
            World.remove(world, part);
            if (part.domElement && part.domElement.parentNode) {
              part.domElement.parentNode.removeChild(part.domElement);
            }
          });
          if (character.hpContainer && character.hpContainer.parentNode) {
            character.hpContainer.parentNode.removeChild(character.hpContainer);
          }
          if (character.isEnemy) {
            enemyChar = createCharacter(character.spawn.x, character.spawn.y, true);
          } else {
            playerChar = createCharacter(character.spawn.x, character.spawn.y, false);
          }
        }, 500);
      }
    }

    // --- Collision Handling for Bullets ---
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        if (pair.bodyA.label === "bullet" && pair.bodyB.character) {
          if (pair.bodyB.character !== pair.bodyA.owner) {
            World.remove(world, pair.bodyA);
            if (pair.bodyA.domElement && pair.bodyA.domElement.parentNode) {
              pair.bodyA.domElement.parentNode.removeChild(pair.bodyA.domElement);
            }
            takeDamage(pair.bodyB.character, 20, pair.bodyA);
          }
        } else if (pair.bodyB.label === "bullet" && pair.bodyA.character) {
          if (pair.bodyA.character !== pair.bodyB.owner) {
            World.remove(world, pair.bodyB);
            if (pair.bodyB.domElement && pair.bodyB.domElement.parentNode) {
              pair.bodyB.domElement.parentNode.removeChild(pair.bodyB.domElement);
            }
            takeDamage(pair.bodyA.character, 20, pair.bodyB);
          }
        }
      });
    });

    // --- Destructible World Collisions (Unchanged) ---
    const destructionSpeedThreshold = 20;
    function isPlayerPart(body) {
      return body === playerChar.head || body === playerChar.torso ||
             body === playerChar.rightUpperArm || body === playerChar.rightHand ||
             body === playerChar.leftUpperArm || body === playerChar.leftHand ||
             body === playerChar.rightUpperLeg || body === playerChar.rightFoot ||
             body === playerChar.leftUpperLeg || body === playerChar.leftFoot ||
             body === enemyChar.head || body === enemyChar.torso ||
             body === enemyChar.rightUpperArm || body === enemyChar.rightHand ||
             body === enemyChar.leftUpperArm || body === enemyChar.leftHand ||
             body === enemyChar.rightUpperLeg || body === enemyChar.rightFoot ||
             body === enemyChar.leftUpperLeg || body === enemyChar.leftFoot;
    }
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        let playerPart = null, other = null;
        if (isPlayerPart(pair.bodyA) && pair.bodyB.isStatic) {
          playerPart = pair.bodyA;
          other = pair.bodyB;
        } else if (isPlayerPart(pair.bodyB) && pair.bodyA.isStatic) {
          playerPart = pair.bodyB;
          other = pair.bodyA;
        }
        if (other && other.label !== "safetyFloor") {
          const vx = playerChar.torso.velocity.x, vy = playerChar.torso.velocity.y;
          const playerSpeed = Math.hypot(vx, vy);
          if (playerSpeed >= destructionSpeedThreshold) {
            World.remove(world, other);
            if (other.domElement && other.domElement.parentNode) {
              other.domElement.parentNode.removeChild(other.domElement);
            }
            const platIndex = platforms.indexOf(other);
            if (platIndex !== -1) platforms.splice(platIndex, 1);
            const tvIndex = tvs.indexOf(other);
            if (tvIndex !== -1) tvs.splice(tvIndex, 1);
          }
        }
      });
    });

    // --- Input Handling ---
    let keys = {};
    window.addEventListener("keydown", (e) => { keys[e.code] = true; });
    window.addEventListener("keyup", (e) => { keys[e.code] = false; });

    // --- Smoothed Dynamic Camera ---
    let currentOffsetX = 0, currentOffsetY = 0, currentZoom = 1;
    function lerp(a, b, t) { return a + (b - a) * t; }
    function updateCamera() {
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      const vx = playerChar.torso.velocity.x;
      const vy = playerChar.torso.velocity.y;
      const speed = Math.hypot(vx, vy);
      const zoomIn = 1.2, zoomOut = 0.8, maxSpeed = 10;
      const t = Math.min(speed / maxSpeed, 1);
      const zoom = zoomIn * (1 - t) + zoomOut * t;
      const visibleWidth = screenWidth / zoom;
      const visibleHeight = screenHeight / zoom;
      const cameraCenterX = playerChar.torso.position.x;
      const cameraCenterY = playerChar.torso.position.y;
      const targetOffsetX = Math.max(0, Math.min(cameraCenterX - visibleWidth / 2, levelWidth - visibleWidth));
      const targetOffsetY = Math.max(0, cameraCenterY - visibleHeight / 2);
      const smoothingFactor = 0.1;
      currentZoom = lerp(currentZoom, zoom, smoothingFactor);
      currentOffsetX = lerp(currentOffsetX, targetOffsetX, smoothingFactor);
      currentOffsetY = lerp(currentOffsetY, targetOffsetY, smoothingFactor);
      game.style.transformOrigin = "top left";
      game.style.transform = `scale(${currentZoom}) translate(-${currentOffsetX}px, -${currentOffsetY}px)`;
    }

    // --- Player Bounding & Damping ---
    function clampPlayer() {
      const margin = 50;
      const pos = playerChar.torso.position;
      const vel = playerChar.torso.velocity;
      if (pos.x < margin) {
        Body.setPosition(playerChar.torso, { x: margin, y: pos.y });
        if (vel.x < 0) Body.setVelocity(playerChar.torso, { x: vel.x * 0.5, y: vel.y });
      } else if (pos.x > levelWidth - margin) {
        Body.setPosition(playerChar.torso, { x: levelWidth - margin, y: pos.y });
        if (vel.x > 0) Body.setVelocity(playerChar.torso, { x: vel.x * 0.5, y: vel.y });
      }
      if (pos.y < margin) {
        Body.setPosition(playerChar.torso, { x: pos.x, y: margin });
        if (vel.y < 0) Body.setVelocity(playerChar.torso, { x: vel.x, y: vel.y * 0.5 });
      }
    }

    // --- Leg Animation ---
    let walkCycle = 0, lastTime = Date.now();
    function updateWalkCycle() {
      const now = Date.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;
      if (playerChar.isGrounded && (keys["ArrowLeft"] || keys["ArrowRight"])) {
        walkCycle += dt * 6;
        const maxAngle = Math.PI / 12;
        const leftLegOffset = Math.sin(walkCycle) * maxAngle;
        const rightLegOffset = Math.sin(walkCycle + Math.PI) * maxAngle;
        Body.setAngle(playerChar.leftUpperLeg, playerChar.torso.angle + leftLegOffset);
        Body.setAngle(playerChar.rightUpperLeg, playerChar.torso.angle + rightLegOffset);
        Body.setAngle(playerChar.leftFoot, playerChar.torso.angle + leftLegOffset);
        Body.setAngle(playerChar.rightFoot, playerChar.torso.angle + rightLegOffset);
      } else {
        walkCycle = 0;
      }
    }

    // --- Enemy AI ---
    function updateEnemyAI() {
      if (!enemyChar || !enemyChar.alive) return;
      const dx = playerChar.torso.position.x - enemyChar.torso.position.x;
      const dy = playerChar.torso.position.y - enemyChar.torso.position.y;
      const mag = Math.hypot(dx, dy);
      if (mag > 0) {
        Body.applyForce(enemyChar.torso, enemyChar.torso.position, { x: (dx/mag)*0.005, y: (dy/mag)*0.005 });
      }
      enemyChar.shootCooldown -= 1000/60;
      if (enemyChar.shootCooldown <= 0) {
        enemyShoot();
        enemyChar.shootCooldown = 1000;
      }
    }

    // --- Main Game Loop ---
    function update() {
      Engine.update(engine, 1000/60);
      domEntities.forEach(body => {
        if (body.domElement) {
          body.domElement.style.left = body.position.x + "px";
          body.domElement.style.top = body.position.y + "px";
          body.domElement.style.transform = "translate(-50%, -50%) rotate(" + body.angle + "rad)";
        }
      });
      
      // Player movement input.
      if (keys["ArrowLeft"]) {
        playerChar.facingDirection = -1;
        Body.applyForce(playerChar.torso, playerChar.torso.position, { x: -0.01, y: 0 });
      }
      if (keys["ArrowRight"]) {
        playerChar.facingDirection = 1;
        Body.applyForce(playerChar.torso, playerChar.torso.position, { x: 0.01, y: 0 });
      }
      if (!keys["ArrowLeft"] && !keys["ArrowRight"]) {
        Body.setVelocity(playerChar.torso, { x: playerChar.torso.velocity.x * 0.98, y: playerChar.torso.velocity.y });
      }
      // Simple jump.
      if (keys["KeyB"] || keys["Space"]) {
        Body.setVelocity(playerChar.torso, { x: playerChar.torso.velocity.x, y: -22 });
      }
      // Keep head aligned.
      Body.setPosition(playerChar.head, { x: playerChar.torso.position.x, y: playerChar.torso.position.y - 40 });
      Body.setVelocity(playerChar.head, playerChar.torso.velocity);

      updateCamera();
      clampPlayer();
      updateWalkCycle();
      updateEnemyAI();

      // Fallback: if player falls too far while alive, mark as dead and respawn.
      if (playerChar.alive && playerChar.torso.position.y > safetyFloorY + 100) {
        playerChar.alive = false;
        setTimeout(() => {
          playerChar = createCharacter(playerChar.spawn.x, playerChar.spawn.y, false);
        }, 500);
      }

      // Update HP bars.
      function updateHpBar(character) {
        if (!character.hpContainer) return;
        character.hpContainer.style.left = (character.torso.position.x - 25) + "px";
        character.hpContainer.style.top = (character.torso.position.y - 60) + "px";
      }
      if (playerChar) updateHpBar(playerChar);
      if (enemyChar) updateHpBar(enemyChar);

      requestAnimationFrame(update);
    }
    update();

    // --- Touch & Button Mappings ---
    const dpad = document.getElementById("dpad");
    dpad.querySelector(".up").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowUp"] = true; });
    dpad.querySelector(".up").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowUp"] = false; });
    dpad.querySelector(".down").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowDown"] = true; });
    dpad.querySelector(".down").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowDown"] = false; });
    dpad.querySelector(".left").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowLeft"] = true; });
    dpad.querySelector(".left").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowLeft"] = false; });
    dpad.querySelector(".right").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowRight"] = true; });
    dpad.querySelector(".right").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowRight"] = false; });
    const abButtons = document.getElementById("ab-buttons");
    abButtons.querySelector(".A").addEventListener("touchstart", (e) => { e.preventDefault(); playerShoot(); });
    abButtons.querySelector(".B").addEventListener("touchstart", (e) => { e.preventDefault(); keys["Space"] = true; });
    abButtons.querySelector(".B").addEventListener("touchend", (e) => { e.preventDefault(); keys["Space"] = false; });
  </script>
</body>
</html>
