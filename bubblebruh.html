<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Pipe Drain Tunneling Game</title>
  <style>
    /* Basic Reset & Full-Screen Setup */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; }
    body { background: #666; font-family: sans-serif; }

    /* Game Shell */
    #gameboy {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #a3c1a3;
      overflow: hidden;
    }
    /* Screen */
    #screen {
      position: absolute;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      overflow: hidden;
    }
    /* Game World Container – our world is 3000px wide */
    #game {
      position: absolute;
      top: 0;
      left: 0;
      /* We'll update its transform to follow the player */
    }
    /* Drain (ground) – a simple static bar at the bottom */
    #ground {
      position: absolute;
      left: 0;
      background: #855;
    }
    /* Controls (D-pad & buttons) */
    #controls {
      position: absolute;
      bottom: 5%;
      width: 100vw;
      height: 40vh;
      z-index: 10;
    }
    /* D-Pad */
    #dpad {
      position: absolute;
      left: 5%;
      bottom: 5%;
      width: 150px;
      height: 150px;
    }
    #dpad button {
      position: absolute;
      background: #333;
      border: 3px solid #777;
      border-radius: 10px;
      font-size: 0;
      touch-action: manipulation;
      cursor: pointer;
    }
    #dpad button:active { background: #777; }
    #dpad .up    { top: 0; left: 45px; width: 60px; height: 60px; }
    #dpad .down  { bottom: 0; left: 45px; width: 60px; height: 60px; }
    #dpad .left  { top: 45px; left: 0; width: 60px; height: 60px; }
    #dpad .right { top: 45px; right: 0; width: 60px; height: 60px; }
    /* Joystick Disc */
    #dpad #joystick {
      position: absolute;
      top: 45px;
      left: 45px;
      width: 60px;
      height: 60px;
      background: #333;
      border: 3px solid #777;
      border-radius: 50%;
      z-index: 3;
      touch-action: none;
    }
    /* A/B/C Buttons */
    #ab-buttons {
      position: absolute;
      right: 0%;
      bottom: 5%;
      width: 250px;
      height: 80px;
      display: flex;
      flex-direction: row;
      justify-content: space-around;
      align-items: flex-end;
    }
    #ab-buttons button:nth-child(1) { transform: translateY(-30px); }
    #ab-buttons button:nth-child(2) { transform: translateY(-10px); }
    #ab-buttons button:nth-child(3) { transform: translateY(-20px); }
    #ab-buttons button {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: #333;
      border: 3px solid #777;
      font-size: 0;
      touch-action: manipulation;
      cursor: pointer;
    }
    #ab-buttons button:active { background: #777; }

    /* In-Game Entities */
    .entity {
      position: absolute;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      transition: transform 0.5s ease, opacity 0.5s ease;
    }
    /* HP Bar */
    .hp-bar-container {
      position: absolute;
      width: 50px;
      height: 6px;
      background: rgba(0,0,0,0.5);
      border: 1px solid #000;
      border-radius: 3px;
      pointer-events: none;
    }
    .hp-bar {
      width: 100%;
      height: 100%;
      background: lime;
      border-radius: 3px;
    }
    /* Player parts */
    .player-part {
      background: radial-gradient(circle, rgba(0,255,0,0.7) 0%, rgba(0,255,0,0.3) 60%, rgba(0,255,0,0) 100%);
      border: 2px solid rgba(255,255,255,0.7);
      box-shadow: 0 0 8px rgba(0,255,0,0.7);
    }
    .bullet { background: #fff; }
    .bubble-burst {
      transform: translate(-50%, -50%) scale(2);
      opacity: 0;
    }
    /* Floor Tiles (the breakable CSS floor) */
    .tile {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #4a4a4a;
      border: 1px solid #333;
    }
    /* Other objects (platforms, TVs, walls) */
    .platform { position: absolute; background: #555; }
    .tv {
      position: absolute;
      background: #444;
      border: 2px solid #999;
      border-radius: 4px;
    }
    .coin {
      position: absolute;
      background: gold;
      color: black;
      border-radius: 50%;
      font-size: 14px;
      line-height: 20px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="gameboy">
    <div id="screen">
      <div id="game"></div>
    </div>
    <div id="controls">
      <div id="dpad">
        <button class="up"></button>
        <button class="down"></button>
        <button class="left"></button>
        <button class="right"></button>
        <div id="joystick"></div>
      </div>
      <div id="ab-buttons">
        <button class="A"></button>
        <button class="B"></button>
        <button class="C"></button>
      </div>
    </div>
  </div>

  <!-- Matter.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    // ------------------------------
    // Global Helpers & Screen Shake
    // ------------------------------
    let lastScreenShakeTime = 0;
    function throttledScreenShake(intensity = 5, duration = 300, cooldown = 500) {
      const now = Date.now();
      if (now - lastScreenShakeTime > cooldown) {
        lastScreenShakeTime = now;
        screenShake(intensity, duration);
      }
    }
    function screenShake(intensity = 5, duration = 300) {
      const screen = document.getElementById("screen");
      const startTime = Date.now();
      (function shake() {
        const elapsed = Date.now() - startTime;
        if (elapsed < duration) {
          const dx = (Math.random() - 0.5) * intensity;
          const dy = (Math.random() - 0.5) * intensity;
          screen.style.transform = `translate(${dx}px, ${dy}px)`;
          requestAnimationFrame(shake);
        } else {
          screen.style.transform = "";
        }
      })();
    }
    function particleBurst(x, y, color) {
      const numParticles = 20;
      for (let i = 0; i < numParticles; i++) {
        const particle = document.createElement("div");
        particle.style.position = "absolute";
        particle.style.left = x + "px";
        particle.style.top = y + "px";
        particle.style.width = "4px";
        particle.style.height = "4px";
        particle.style.backgroundColor = color;
        particle.style.borderRadius = "50%";
        particle.style.pointerEvents = "none";
        particle.style.opacity = "1";
        particle.style.transform = "translate(-50%, -50%)";
        game.appendChild(particle);
        const angle = Math.random() * 2 * Math.PI;
        const distance = Math.random() * 50 + 20;
        const deltaX = Math.cos(angle) * distance;
        const deltaY = Math.sin(angle) * distance;
        particle.animate([
          { transform: `translate(0px, 0px)`, opacity: 1 },
          { transform: `translate(${deltaX}px, ${deltaY}px)`, opacity: 0 }
        ], {
          duration: 800 + Math.random() * 400,
          easing: "ease-out",
          fill: "forwards"
        });
        setTimeout(() => { if (particle.parentNode) particle.parentNode.removeChild(particle); }, 1200);
      }
    }

    // ------------------------------
    // Matter.js Setup & World
    // ------------------------------
    const { Engine, World, Bodies, Body, Constraint, Events } = Matter;
    const engine = Engine.create();
    engine.world.gravity.y = 3.2;
    const world = engine.world;
    const game = document.getElementById("game");

    // Global joystick aim vector.
    let joystickAim = { x: 0, y: 0 };

    // ------------------------------
    // Level Setup: 3000px wide tunneling world
    // ------------------------------
    const levelWidth = 3000;
    const gameHeight = window.innerHeight;
    const playAreaHeight = window.innerHeight - 100;
    const groundExtraHeight = 100;
    game.style.width = levelWidth + "px";
    game.style.height = gameHeight + "px";

    // Create ground (drain) element.
    const groundEl = document.createElement("div");
    groundEl.id = "ground";
    groundEl.style.top = playAreaHeight + "px";
    groundEl.style.width = levelWidth + "px";
    groundEl.style.height = groundExtraHeight + "px";
    game.appendChild(groundEl);

    // ------------------------------
    // Generate Breakable Floor Tiles (CSS tiles)
    // ------------------------------
    let floorTiles = [];
    function generateFloorTiles() {
      const tileSize = 10;
      const rows = 5;  // 5 rows tall floor
      const startY = playAreaHeight - rows * tileSize;
      const cols = Math.floor(levelWidth / tileSize);
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          let tile = {
            x: col * tileSize,
            y: startY + row * tileSize,
            width: tileSize,
            height: tileSize
          };
          let tileEl = document.createElement("div");
          tileEl.className = "tile";
          tileEl.style.left = tile.x + "px";
          tileEl.style.top = tile.y + "px";
          tileEl.style.width = tileSize + "px";
          tileEl.style.height = tileSize + "px";
          game.appendChild(tileEl);
          tile.domElement = tileEl;
          floorTiles.push(tile);
        }
      }
    }
    generateFloorTiles();

    // Remove tiles within a given circular impact area.
    function clearFloorTilesAt(x, y, radius) {
      for (let i = floorTiles.length - 1; i >= 0; i--) {
        let tile = floorTiles[i];
        let centerX = tile.x + tile.width / 2;
        let centerY = tile.y + tile.height / 2;
        let dist = Math.hypot(centerX - x, centerY - y);
        if (dist < radius) {
          // Animate tile falling.
          tile.domElement.style.transition = "top 0.5s ease-out, opacity 0.5s ease-out";
          tile.domElement.style.top = gameHeight + "px";
          tile.domElement.style.opacity = "0";
          setTimeout(() => {
            if (tile.domElement && tile.domElement.parentNode) {
              tile.domElement.parentNode.removeChild(tile.domElement);
            }
          }, 500);
          floorTiles.splice(i, 1);
        }
      }
    }
    // Check if a bullet hits any floor tile.
    function checkBulletFloorCollisions() {
      bullets.forEach((bullet, bIndex) => {
        for (let i = floorTiles.length - 1; i >= 0; i--) {
          let tile = floorTiles[i];
          if (bullet.position.x >= tile.x && bullet.position.x <= tile.x + tile.width &&
              bullet.position.y >= tile.y && bullet.position.y <= tile.y + tile.height) {
            // Remove tile.
            tile.domElement.style.transition = "top 0.5s ease-out, opacity 0.5s ease-out";
            tile.domElement.style.top = gameHeight + "px";
            tile.domElement.style.opacity = "0";
            setTimeout(() => {
              if (tile.domElement && tile.domElement.parentNode)
                tile.domElement.parentNode.removeChild(tile.domElement);
            }, 500);
            floorTiles.splice(i, 1);
            // Remove bullet.
            World.remove(world, bullet);
            if (bullet.domElement && bullet.domElement.parentNode)
              bullet.domElement.parentNode.removeChild(bullet.domElement);
            let bIdx = bullets.indexOf(bullet);
            if (bIdx !== -1) bullets.splice(bIdx, 1);
            break;
          }
        }
      });
    }
    // Remove floor tiles that have "fallen" off screen.
    function clearFallenFloorTiles() {
      for (let i = floorTiles.length - 1; i >= 0; i--) {
        if (floorTiles[i].y > playAreaHeight) {
          if (floorTiles[i].domElement && floorTiles[i].domElement.parentNode)
            floorTiles[i].domElement.parentNode.removeChild(floorTiles[i].domElement);
          floorTiles.splice(i, 1);
        }
      }
    }

    // ------------------------------
    // Standard Matter.js Objects (Platforms, TVs, Walls)
    // ------------------------------
    let domEntities = [], platforms = [], tvs = [], walls = [], coins = [], bullets = [];
    function createDomElement(body, cls, w, h) {
      const el = document.createElement("div");
      el.className = "entity " + cls;
      el.style.width = w + "px";
      el.style.height = h + "px";
      game.appendChild(el);
      body.domElement = el;
      domEntities.push(body);
    }
    function createPlatform(x, y, width, height) {
      const platform = Bodies.rectangle(x + width/2, y + height/2, width, height, { isStatic: true, label: "platform" });
      platform.width = width; platform.height = height; platform.hp = 50;
      World.add(world, platform);
      const el = document.createElement("div");
      el.className = "platform";
      el.style.width = width + "px";
      el.style.height = height + "px";
      el.style.left = (x + width/2) + "px";
      el.style.top = (y + height/2) + "px";
      game.appendChild(el);
      platform.domElement = el;
      platforms.push(platform);
    }
    function createTV(x, y, width, height) {
      const tv = Bodies.rectangle(x + width/2, y + height/2, width, height, { isStatic: true, label: "tv" });
      tv.width = width; tv.height = height; tv.hp = 30;
      World.add(world, tv);
      const el = document.createElement("div");
      el.className = "tv";
      el.style.width = width + "px";
      el.style.height = height + "px";
      el.style.left = (x + width/2) + "px";
      el.style.top = (y + height/2) + "px";
      game.appendChild(el);
      tv.domElement = el;
      tvs.push(tv);
    }
    function createWall(x, y, width, height) {
      const wall = Bodies.rectangle(x + width/2, y + height/2, width, height, { isStatic: true, label: "wall" });
      wall.width = width; wall.height = height; wall.hp = 100;
      World.add(world, wall);
      const el = document.createElement("div");
      el.className = "platform";
      el.style.width = width + "px";
      el.style.height = height + "px";
      el.style.left = (x + width/2) + "px";
      el.style.top = (y + height/2) + "px";
      game.appendChild(el);
      wall.domElement = el;
      walls.push(wall);
    }
    // For demonstration, add a few objects.
    createPlatform(50, playAreaHeight - 150, 300, 20);
    createTV(50, playAreaHeight - 250, 40, 60);
    createWall(350, playAreaHeight - 300, 20, 200);

    // ------------------------------
    // Static Boundaries & Drain (Safety Floor)
    // ------------------------------
    const groundBody = Bodies.rectangle(levelWidth / 2, playAreaHeight, levelWidth, 40, { isStatic: true });
    const leftBoundary = Bodies.rectangle(0, playAreaHeight / 2, 40, playAreaHeight, { isStatic: true });
    const rightBoundary = Bodies.rectangle(levelWidth, playAreaHeight / 2, 40, playAreaHeight, { isStatic: true });
    World.add(world, [groundBody, leftBoundary, rightBoundary]);
    const safetyFloorY = playAreaHeight + 50;
    const safetyFloor = Bodies.rectangle(levelWidth / 2, safetyFloorY, levelWidth, 40, { isStatic: true, label: "safetyFloor" });
    World.add(world, safetyFloor);

    // ------------------------------
    // Character Factory (Player)
    // ------------------------------
    function createCharacter(x, y) {
      const char = { hp: 100, alive: true, spawn: { x, y } };
      const size = 20;
      const torsoOpts = { friction: 6.0, frictionAir: 0.01, restitution: 0 };
      const defOpts = { friction: 0.5, frictionAir: 0.01, restitution: 0 };
      const hpContainer = document.createElement("div");
      hpContainer.className = "hp-bar-container";
      const hpBar = document.createElement("div");
      hpBar.className = "hp-bar";
      hpContainer.appendChild(hpBar);
      game.appendChild(hpContainer);
      char.hpContainer = hpContainer;
      char.hpBar = hpBar;
      function addPart(body, cls, w, h) {
        createDomElement(body, cls, w, h);
        body.character = char;
        return body;
      }
      const head = Bodies.circle(x, y - 40, size/2, defOpts);
      addPart(head, "player-part", size, size);
      const torso = Bodies.circle(x, y - 20, size, torsoOpts);
      addPart(torso, "player-part", size*2, size*2);
      const rUpperArm = Bodies.circle(x + 30, y - 20, size/2, defOpts);
      addPart(rUpperArm, "player-part", size, size);
      const rHand = Bodies.circle(x + 30, y - 20 + 20, size/2, defOpts);
      addPart(rHand, "player-part", size, size);
      const lUpperArm = Bodies.circle(x - 30, y - 20, size/2, defOpts);
      addPart(lUpperArm, "player-part", size, size);
      const lHand = Bodies.circle(x - 30, y - 20 + 20, size/2, defOpts);
      addPart(lHand, "player-part", size, size);
      const rUpperLeg = Bodies.circle(x + 10, y + 10, size/2, defOpts);
      addPart(rUpperLeg, "player-part", size, size);
      const rFoot = Bodies.circle(x + 10, y + 10 + 20, size/2, defOpts);
      addPart(rFoot, "player-part", size, size);
      const lUpperLeg = Bodies.circle(x - 10, y + 10, size/2, defOpts);
      addPart(lUpperLeg, "player-part", size, size);
      const lFoot = Bodies.circle(x - 10, y + 10 + 20, size/2, defOpts);
      addPart(lFoot, "player-part", size, size);
      World.add(world, [head, torso, rUpperArm, rHand, lUpperArm, lHand, rUpperLeg, rFoot, lUpperLeg, lFoot]);
      function link(a, b, offA, offB) {
        const con = Constraint.create({
          bodyA: a, pointA: offA, bodyB: b, pointB: offB,
          stiffness: 1, length: 0.1
        });
        World.add(world, con);
      }
      link(head, torso, { x: 0, y: size/2 }, { x: 0, y: -size });
      link(torso, rUpperArm, { x: size, y: 0 }, { x: 0, y: 0 });
      link(rUpperArm, rHand, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, lUpperArm, { x: -size, y: 0 }, { x: 0, y: 0 });
      link(lUpperArm, lHand, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, rUpperLeg, { x: 10, y: size }, { x: 0, y: -size/2 });
      link(rUpperLeg, rFoot, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, lUpperLeg, { x: -10, y: size }, { x: 0, y: -size/2 });
      link(lUpperLeg, lFoot, { x: 0, y: 0 }, { x: 0, y: -20 });
      char.head = head; char.torso = torso;
      char.rightUpperArm = rUpperArm; char.rightHand = rHand;
      char.leftUpperArm = lUpperArm; char.leftHand = lHand;
      char.rightUpperLeg = rUpperLeg; char.rightFoot = rFoot;
      char.leftUpperLeg = lUpperLeg; char.leftFoot = lFoot;
      return char;
    }
    let playerChar = createCharacter(100, 100);

    // ------------------------------
    // Destructible Object Damage Handling
    // ------------------------------
    function damageDestructible(obj, damage) {
      if (typeof obj.hp !== "number") return;
      obj.hp -= damage;
      particleBurst(obj.position.x, obj.position.y, "orange");
      if (obj.hp <= 0) {
        particleBurst(obj.position.x, obj.position.y, "red");
        if (obj.label === "wall") {
          breakWall(obj);
        } else {
          World.remove(world, obj);
          if (obj.domElement && obj.domElement.parentNode)
            obj.domElement.parentNode.removeChild(obj.domElement);
          if (obj.label === "platform") {
            let idx = platforms.indexOf(obj);
            if (idx !== -1) platforms.splice(idx, 1);
          } else if (obj.label === "tv") {
            let idx = tvs.indexOf(obj);
            if (idx !== -1) tvs.splice(idx, 1);
            spawnCoins(obj.position.x, obj.position.y);
          } else if (obj.label === "clog") {
            // Remove clog tiles.
            let idx = floorTiles.findIndex(tile => {
              // Compare tile center to object's position.
              let centerX = tile.x + tile.width/2;
              let centerY = tile.y + tile.height/2;
              return Math.hypot(centerX - obj.position.x, centerY - obj.position.y) < 5;
            });
            if (idx !== -1) {
              let tile = floorTiles[idx];
              tile.domElement.style.transition = "top 0.5s ease-out, opacity 0.5s ease-out";
              tile.domElement.style.top = gameHeight + "px";
              tile.domElement.style.opacity = "0";
              setTimeout(() => { if (tile.domElement) tile.domElement.parentNode.removeChild(tile.domElement); }, 500);
              floorTiles.splice(idx, 1);
            }
          }
        }
      }
    }

    // Break wall into dynamic chunks.
    function breakWall(wall) {
      World.remove(world, wall);
      if (wall.domElement && wall.domElement.parentNode) {
        wall.domElement.parentNode.removeChild(wall.domElement);
      }
      let idx = walls.indexOf(wall);
      if (idx !== -1) walls.splice(idx, 1);
      const cols = 2, rows = 2;
      const chunkWidth = wall.width / cols;
      const chunkHeight = wall.height / rows;
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const cx = wall.position.x - wall.width/2 + chunkWidth/2 + j * chunkWidth;
          const cy = wall.position.y - wall.height/2 + chunkHeight/2 + i * chunkHeight;
          let chunk = Bodies.rectangle(cx, cy, chunkWidth, chunkHeight, { isStatic: false, label: "wallChunk" });
          Body.setVelocity(chunk, { x: (Math.random()-0.5)*10, y: (Math.random()-0.5)*10 });
          World.add(world, chunk);
          const chunkEl = document.createElement("div");
          chunkEl.className = "platform";
          chunkEl.style.width = chunkWidth + "px";
          chunkEl.style.height = chunkHeight + "px";
          chunkEl.style.left = cx + "px";
          chunkEl.style.top = cy + "px";
          game.appendChild(chunkEl);
          chunk.domElement = chunkEl;
          domEntities.push(chunk);
        }
      }
    }

    // Spawn coins.
    function spawnCoins(x, y) {
      for (let i = 0; i < 3; i++) {
        let coin = Bodies.circle(x, y, 10, { isStatic: false, label: "coin", restitution: 0.5 });
        coin.value = 1;
        World.add(world, coin);
        let coinEl = document.createElement("div");
        coinEl.className = "coin";
        coinEl.textContent = "$";
        coinEl.style.width = "20px";
        coinEl.style.height = "20px";
        coinEl.style.lineHeight = "20px";
        coinEl.style.fontSize = "14px";
        coinEl.style.textAlign = "center";
        coinEl.style.borderRadius = "50%";
        coinEl.style.background = "gold";
        coinEl.style.color = "black";
        game.appendChild(coinEl);
        coin.domElement = coinEl;
        coins.push(coin);
        let angle = Math.random() * 2 * Math.PI;
        let speed = Math.random() * 5 + 2;
        Body.setVelocity(coin, { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed });
      }
    }

    // ------------------------------
    // Melee Attack with Whip Physics & Directional Control
    // (Uses D-Pad or Joystick; limits whip distance; defaults: on ground up, in air down)
    // ------------------------------
    function meleeAttack() {
      // Build directional input.
      let inputDir = { x: 0, y: 0 };
      if (keys["ArrowLeft"]) inputDir.x -= 1;
      if (keys["ArrowRight"]) inputDir.x += 1;
      if (keys["ArrowUp"]) inputDir.y -= 1;
      if (keys["ArrowDown"]) inputDir.y += 1;
      if (inputDir.x === 0 && inputDir.y === 0) {
        if (Math.hypot(joystickAim.x, joystickAim.y) > 0.1) {
          inputDir.x = joystickAim.x;
          inputDir.y = joystickAim.y;
        }
      }
      let onGround = (playerChar.torso.position.y >= playAreaHeight - 5);
      let defaultDir = onGround ? { x: 0, y: -1 } : { x: 0, y: 1 };
      let attackDir = (inputDir.x !== 0 || inputDir.y !== 0)
                        ? { x: inputDir.x/Math.hypot(inputDir.x,inputDir.y), y: inputDir.y/Math.hypot(inputDir.x,inputDir.y) }
                        : defaultDir;
      // Set max whip distance.
      let maxWhipDistance = 60;
      let whipOrigin = playerChar.rightUpperArm.position;
      // Compute perpendicular vector.
      let tangent = { x: attackDir.y, y: -attackDir.x };
      // Apply sine–modulated force over 300ms (30 steps) if hand is within range.
      let swingTime = 300, steps = 30, stepTime = swingTime/steps, step = 0;
      let interval = setInterval(() => {
        let currentDistance = Math.hypot(playerChar.rightHand.position.x - whipOrigin.x,
                                         playerChar.rightHand.position.y - whipOrigin.y);
        if (currentDistance < maxWhipDistance) {
          let amplitude = Math.sin(Math.PI * step / steps);
          let forceOut = 0.05, forceTangent = 0.05;
          Body.applyForce(playerChar.rightHand, playerChar.rightHand.position, {
            x: (attackDir.x * forceOut + tangent.x * forceTangent) * amplitude,
            y: (attackDir.y * forceOut + tangent.y * forceTangent) * amplitude
          });
        }
        step++;
        if (step >= steps) clearInterval(interval);
      }, stepTime);
      // After 100ms, clear floor tiles and damage nearby objects.
      setTimeout(() => {
        let attackPos = playerChar.rightHand.position;
        const meleeRange = 60, damageAmount = 30;
        [platforms, tvs, walls].forEach(arr => {
          arr.forEach(obj => {
            let dx = attackPos.x - obj.position.x;
            let dy = attackPos.y - obj.position.y;
            if (Math.hypot(dx, dy) <= meleeRange) {
              damageDestructible(obj, damageAmount);
            }
          });
        });
        // Also clear floor tiles within a 10px radius.
        clearFloorTilesAt(attackPos.x, attackPos.y, 10);
      }, 100);
    }

    // ------------------------------
    // Bullet Functions
    // ------------------------------
    function shootBullet(x, y, tx, ty, owner) {
      const bullet = Bodies.circle(x, y, 5, { friction: 0, frictionAir: 0.01, label: "bullet" });
      bullet.owner = owner;
      const angle = Math.atan2(ty - y, tx - x);
      const speed = 35;
      Body.setVelocity(bullet, { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed });
      World.add(world, bullet);
      createDomElement(bullet, "bullet", 10, 10);
      bullets.push(bullet);
    }
    function playerShoot() {
      let dx = 0, dy = 0;
      const aimMag = Math.hypot(joystickAim.x, joystickAim.y);
      if (aimMag > 0.1) {
        dx = joystickAim.x;
        dy = joystickAim.y;
      } else {
        if (keys["ArrowUp"]) dy = -1;
        if (keys["ArrowDown"]) dy =  1;
        if (keys["ArrowLeft"]) dx = -1;
        if (keys["ArrowRight"]) dx =  1;
        if (dx === 0 && dy === 0) dx = 1;
        let mag = Math.hypot(dx, dy);
        dx /= mag; dy /= mag;
      }
      Body.setPosition(playerChar.rightHand, { 
        x: playerChar.rightUpperArm.position.x + 20, 
        y: playerChar.rightUpperArm.position.y 
      });
      const origin = { x: playerChar.rightHand.position.x, y: playerChar.rightHand.position.y };
      shootBullet(origin.x, origin.y, origin.x + dx * 100, origin.y + dy * 100, playerChar);
    }

    // ------------------------------
    // Coin Collection (Player collects coins)
    // ------------------------------
    let coinCount = 0;
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        if ((pair.bodyA.label === "coin" && pair.bodyB.character) ||
            (pair.bodyB.label === "coin" && pair.bodyA.character)) {
          let coinBody = (pair.bodyA.label === "coin") ? pair.bodyA : pair.bodyB;
          World.remove(world, coinBody);
          if (coinBody.domElement && coinBody.domElement.parentNode)
            coinBody.domElement.parentNode.removeChild(coinBody.domElement);
          let idx = coins.indexOf(coinBody);
          if (idx !== -1) coins.splice(idx, 1);
          coinCount++;
          console.log("Coins collected: " + coinCount);
        }
      });
    });

    // ------------------------------
    // Collision Handling for Bullets (and other interactions)
    // ------------------------------
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        // Standard bullet vs. character collisions.
        if (pair.bodyA.label === "bullet" && pair.bodyB.character) {
          if (pair.bodyB.character !== pair.bodyA.owner) {
            World.remove(world, pair.bodyA);
            if (pair.bodyA.domElement) pair.bodyA.domElement.parentNode.removeChild(pair.bodyA.domElement);
          }
        } else if (pair.bodyB.label === "bullet" && pair.bodyA.character) {
          if (pair.bodyA.character !== pair.bodyB.owner) {
            World.remove(world, pair.bodyB);
            if (pair.bodyB.domElement) pair.bodyB.domElement.parentNode.removeChild(pair.bodyB.domElement);
          }
        }
      });
    });

    // ------------------------------
    // Destructible World Collisions (Gradual Damage on High-Speed Contact)
    // ------------------------------
    const destructionSpeedThreshold = 20;
    function isPlayerPart(body) {
      return body === playerChar.head || body === playerChar.torso ||
             body === playerChar.rightUpperArm || body === playerChar.rightHand ||
             body === playerChar.leftUpperArm || body === playerChar.leftHand ||
             body === playerChar.rightUpperLeg || body === playerChar.rightFoot ||
             body === playerChar.leftUpperLeg || body === playerChar.leftFoot;
    }
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        let playerPart = null, other = null;
        if (isPlayerPart(pair.bodyA) && pair.bodyB.isStatic) {
          playerPart = pair.bodyA;
          other = pair.bodyB;
        } else if (isPlayerPart(pair.bodyB) && pair.bodyA.isStatic) {
          playerPart = pair.bodyB;
          other = pair.bodyA;
        }
        if (other && other.label !== "safetyFloor" &&
           (other.label === "platform" || other.label === "tv" || other.label === "wall")) {
          const vx = playerChar.torso.velocity.x, vy = playerChar.torso.velocity.y;
          const playerSpeed = Math.hypot(vx, vy);
          if (playerSpeed >= destructionSpeedThreshold) {
            damageDestructible(other, 10);
          }
        }
      });
    });

    // ------------------------------
    // Main Game Loop
    // ------------------------------
    function update() {
      Engine.update(engine, 1000/60);
      domEntities.forEach(body => {
        if (body.domElement) {
          body.domElement.style.left = body.position.x + "px";
          body.domElement.style.top = body.position.y + "px";
          body.domElement.style.transform = "translate(-50%, -50%) rotate(" + body.angle + "rad)";
        }
      });
      coins.forEach(coin => {
        if (coin.domElement) {
          coin.domElement.style.left = coin.position.x + "px";
          coin.domElement.style.top = coin.position.y + "px";
        }
      });
      // Update floor tile positions (they are static, so no update needed)

      // Player movement via arrow keys.
      if (keys["ArrowLeft"]) {
        Body.applyForce(playerChar.torso, playerChar.torso.position, { x: -0.01, y: 0 });
      }
      if (keys["ArrowRight"]) {
        Body.applyForce(playerChar.torso, playerChar.torso.position, { x: 0.01, y: 0 });
      }
      if (!keys["ArrowLeft"] && !keys["ArrowRight"]) {
        Body.setVelocity(playerChar.torso, { x: playerChar.torso.velocity.x * 0.98, y: playerChar.torso.velocity.y });
      }
      // Also allow horizontal movement from joystick.
      if (Math.abs(joystickAim.x) > 0.1) {
        Body.applyForce(playerChar.torso, playerChar.torso.position, { x: joystickAim.x * 0.005, y: 0 });
      }
      // Jump: if jump key pressed, use joystick aim if present; else vertical.
      if (keys["KeyB"] || keys["Space"]) {
        const jumpStrength = 22;
        const aimMag = Math.hypot(joystickAim.x, joystickAim.y);
        if (aimMag > 0.1) {
          Body.setVelocity(playerChar.torso, { x: joystickAim.x * jumpStrength, y: joystickAim.y * jumpStrength });
        } else {
          Body.setVelocity(playerChar.torso, { x: playerChar.torso.velocity.x, y: -jumpStrength });
        }
      }
      // Sync head with torso.
      Body.setPosition(playerChar.head, { x: playerChar.torso.position.x, y: playerChar.torso.position.y - 40 });
      Body.setVelocity(playerChar.head, playerChar.torso.velocity);
      
      // Clamp player within the pipe boundaries.
      (function clampPlayer(character) {
        const margin = 50;
        const pos = character.torso.position;
        let clampedX = pos.x, clampedY = pos.y;
        if (pos.x < margin) clampedX = margin;
        if (pos.x > levelWidth - margin) clampedX = levelWidth - margin;
        if (pos.y < margin) clampedY = margin;
        if (clampedX !== pos.x || clampedY !== pos.y) {
          Body.setPosition(character.torso, { x: clampedX, y: clampedY });
          Body.setVelocity(character.torso, { x: 0, y: 0 });
        }
      })(playerChar);

      // Leg Animation.
      let walkCycle = 0, lastTime = Date.now();
      (function updateLegs() {
        const now = Date.now();
        const dt = (now - lastTime) / 1000;
        lastTime = now;
        if (keys["ArrowLeft"] || keys["ArrowRight"]) {
          walkCycle += dt * 6;
          const maxAngle = Math.PI / 12;
          const leftLegOffset = Math.sin(walkCycle) * maxAngle;
          const rightLegOffset = Math.sin(walkCycle + Math.PI) * maxAngle;
          Body.setAngle(playerChar.leftUpperLeg, playerChar.torso.angle + leftLegOffset);
          Body.setAngle(playerChar.rightUpperLeg, playerChar.torso.angle + rightLegOffset);
          Body.setAngle(playerChar.leftFoot, playerChar.torso.angle + leftLegOffset);
          Body.setAngle(playerChar.rightFoot, playerChar.torso.angle + rightLegOffset);
        }
      })();

      // Update HP bar.
      (function updateHpBar(character) {
        if (!character.hpContainer) return;
        character.hpContainer.style.left = (character.torso.position.x - 25) + "px";
        character.hpContainer.style.top = (character.torso.position.y - 60) + "px";
      })(playerChar);

      // Check for bullet-floor collisions.
      checkBulletFloorCollisions();
      // Clear floor tiles that have fallen below drain.
      clearFallenFloorTiles();

      // Update camera (follow player).
      function updateCamera() {
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const scale = 1;
        const viewWidth = screenWidth;
        const viewHeight = screenHeight;
        let cameraX = playerChar.torso.position.x - viewWidth / 2;
        let cameraY = playerChar.torso.position.y - viewHeight / 2;
        cameraX = Math.max(0, Math.min(cameraX, levelWidth - viewWidth));
        cameraY = Math.max(0, Math.min(cameraY, gameHeight - viewHeight));
        game.style.transformOrigin = "top left";
        game.style.transform = `scale(${scale}) translate(-${cameraX}px, -${cameraY}px)`;
      }
      updateCamera();

      // Call clearFallenClogs if needed (if you add additional clog particles).

      requestAnimationFrame(update);
    }
    update();

    // ------------------------------
    // Joystick Functionality
    // ------------------------------
    (function() {
      const joystick = document.getElementById("joystick");
      let startX, startY;
      const maxDistance = 30;
      let dragging = false;
      joystick.addEventListener("touchstart", function(e) {
        dragging = true;
        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
        e.preventDefault();
      });
      joystick.addEventListener("touchmove", function(e) {
        if (!dragging) return;
        const touch = e.touches[0];
        const dx = touch.clientX - startX;
        const dy = touch.clientY - startY;
        const distance = Math.hypot(dx, dy);
        let moveX = dx, moveY = dy;
        if (distance > maxDistance) {
          moveX = (dx / distance) * maxDistance;
          moveY = (dy / distance) * maxDistance;
        }
        joystick.style.transform = `translate(${moveX}px, ${moveY}px)`;
        const mag = Math.hypot(moveX, moveY);
        if (mag > 0) {
          joystickAim.x = moveX / mag;
          joystickAim.y = moveY / mag;
        } else {
          joystickAim.x = 0;
          joystickAim.y = 0;
        }
        e.preventDefault();
      });
      function snapBack() {
        joystick.style.transition = "transform 0.2s ease-out";
        joystick.style.transform = "translate(0px, 0px)";
        setTimeout(() => {
          joystick.style.transition = "";
          joystickAim.x = 0;
          joystickAim.y = 0;
        }, 200);
      }
      joystick.addEventListener("touchend", (e) => { dragging = false; snapBack(); e.preventDefault(); });
      joystick.addEventListener("touchcancel", (e) => { dragging = false; snapBack(); e.preventDefault(); });
    })();

    // ------------------------------
    // Touch & Button Mappings
    // ------------------------------
    const dpad = document.getElementById("dpad");
    dpad.querySelector(".up").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowUp"] = true; });
    dpad.querySelector(".up").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowUp"] = false; });
    dpad.querySelector(".down").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowDown"] = true; });
    dpad.querySelector(".down").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowDown"] = false; });
    dpad.querySelector(".left").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowLeft"] = true; });
    dpad.querySelector(".left").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowLeft"] = false; });
    dpad.querySelector(".right").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowRight"] = true; });
    dpad.querySelector(".right").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowRight"] = false; });
    const abButtons = document.getElementById("ab-buttons");
    abButtons.querySelector(".A").addEventListener("touchstart", (e) => { e.preventDefault(); playerShoot(); });
    abButtons.querySelector(".B").addEventListener("touchstart", (e) => { e.preventDefault(); keys["Space"] = true; });
    abButtons.querySelector(".B").addEventListener("touchend", (e) => { e.preventDefault(); keys["Space"] = false; });
    abButtons.querySelector(".C").addEventListener("touchstart", (e) => { e.preventDefault(); meleeAttack(); });
    abButtons.querySelector(".C").addEventListener("mousedown", (e) => { e.preventDefault(); meleeAttack(); });
  </script>
</body>
</html>
