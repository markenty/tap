 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kill-Da-Bear</title>
  <style>
    html, body {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #505050;
      touch-action: none;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      background: #505050;
    }
    /* --- Headbutt Effect Styling --- */
    #headbuttEffect {
      position: absolute;
      pointer-events: none;
      width: 64px;
      height: 64px;
      background: rgba(255,255,255,0.8);
      border-radius: 50%;
      transform: scale(0);
      opacity: 0;
    }
    #headbuttEffect.active {
      animation: headbuttAnim 0.3s forwards;
    }
    @keyframes headbuttAnim {
      0% { transform: scale(0); opacity: 1; }
      50% { transform: scale(1.2) rotate(10deg); opacity: 1; }
      100% { transform: scale(0); opacity: 0; }
    }
    
  #upgradeButton {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 101;
  padding: 10px 20px;
  font-size: 1.5rem;
  background-color: #ffebcd;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}

@keyframes upgradeAlertAnimation {
  0%   { opacity: 0; transform: scale(0.5) rotate(-15deg); }
  20%  { opacity: 1; transform: scale(1.2) rotate(10deg); }
  40%  { opacity: 1; transform: scale(1) rotate(0deg); }
  80%  { opacity: 1; transform: translateY(-20px) scale(1); }
  100% { opacity: 0; transform: translateY(-40px) scale(0.8); }
}

.upgrade-alert {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  padding: 20px 40px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  font-size: 2.5rem;
  font-weight: bold;
  text-shadow: 2px 2px 5px #000;
  border: 3px solid #ffebcd;
  border-radius: 10px;
  z-index: 11000;
  pointer-events: none;
  animation: upgradeAlertAnimation 2s ease-out forwards;
}

    /* Fullscreen overlay for the upgrade menu */
    #upgradeMenu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    /* Expanded menu content that fills the screen */
    .menu-content {
      background: #ffebcd;
      width: 100%;
      height: 100%;
      padding: 1rem;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      justify-content: space-around;
      align-items: center;
      overflow-y: auto; z-index: 10000;
    }
    /* Headings and text scale up for readability */
    .menu-content h1 {
      font-size: 3rem;
      margin: 0.5rem 0;
    }
    .menu-content p {
      font-size: 1.8rem;
      margin: 0.5rem 0;
    }
    /* Tabs styling */
    .tabs {
      display: flex;
      justify-content: center;
      margin: 1rem 0;
      width: 100%;
    }
    .tabs button {
      background: #ddd;
      border: none;
      padding: 1rem 2rem;
      margin: 0 0.5rem;
      cursor: pointer;
      border-radius: 5px;
      transition: background 0.2s;
      font-size: 1.8rem;
      font-weight: bold;
      flex: 1;
    }
    .tabs button.active {
      background: #ffebcd;
      box-shadow: 0 0 5px rgba(0,0,0,0.5);
    }
    /* --- Section Containers --- */
    .section { display: none; }
    /* Responsive grid for upgrade/shop buttons */
.menu-buttons {
  display: grid;
  grid-template-columns: repeat(3, 180px);
  gap: 1rem;
  width: 100%;
  padding: 1rem;
  box-sizing: border-box;
}
    /* Enlarged buttons for easier touch interaction */
    .menu-buttons button {
      background: rgba(0,0,0,0.5);
      border: 2px solid white;
      border-radius: 10px;
      width: 100%;
  aspect-ratio: 1;
  font-size: 1.5rem;
  padding: 1.0rem;
      color: white;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
   
    }
    .menu-buttons button:active {
      border: 2px solid red;
      box-shadow: 0 0 10px 3px rgba(255,0,0,0.8);
    }
    /* Resume Game Button */
    #resumeGame {
      margin-top: 1rem;
      padding: 1rem 2rem;
      font-size: 2rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #ffebcd;
      color: black;
      width: 90%;
      max-width: 400px;
    }
    /* --- Item Tray --- */
    #itemTray {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      width: 90%;
      max-width: 800px;
    }
    #itemTray .tray-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .divider {
      width: 1px;
      background-color: white;
      height: 40px;
      margin: 0 10px;
    }
    .tray-slot {
      position: relative;
      background: rgba(0,0,0,0.5);
      border: 2px solid white;
      border-radius: 10px;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      color: white;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .tray-slot.active {
      box-shadow: 0 0 15px 3px rgba(255,255,0,0.9);
      transform: scale(1.1);
    }
    .tray-slot.dimmed {
      opacity: 0.5;
      pointer-events: none;
    }
    /* Overlays for counters and indicators */
    .tray-slot .counter,
    .tray-slot .timer {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 14px;
      color: yellow;
    }
    .tray-slot .indicator {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 14px;
      color: yellow;
    }
    @media (max-width: 600px) {
      #itemTray .tray-slot {
        width: 50px;
        height: 50px;
        font-size: 28px;
      }
      .tray-slot .counter, .tray-slot .timer, .tray-slot .indicator {
        font-size: 12px;
      }
    }
    /* --- Tally Marks for Max Strike Distance --- */
    #maxStrikeSlot .tally-container {
      position: absolute;
      top: 4px;
      left: 4px;
      right: 4px;
      bottom: 4px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
      gap: 2px;
    }
    .tally {
      flex: 0 0 auto;
      width: 10px;
      height: 10px;
      background: white;
    }
    .meter {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      background: gray;
      border-radius: 0 0 10px 10px;
    }
    .shield-meter { background-color: blue; }
    .charm-meter { background-color: purple; }
    .auto-strike-meter { background-color: orange; }
    .bomb-available {
      border-color: red;
      box-shadow: 0 0 10px 3px rgba(255,0,0,0.8);
      
    }/* Ensure the button keeps its width while the text scrolls */
.marquee {
  width: 100%;
  overflow: hidden;
  white-space: nowrap;
  position: relative;
}

/* Force the inner span to start offscreen and animate */
.marquee span {
  display: inline-block;
  /* Add padding so the text always moves from right offscreen to left offscreen */
  padding-left: 100%;
  animation: marquee 10s linear infinite;
}

/* Define the marquee keyframes */
@keyframes marquee {
  0% {
    transform: translateX(0);
  }
  100% {
    transform: translateX(-100%);
  }
}
#shopSection .menu-buttons {
  justify-items: center;
}

  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <!-- Headbutt Effect Overlay -->
  <div id="headbuttEffect"></div>
  
  <!-- Upgrade Menu with Tabs -->
<div id="upgradeMenu">
  <div class="menu-content">
    <h1>Player Menu</h1>
    <p>You have <span id="pointsDisplay">0</span> points.</p>
    <p>Your Rank: <span id="menuRankDisplay">üî∞ Beginner</span></p>
    <div class="tabs">
      <button id="upgradesTab" class="active">Upgrades</button>
      <button id="shopTab">Shop</button>
      <button id="inventoryTab">Inventory</button>
    </div>
    <div id="upgradesSection" class="section" style="display:block;">
      <div class="menu-buttons">
          <button id="increaseHP">
  <div class="marquee"><p class="icon" style="font-size:3rem">‚ù§Ô∏è+</p> 
<div class="label"><b><i>Cost: 50</i></b></div>  
 
<span>Increase Max HP (+20 HP) - Cost: 50</span>
  </div>
</button>
          <button id="increaseAutoRun">
  <div class="marquee"><p class="icon" style="font-size:3rem">‚öîÔ∏è+‚è±</p>
<div class="label"><b><i>Cost: 200</i></b></div>  

    <span> Increase Auto Strike Time (+10s) - Cost: 200</span>
  </div>
</button>
          <button id="increaseDash">
<div class="marquee"><p class="icon" style="font-size:3rem">‚öîÔ∏è+‚û°Ô∏è</p>
<div class="label"><b><i>Cost: 300</i></b></div>  
    <span> Increase Strike Range (+1 tile) - Cost: 300</span>
  </div>
</button>
          <button id="increaseStrikeMeter"><div class="marquee"><p class="icon" style="font-size:3rem">‚öîÔ∏è+üîã</p>
<div class="label"><b><i>Cost: 150</i></b></div> 

    <span> Increase Strike Meter Capacity (+10) - Cost: 150</span></div></button>
          <button id="increaseHealingCharmTime"><div class="marquee"><p class="icon" style="font-size:3rem">ü™¨+</p>
<div class="label"><b><i>Cost: 250</i></b></div> 

    <span>  Increase Healing Charm (Duration & Heal) - Cost: 250</span></div></button>
          <button id="increaseShieldingTime"><div class="marquee"><p class="icon" style="font-size:3rem">üõ°Ô∏è+</p>
<div class="label"><b><i>Cost: 250</i></b></div> 

    <span>  Increase Shielding (Duration & Reduction) - Cost: 250</span></div></button>
        </div>
      </div>

<div id="shopSection" class="section">
  <div class="menu-buttons">
    <button id="buyBomb">
      <div class="marquee"><p class="icon" style="font-size:3rem">üí£</p>
       <div class="label">
<b><i><div class="cost" id="bombCostDisplay"></div></i></b>   </div>
        <span>Buy a Bomb</span> </div></button>

 
    <!-- Add additional shop buttons here as needed -->
  </div>
</div>

    <div id="inventorySection" class="section">
      <div class="menu-buttons" id="inventoryItems">
        <!-- Inventory items (tiles) will be injected here -->
      </div>
    </div>
    <button id="resumeGame">‚ñ∂Ô∏è Resume Game</button>
  </div>
</div>
  
  <!-- Item Tray -->
  <div id="itemTray">
    <div class="tray-group passive">
      <div class="tray-slot" id="pointsSlot">üí∞<div class="counter">0</div></div>
      <div class="tray-slot" id="killsSlot">üíÄ<div class="counter">0</div></div>
      <div class="tray-slot dimmed" id="defenseSlot">üõ°Ô∏è</div>
      <div class="tray-slot dimmed" id="charmsSlot">ü™¨</div>
      <div class="tray-slot" id="hpSlot">‚ù§Ô∏è<div class="counter">100</div></div>
      <div class="tray-slot" id="autoStrikeSlot">
        <div class="indicator">‚úÖ</div>
        ‚öîÔ∏è<div class="counter">10</div>
      </div>
      <div class="tray-slot" id="maxStrikeSlot">
        ‚û°Ô∏è<div class="tally-container"></div>
      </div>
    </div>
    <div class="divider"></div>
    <div class="tray-group active">
      <div class="tray-slot" id="explosivesSlot">üí£<div class="counter">0</div></div>
      <div class="tray-slot" id="attackSlot">üëä</div>
    </div>
  </div>
   <button id="upgradeButton">
  <i><u><b>Player Menu</b></u></i>
  <div class="button-content">
    <div class="rank-info">
      <span id="buttonRankDisplay">üî∞ Beginner</span>
    </div>
  </div>
</button>
<script>
document.addEventListener("DOMContentLoaded", () => {
  const buyBombBtn = document.getElementById("buyBomb");
  if (buyBombBtn) {
    buyBombBtn.addEventListener("click", function () {
      // Your click handler code here
      console.log("Bomb button clicked!");
    });
  }
  // All your other code...
});
    "use strict";
    let preservedAutoStrikeTime = 0;
let preservedStrikeMeter = 0;

    // Constants and global state
    const PIXEL_SIZE = 4;
    const goldDecayRate = 5;
    
    let timeScale = 1.0, slowMotionTimer = 0, killCount = 0;
    let bombCount = 1, points = 0;
    let hasReflexAmulet = true; 
    
   let baseAutoStrikeTime = 10;
let autoStrikeTime = hasReflexAmulet ? baseAutoStrikeTime : 0;
    
    let autoStrikeInterval = 0.3, autoStrikeTimer = 0;
    let globalTime = 0;
    let isUpgradeMenuVisible = false;
    let autoStrikeBonus = 10;
    let strikeRangeTiles = 1;
    let strikeMeterCapacity = 100;

  // This block uses the Page Visibility API and focus/blur events.
let isPageActive = true;
document.addEventListener("visibilitychange", () => {
  isPageActive = !document.hidden;
});
window.addEventListener("focus", () => { isPageActive = true; });
window.addEventListener("blur", () => { isPageActive = false; });
    // Power-up state
    let defenseBoostActive = false, defenseBoostTimer = 0;
    let healingCharmActive = false, healingCharmTimer = 0;
    let baseDefenseBoostDuration = 10, baseShieldDamageReduction = 0.5;
    let baseHealingCharmDuration = 10, baseHealingCharmHeal = 1;
    
    let screenFlashAlpha = 0;
    let spriteFlashes = [];
    function triggerScreenFlash() { screenFlashAlpha = 0.5; }
    function addSpriteFlash(position) { spriteFlashes.push({ position, timer: 0.2, duration: 0.2 }); }
    
    let meleeEffects = [];
    function spawnMeleeEffect(x, y, angle) { meleeEffects.push({ x, y, angle, timer: 0.2, duration: 0.2 }); }
    function renderMeleeEffects(ctx, camera) {
      for (let effect of meleeEffects) {
        let progress = 1 - (effect.timer / effect.duration);
        let screenPos = camera.worldToScreen(new Vector2(effect.x, effect.y));
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(effect.angle);
        ctx.beginPath();
        ctx.arc(0, 0, 40 * progress, Math.PI, Math.PI + 0.8, false);
        ctx.lineWidth = 4;
        ctx.strokeStyle = "white";
        ctx.stroke();
        ctx.restore();
      }
    }
   
// ‚úÖ Preload and create sound instances
const sfx = {
  attack: createAudio("sword3.wav"),
  dash: createAudio("sfx/dash.mp3"),
  bombDeploy: createAudio("sfx/bomb.mp3"),
  pickup: createAudio("choice2.wav"),
  enemyDie: createAudio("bloodsuck.wav"),
  playerDie: createAudio("gong.wav"),
  explosion: createAudio("explode7.wav"),
  swingSword: createAudio("evade2.wav"),
  ripple: createAudio("sfx/ripple.mp3"),
   enemyAttack: createAudio("punch3.wav"),    // Enemy hits player
  enemyDamage: createAudio("punch5.wav"),    // Enemy takes damage
};

// ‚úÖ Function to create an audio instance (ensures instant play)
function createAudio(src) {
  const audio = new Audio(src);
  audio.preload = "auto";
  return audio;
}

// ‚úÖ Fast, overlap-allowed sound playback
function playSFX(sound) {
  if (sfx[sound]) {
    const audio = sfx[sound].cloneNode(); // Clone allows multiple overlapping plays
    audio.volume = 1.0; // Adjust if needed
    audio.play().catch(err => console.warn("SFX Play Error:", err));
  } else {
    console.warn(`SFX "${sound}" not found.`);
  }
}
    // --- Sword Effect for Max Strike ---
    // This effect draws a spinning sword emoji from the player to each struck enemy.
    class SwordEffect {
      constructor(startPos, targetPos, duration = 0.5) {
        this.startPos = startPos;   // Starting position (Vector2)
        this.targetPos = targetPos; // Target position (Vector2)
        this.duration = duration;   // Duration in seconds for the effect
        this.elapsed = 0;           // Time elapsed so far
        this.complete = false;      // Flag for completion
      }
      getCurrentPosition() {
    const t = this.elapsed / this.duration;
    const currentX = this.startPos.x + (this.targetPos.x - this.startPos.x) * t;
    const currentY = this.startPos.y + (this.targetPos.y - this.startPos.y) * t;
    return new Vector2(currentX, currentY);
  }
      update(dt) {
        this.elapsed += dt;
        if (this.elapsed >= this.duration) {
          this.elapsed = this.duration;
          this.complete = true;
        }
      }
      
      render(ctx, camera) {
        // Calculate progress (0 to 1)
        let t = this.elapsed / this.duration;
        // Linear interpolation between start and target positions
        let currentX = this.startPos.x + (this.targetPos.x - this.startPos.x) * t;
        let currentY = this.startPos.y + (this.targetPos.y - this.startPos.y) * t;
        let currentPos = new Vector2(currentX, currentY);
        // Spin the sword: one full rotation over the duration
        let angle = t * 2 * Math.PI;
        // Convert world coordinates to screen coordinates
        let screenPos = camera.worldToScreen(currentPos);
        
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(angle);
        ctx.font = "32px sans-serif"; // Adjust size as needed
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("üó° ", 0, 0);
        ctx.restore();
      }
    }
    // Global array to hold active sword effects
    let swordEffects = [];
     // -------------------------
    // Shop & Upgrade Menu Logic
    // -------------------------
    function getBombCost() {
      // Cost scales with rank: cost = 50 √ó (rank + 1)
      return Math.floor(50 * (calculateRank(killCount) + 1));
    }
    function updateBombCostDisplay() {
      document.getElementById("bombCostDisplay").innerText = "Cost: " + getBombCost();
    }
    
    document.getElementById("buyBomb").addEventListener("click", function() {
      let cost = getBombCost();
      if(points >= cost) {
        points -= cost;
        bombCount++;
        updateBombCostDisplay();showUpgradeAlert("Bomb purchased!");
        document.getElementById("pointsDisplay").textContent = Math.floor(points);
      }
    });
    
    // Tab switching for upgrade menu
document.getElementById("upgradesTab").addEventListener("click", function() {
  document.getElementById("upgradesSection").style.display = "block";
  document.getElementById("shopSection").style.display = "none";
  document.getElementById("inventorySection").style.display = "none";
  this.classList.add("active");
  document.getElementById("shopTab").classList.remove("active");
  document.getElementById("inventoryTab").classList.remove("active");
});

document.getElementById("shopTab").addEventListener("click", function() {
  document.getElementById("shopSection").style.display = "block";
  document.getElementById("upgradesSection").style.display = "none";
  document.getElementById("inventorySection").style.display = "none";
  this.classList.add("active");
  document.getElementById("upgradesTab").classList.remove("active");
  document.getElementById("inventoryTab").classList.remove("active");
  updateBombCostDisplay();
});

document.getElementById("inventoryTab").addEventListener("click", function() {
  document.getElementById("inventorySection").style.display = "block";
  document.getElementById("upgradesSection").style.display = "none";
  document.getElementById("shopSection").style.display = "none";
  this.classList.add("active");
  document.getElementById("upgradesTab").classList.remove("active");
  document.getElementById("shopTab").classList.remove("active");
  updateInventoryDisplay(); // Refresh the inventory view
});

    
    document.getElementById("resumeGame").addEventListener("click", () => { 
  resumeGame(); 
});

    // --- Ranking System Variables & Functions ---
    const rankEmojis = ["üî∞", "ü•â", "ü•à", "ü•á", "üèÜ", "üëë", "üíé", "üî•", "üöÄ"];
    const rankNames  = ["Beginner", "Novice", "Warrior", "Veteran", "Elite", "Master", "Champion", "Legend", "Mythic"];
    function calculateRank(kills) {
      let rank = 0;
      let threshold = 100;
      let remainingKills = kills;
      while (remainingKills >= threshold) {
        rank++;
        remainingKills -= threshold;
        threshold = Math.floor(threshold * 1.5);
      }
      return rank;
    }
    function updateInventoryDisplay() {
  const inventoryContainer = document.getElementById("inventoryItems");
  let html = "";
  
  // Example: display bomb count as an inventory item if there are any bombs.
  if (bombCount > 0) {
    html += `
      <button class="inventory-item"><div class="marquee">
        <div class="icon" style="font-size:3rem">üí£</div>
 <div class="label"><b><i>Bombs</i></b></div>
        <div class="count">${bombCount}</div>
      </button>
    `;
  }
   // Show Reflex Amulet if the player has it
  if (hasReflexAmulet) {
    html += `
      <button class="inventory-item"><div class="marquee">
        <div class="icon" style="font-size:3rem">üßø</div>
        <div class="label"><b><i>ReflexAmulet</i></b><br>
<span> Player starts with Auto-Strike for 10s</span></div>
      </button>
    `;
  }
   
  // Add similar blocks for other items if needed.
  
  inventoryContainer.innerHTML = html;
}

function updateRankDisplay() {
  const currentRank = calculateRank(killCount);
  const emoji = rankEmojis[Math.min(currentRank, rankEmojis.length - 1)];
  const name  = rankNames[Math.min(currentRank, rankNames.length - 1)];
  
  // Update both elements.
  const menuRankDisplay = document.getElementById("menuRankDisplay");
  if (menuRankDisplay) {
    menuRankDisplay.textContent = `${emoji} ${name}`;
  }
  
  const buttonRankDisplay = document.getElementById("buttonRankDisplay");
  if (buttonRankDisplay) {
    buttonRankDisplay.textContent = `${emoji} ${name}`;
  }
}

    function updateMeleeEffects(deltaTime) {
      for (let i = meleeEffects.length - 1; i >= 0; i--) {
        meleeEffects[i].timer -= deltaTime;
        if (meleeEffects[i].timer <= 0) meleeEffects.splice(i, 1);
      }
    }
    
    function updateSwordEffects(dt) {
  for (let i = swordEffects.length - 1; i >= 0; i--) {
    const effect = swordEffects[i];
    effect.update(dt);
    const effectPos = effect.getCurrentPosition();
   // Check collision with each enemy
    enemies.forEach(enemy => {
      // Compute enemy center position
      const enemyCenter = new Vector2(
        enemy.position.x + enemy.width / 2,
        enemy.position.y + enemy.height / 2
      );
      // If within collision radius (e.g., 20 pixels), damage enemy
      if (effectPos.subtract(enemyCenter).length() < 20) { 
        // Ensure the enemy hasn't already been damaged by this effect
        if (enemy.deathTimer === undefined) {
          enemy.deathTimer = 0.5; // Set delay before death/damage effect
          enemy.damageFlashTimer = 0.3;
          enemy.damageVibrateTimer = 0.3;
          // Optionally, add knockback or other effects here
         playSFX("swingSword");
        }
      }
    });
    if (effect.complete) swordEffects.splice(i, 1);
  }
}
    
    function renderSwordEffects(ctx, camera) {
      for (let effect of swordEffects) {
        effect.render(ctx, camera);
      }
    }

 
    function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }
    
    class Vector2 {
      constructor(x, y) { this.x = x; this.y = y; }
      add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
      subtract(v) { return new Vector2(this.x - v.x, this.y - v.y); }
      scale(s) { return new Vector2(this.x * s, this.y * s); }
      length() { return Math.sqrt(this.x * this.x + this.y * this.y); }
      normalize() { let len = this.length(); return new Vector2(this.x / (len || 1), this.y / (len || 1)); }
    }
    
    class Camera {
      constructor(screenWidth, screenHeight) {
        this.position = new Vector2(0, 0);
        this.zoom = 1.0;
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
      }
      worldToScreen(worldPos) {
        return new Vector2(
          (worldPos.x - this.position.x) * this.zoom + this.screenWidth / 2,
          (worldPos.y - this.position.y) * this.zoom + this.screenHeight / 2
        );
      }
      screenToWorld(screenPos) {
        return new Vector2(
          (screenPos.x - this.screenWidth / 2) / this.zoom + this.position.x,
          (screenPos.y - this.screenHeight / 2) / this.zoom + this.position.y
        );
      }
    }
    
    class Tile {
      constructor(gridX, gridY, tileType, color) {
        this.gridX = gridX;
        this.gridY = gridY;
        this.tileType = tileType;
        this.color = color;
      }
    }
    
    class TileMap {
      constructor(width, height, tileWidth, tileHeight) {
        this.width = width;
        this.height = height;
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;
        this.tiles = [];
    
        // Create a simplex noise instance
        const simplex = new SimplexNoise();
    
        for (let y = 0; y < height; y++) {
          let row = [];
          for (let x = 0; x < width; x++) {
            let noiseValue = simplex.noise2D(x / 100, y / 100);
            noiseValue = (noiseValue + 1) / 2;
    
            let tileType = 0;
            let color = "#64dd64"; // grass by default
    
            if (noiseValue < 0.3) {
              tileType = 1; // water
              color = "#3399ff";
            } else if (noiseValue < 0.5) {
              tileType = 2; // sand/beach
              color = "#f4e285";
            } else if (noiseValue > 0.8) {
              tileType = 3; // mountain
              color = "#888888";
            }
            row.push(new Tile(x, y, tileType, color));
          }
          this.tiles.push(row);
        }
      }
    
      gridToWorld(gridX, gridY) {
        return new Vector2(
          (gridX - gridY) * (this.tileWidth / 2),
          (gridX + gridY) * (this.tileHeight / 2)
        );
      }
    
      render(ctx, camera) {
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            let worldPos = this.gridToWorld(x, y);
            let screenPos = camera.worldToScreen(worldPos);
            let halfW = this.tileWidth / 2, halfH = this.tileHeight / 2;
            ctx.beginPath();
            ctx.moveTo(screenPos.x, screenPos.y + halfH);
            ctx.lineTo(screenPos.x + halfW, screenPos.y);
            ctx.lineTo(screenPos.x + this.tileWidth, screenPos.y + halfH);
            ctx.lineTo(screenPos.x + halfW, screenPos.y + this.tileHeight);
            ctx.closePath();
            ctx.fillStyle = this.tiles[y][x].color;
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.stroke();
          }
        }
      }
    }
    
    // Helper: Only allow tiles with type 0 (grass) or 2 (sand) to be passed
function isTilePassable(tile) {
  // Allow grass (0), water (1), sand (2), and mountains (3)
  return tile.tileType === 0 || tile.tileType === 1 || tile.tileType === 2 || tile.tileType === 3;
}

    class Particle {
      constructor(position, velocity, life, color, size, acceleration) {
        this.position = position;
        this.velocity = velocity;
        this.acceleration = acceleration || new Vector2(0, 0);
        this.life = life;
        this.maxLife = life;
        this.color = color;
        this.size = size;
      }
      update(deltaTime) {
        this.velocity = this.velocity.add(this.acceleration.scale(deltaTime));
        this.position = this.position.add(this.velocity.scale(deltaTime));
        this.life -= deltaTime;
      }
      render(ctx, camera) {
        let alpha = Math.max(this.life / this.maxLife, 0);
        let screenPos = camera.worldToScreen(this.position);
        ctx.fillStyle = this.color.replace("ALPHA", alpha);
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    let effects = [];
    function spawnPickupEffect(position) {
      const count = 10;
      for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = Math.random() * 50 + 50;
        let velocity = new Vector2(Math.cos(angle), Math.sin(angle)).scale(speed);
        let life = Math.random() * 0.5 + 0.5;
        let size = Math.random() * 2 + 2;
        effects.push(new Particle(new Vector2(position.x, position.y), velocity, life, "rgba(255,215,0,ALPHA)", size));
      }
    }
    function spawnBloodEffect(position) {
      const count = 20;
      for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = Math.random() * 100 + 50;
        let velocity = new Vector2(Math.cos(angle), Math.sin(angle)).scale(speed);
        let life = Math.random() * 0.5 + 0.5;
        let size = Math.random() * 1 + 1;
        effects.push(new Particle(new Vector2(position.x, position.y), velocity, life, "rgba(200,0,0,ALPHA)", size));
      }
    }
    function spawnExplosionEffect(position) {
      const count = 30;
      for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = Math.random() * 80 + 40;
        let velocity = new Vector2(Math.cos(angle), Math.sin(angle)).scale(speed);
        let life = Math.random() * 0.5 + 0.5;
        let size = Math.random() * 2 + 2;
        effects.push(new Particle(new Vector2(position.x, position.y), velocity, life, "rgba(255,165,0,ALPHA)", size));
      }
    }
    function spawnEnemyExplosionEffect(position) {
      const count = 50;
      for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = Math.random() * 200 + 100;
        let velocity = new Vector2(Math.cos(angle), Math.sin(angle)).scale(speed);
        let life = Math.random() * 1 + 0.5;
        let size = Math.random() * 3 + 2;
        let color = Math.random() < 0.5 ? "rgba(255,105,180,ALPHA)" : "rgba(255,0,0,ALPHA)";
        let acceleration = new Vector2(0, 300);
        effects.push(new Particle(new Vector2(position.x, position.y), velocity, life, color, size, acceleration)); 
      }
    }
    function updateEffects(deltaTime) {
      for (let i = effects.length - 1; i >= 0; i--) {
        effects[i].update(deltaTime);
        if (effects[i].life <= 0) effects.splice(i, 1);
      }
    }
    function renderEffects(ctx, camera) {
      for (let eff of effects) { eff.render(ctx, camera); }
    }
    
    // --- Pickup Classes ---
    class HealthPickup {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap;
        this.gridX = tileX;
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.size = tileMap.tileWidth / 2;
      }
      render(ctx, camera, t) {
        let screenPos = camera.worldToScreen(this.position);
        let floatOffset = Math.sin(t * 2) * 5;
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y + this.size/2 + floatOffset);
        ctx.rotate(t);
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(255,255,255,0.8)";
        ctx.font = `${this.size}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("‚ù§Ô∏è", 0, 0);
        ctx.restore();
      }
    }
    class BombPickup {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap;
        this.gridX = tileX;
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.size = tileMap.tileWidth / 2;
      }
      render(ctx, camera, t) {
        let screenPos = camera.worldToScreen(this.position);
        let floatOffset = Math.sin(t * 2) * 5;
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y + this.size/2 + floatOffset);
        ctx.rotate(t);
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(255,255,255,0.8)";
        ctx.font = `${this.size}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("üí£", 0, 0);
        ctx.restore();
      }
    }
    class SwordPickup {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap;
        this.gridX = tileX;
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.size = tileMap.tileWidth / 2;
      }
      render(ctx, camera, t) {
        let screenPos = camera.worldToScreen(this.position);
        let floatOffset = Math.sin(t * 2) * 5;
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y + this.size/2 + floatOffset);
        ctx.rotate(t);
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(255,255,255,0.8)";
        ctx.font = `${this.size}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("‚öîÔ∏è", 0, 0);
        ctx.restore();
      }
    }
    class DefenseBoostPickup {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap;
        this.gridX = tileX;
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.size = tileMap.tileWidth / 2;
      }
      render(ctx, camera, t) {
        let screenPos = camera.worldToScreen(this.position);
        let floatOffset = Math.sin(t * 2) * 5;
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y + this.size/2 + floatOffset);
        ctx.rotate(t);
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(255,255,255,0.8)";
        ctx.font = `${this.size}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("üõ°Ô∏è", 0, 0);
        ctx.restore();
      }
    }
    class HealingCharmPickup {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap;
        this.gridX = tileX;
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.size = tileMap.tileWidth / 2;
      }
      render(ctx, camera, t) {
        let screenPos = camera.worldToScreen(this.position);
        let floatOffset = Math.sin(t * 2) * 5;
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y + this.size/2 + floatOffset);
        ctx.rotate(t);
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(255,255,255,0.8)";
        ctx.font = `${this.size}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("ü™¨", 0, 0);
        ctx.restore();
      }
    }
    
    let pickups = [], baitBombs = [];
    let pickupSpawnTimer = 0, pickupSpawnInterval = 10.0;
    
    class Bullet {
      constructor(position, velocity, owner) {
        this.position = new Vector2(position.x, position.y);
        this.startPosition = new Vector2(position.x, position.y);
        this.velocity = velocity;
        this.radius = 5;
        this.alive = true;
        this.owner = owner;
        this.maxDistance = Math.sqrt(Math.pow(tileMap.tileWidth/2,2) + Math.pow(tileMap.tileHeight/2,2));
      }
      update(deltaTime) {
        this.position = this.position.add(this.velocity.scale(deltaTime));
        if (this.position.subtract(this.startPosition).length() >= this.maxDistance)
          this.alive = false;
        if (this.position.x < -50 || this.position.x > canvas.width+50 ||
            this.position.y < -50 || this.position.y > canvas.height+50)
          this.alive = false;
      }
      render(ctx, camera) {
        let screenPos = camera.worldToScreen(this.position);
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI*2);
        ctx.fillStyle = "yellow";
        ctx.fill();
      }
    }
    
    // --- Player Class ---
    class Player {
      constructor(tileX, tileY, tileMap) {
        this.animTime = 0;
        this.tileMap = tileMap;
        this.gridX = tileX;
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.pixelSize = PIXEL_SIZE * 0.5;
        this.width = 32 * this.pixelSize;
        this.height = 32 * this.pixelSize;
        this.moving = false;
        this.startPos = null;
        this.targetPos = null;
        this.moveDuration = 0.1;
        this.moveTime = 0;
        this.targetGridX = tileX;
        this.targetGridY = tileY;
        this.direction = "down";
        this.maxHP = 100;
        this.hp = 100;
        this.normalStrikeRange = 50;
        this.strikeMeter = 0;
        this.maxStrikeMeter = strikeMeterCapacity;
        this.knockback = new Vector2(0, 0);
        this.isDead = false;
        this.spriteSheet = new Image();
        this.spriteLoaded = false;
        this.spriteSheet.onload = () => { this.spriteLoaded = true; };
        this.spriteSheet.src = "https://s3-us-west-2.amazonaws.com/s.cdpn.io/21542/WalkingDemo-SHIRMOND-SHEET.png";
        this.frameCount = 4;
        this.currentFrame = 0;
        this.frameTime = 0;
        this.frameDelay = 0.1;
        this.isDashing = false;
        this.dashStart = null;
        this.dashEnd = null;
        this.dashDuration = 0.2;
        this.dashElapsed = 0;
        this.damageFlashTimer = 0;
        this.damageVibrateTimer = 0;
        this.vibrationMagnitude = 5;
      }
      
      flashDamage() {
        this.damageFlashTimer = 0.3;
        this.damageVibrateTimer = 0.3;
      }
      
      startDash(direction) {
        if (this.isDashing) return;
        this.isDashing = true;
        this.dashElapsed = 0;
        const dashDistance = strikeRangeTiles * 50;
        let dashVector;
        switch(direction) {
          case "up":    dashVector = new Vector2(0, -dashDistance); break;
          case "down":  dashVector = new Vector2(0, dashDistance); break;
          case "left":  dashVector = new Vector2(-dashDistance, 0); break;
          case "right": dashVector = new Vector2(dashDistance, 0); break;
          default:      dashVector = new Vector2(0, 0);
        }
        this.dashStart = this.position;
        this.dashEnd = this.position.add(dashVector);
      }
      
      update(deltaTime) {
          if (this.moving) {
    // Update movement interpolation as before.
    this.moveTime += deltaTime;
    let t = Math.min(this.moveTime / this.moveDuration, 1);
    this.position = new Vector2(
      this.startPos.x + (this.targetPos.x - this.startPos.x) * t,
      this.startPos.y + (this.targetPos.y - this.startPos.y) * t
    );
    // Independently update the walk animation timer
    this.animTime += deltaTime;
    this.currentFrame = Math.floor(this.animTime / this.frameDelay) % this.frameCount;
    
    if (t >= 1) {
      this.moving = false;
      this.gridX = this.targetGridX;
      this.gridY = this.targetGridY;
      // (Optionally, if you want to reset the animation when stopping:)
      // this.animTime = 0;
      // this.currentFrame = 0;
    }
  } else {
    // When not moving, reset animation so the idle frame is shown.
    this.animTime = 0;
    this.currentFrame = 0;
  }
        if (this.isDashing) {
          this.dashElapsed += deltaTime;
          let t = Math.min(this.dashElapsed / this.dashDuration, 1);
          let easeT = t * t;
          this.position = new Vector2(
            this.dashStart.x + (this.dashEnd.x - this.dashStart.x) * easeT,
            this.dashStart.y + (this.dashEnd.y - this.dashStart.y) * easeT
          );
          let playerCenter = new Vector2(this.position.x + this.width/2, this.position.y + this.height/2);
          enemies.forEach(enemy => {
            let enemyCenter = new Vector2(enemy.position.x + enemy.width/2, enemy.position.y + enemy.height/2);
            if (playerCenter.subtract(enemyCenter).length() < 50 && enemy.alive) {
           if (enemy.deathTimer === undefined) {
  enemy.deathTimer = 0.5; // Delay
  enemy.damageFlashTimer = 0.3;
  enemy.damageVibrateTimer = 0.3;
  swordEffects.push(new SwordEffect(playerCenter, enemyCenter, 0.5));
}
addSpriteFlash(enemy.position);

            }
          });
          createDashTrail(this.position, this.dashEnd);
          if (t >= 1) {
            this.isDashing = false;
            spawnShockwave(this.position);
          }
        } else if (this.moving) {
          this.moveTime += deltaTime;
          let t = Math.min(this.moveTime / this.moveDuration, 1);
          this.position = new Vector2(
            this.startPos.x + (this.targetPos.x - this.startPos.x) * t,
            this.startPos.y + (this.targetPos.y - this.startPos.y) * t
          );
          this.frameTime += deltaTime;
          if (this.frameTime >= this.frameDelay) {
            this.currentFrame = (this.currentFrame + 1) % this.frameCount;
            this.frameTime = 0;
          }
          if (t >= 1) {
            this.moving = false;
            this.gridX = this.targetGridX;
            this.gridY = this.targetGridY;
            this.currentFrame = 0;
          }
        } else {
          this.currentFrame = 0;
        }
        if(this.damageFlashTimer > 0) {
          this.damageFlashTimer -= deltaTime;
          if(this.damageFlashTimer < 0) this.damageFlashTimer = 0;
        }
        if(this.damageVibrateTimer > 0) {
          this.damageVibrateTimer -= deltaTime;
          if(this.damageVibrateTimer < 0) this.damageVibrateTimer = 0;
        }
        this.knockback = this.knockback.scale(0.9);
      }
      
render(ctx, camera) {
  // Calculate any shake offset
  let offsetX = 0, offsetY = 0;
  if (this.damageVibrateTimer > 0) {
    offsetX = (Math.random() * 2 - 1) * this.vibrationMagnitude;
    offsetY = (Math.random() * 2 - 1) * this.vibrationMagnitude;
  }
  let pos = this.position.add(this.knockback);
  let screenPos = camera.worldToScreen(new Vector2(pos.x + offsetX, pos.y + offsetY));

  // Save the context so we can restore later
  ctx.save();
 // If on water, clip the drawing to the top half only.
  if (this.tileMap.tiles[this.gridY][this.gridX].tileType === 1) {
    ctx.beginPath();
    ctx.rect(screenPos.x, screenPos.y, this.width, this.height / 2);
    ctx.clip();
  }
  
  // If dashing, reduce opacity
  if (this.isDashing) {
    ctx.globalAlpha = 0.7;
  }

  // Determine source frame
  let row = this._getRowForDirection();
  let srcX = this.currentFrame * 32;
  let srcY = row * 32;

  // --- Draw glow effects underneath the sprite ---
  
  // Shield glow (blue)
  if (defenseBoostActive) {
    ctx.save();
    ctx.shadowBlur = 20;
    ctx.shadowColor = "rgba(0,0,255,0.8)";
    ctx.drawImage(
      this.spriteSheet,
      srcX, srcY, 32, 32,
      screenPos.x, screenPos.y, this.width, this.height
    );
    ctx.restore();
  }

  // Healing charm glow (purple)
  if (healingCharmActive) {
    ctx.save();
    ctx.shadowBlur = 20;
    ctx.shadowColor = "rgba(128,0,128,0.8)";
    ctx.drawImage(
      this.spriteSheet,
      srcX, srcY, 32, 32,
      screenPos.x, screenPos.y, this.width, this.height
    );
    ctx.restore();
  }

  // Auto‚Äëstrike glow (orange)
  if (autoStrikeTime > 0) {
    ctx.save();
    ctx.shadowBlur = 20;
    ctx.shadowColor = "rgba(255,165,0,0.8)";
    ctx.drawImage(
      this.spriteSheet,
      srcX, srcY, 32, 32,
      screenPos.x, screenPos.y, this.width, this.height
    );
    ctx.restore();
  }

  // --- Draw the base player sprite on top of the glows ---
  ctx.drawImage(
    this.spriteSheet,
    srcX, srcY, 32, 32,
    screenPos.x, screenPos.y, this.width, this.height
  );

  // --- If damage flash is active, draw a red-tinted overlay on top ---
  if (this.damageFlashTimer > 0) {
    let offCanvas = document.createElement("canvas");
    offCanvas.width = this.width;
    offCanvas.height = this.height;
    let offCtx = offCanvas.getContext("2d");

    // Draw the sprite onto the offscreen canvas
    offCtx.drawImage(this.spriteSheet, srcX, srcY, 32, 32, 0, 0, this.width, this.height);

    // Mask with red fill (using source-atop so it only covers the sprite shape)
    offCtx.globalCompositeOperation = "source-atop";
    offCtx.fillStyle = "rgba(255, 0, 0, 0.5)";
    offCtx.fillRect(0, 0, this.width, this.height);

    // Draw the tinted sprite on top of the base sprite
    ctx.drawImage(offCanvas, screenPos.x, screenPos.y);
  }

  ctx.restore();
}

// Helper method to get the row for the current direction:
_getRowForDirection() {
  switch (this.direction) {
    case "down":  return 0;
    case "right": return 1;
    case "up":    return 2;
    case "left":  return 3;
    default:      return 0;
  }
}



      
   move(direction) {
  if (this.moving || this.isDashing) return;
  
  // Determine the new grid position
  let newGridX = this.gridX, newGridY = this.gridY;
  if (direction === "up") newGridY -= 1;
  else if (direction === "down") newGridY += 1;
  else if (direction === "left") newGridX -= 1;
  else if (direction === "right") newGridX += 1;
  
  // Check bounds
  if (newGridX < 0 || newGridX >= this.tileMap.width ||
      newGridY < 0 || newGridY >= this.tileMap.height) return;
  
  // Get the target tile and check passability
  let targetTile = this.tileMap.tiles[newGridY][newGridX];
  if (!isTilePassable(targetTile)) return;
  
  // Set the movement duration.
     
  // If the tile is a mountain (tileType 3), slow down movement further.
const baseMoveDuration = 0.24;  // Base duration for normal tiles
let speedMultiplier;
if (targetTile.tileType === 3) {       // mountain: slower
  speedMultiplier = 2;
} else if (targetTile.tileType === 1) {  // water: even slower than mountain
  speedMultiplier = 3;
} else {
  speedMultiplier = 1;
}
this.moveDuration = baseMoveDuration * speedMultiplier;
  
  // Set up the movement as usual
  this.moving = true;
  this.moveTime = 0;
  this.startPos = this.position;
  this.targetPos = this.tileMap.gridToWorld(newGridX, newGridY);
  this.targetGridX = newGridX;
  this.targetGridY = newGridY;
  this.direction = direction;
  this.frameTime = 0;
  this.currentFrame = 0;
}

      
      shoot() {
        let startPos = new Vector2(this.position.x + this.width/2, this.position.y + this.height/2);
        let directionVector;
        switch (this.direction) {
          case "up": directionVector = new Vector2(0, -1); break;
          case "down": directionVector = new Vector2(0, 1); break;
          case "left": directionVector = new Vector2(-1, 0); break;
          case "right": directionVector = new Vector2(1, 0); break;
          default: directionVector = new Vector2(0, -1);
        }
        let bulletSpeed = 600, velocity = directionVector.scale(bulletSpeed);
        bullets.push(new Bullet(new Vector2(this.position.x + this.width/2, this.position.y + this.height/2), velocity, "player"));
      }
      
      shootAt(target) {
        let startPos = new Vector2(this.position.x + this.width/2, this.position.y + this.height/2);
        let diff = target.subtract(startPos), norm = diff.normalize();
        let bulletSpeed = 600, velocity = norm.scale(bulletSpeed);
        bullets.push(new Bullet(startPos, velocity, "player"));
      }
      
      respawn() {
        this.gridX = 5;
        this.gridY = 5;
        this.position = this.tileMap.gridToWorld(this.gridX, this.gridY);
        this.hp = this.maxHP;
        this.isDead = false;
      }
      
      strike(direction) {
        let strikeRange;
        if (strikeRangeTiles <= 1) {
          strikeRange = this.normalStrikeRange;
        } else {
          if (this.strikeMeter >= 10) {
            strikeRange = strikeRangeTiles * 50;
            this.strikeMeter -= 10;
          } else { 
            strikeRange = this.normalStrikeRange; 
          }
        }
        let offset;
        switch(direction) {
          case "up": offset = new Vector2(0, -strikeRange); break;
          case "down": offset = new Vector2(0, strikeRange); break;
          case "left": offset = new Vector2(-strikeRange, 0); break;
          case "right": offset = new Vector2(strikeRange, 0); break;
          default: offset = new Vector2(0, -strikeRange);
        }
        let playerCenter = new Vector2(this.position.x + this.width/2, this.position.y + this.height/2);
        let strikeCenter = playerCenter.add(offset);
        triggerHeadbutt();playSFX("swingSword");
        enemies.forEach(enemy => {
          let enemyCenter = new Vector2(enemy.position.x + enemy.width/2, enemy.position.y + enemy.height/2);
       if (enemyCenter.subtract(strikeCenter).length() <= strikeRange) {
         playSFX("attack");playSFX("enemyDamage");  // Set a death timer if not already set
  if (enemy.deathTimer === undefined) {
    enemy.deathTimer = 0.5; // Delay in seconds (adjust as needed)
      enemy.damageFlashTimer = 0.3;
  enemy.damageVibrateTimer = 0.3;
    swordEffects.push(new SwordEffect(playerCenter, enemyCenter, 0.5));
  }
  addSpriteFlash(enemy.position);
  
  // Remove immediate explosion and kill actions.
  // The enemy.update() method will handle the explosion and marking as dead.
  
  let angle = Math.atan2(enemyCenter.y - strikeCenter.y, enemyCenter.x - strikeCenter.x);
  let effectX = strikeCenter.x + Math.cos(angle) * 20;
  let effectY = strikeCenter.y + Math.sin(angle) * 20;
  spawnMeleeEffect(effectX, effectY, angle);
}

        });
      }
    }
    
    class Enemy {
      constructor(tileX, tileY, tileMap) {
        this.damageFlashTimer = 0;
    this.damageVibrateTimer = 0;
        this.tileMap = tileMap;
        this.gridX = tileX;
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.pixelSize = PIXEL_SIZE * 0.5;
        this.width = 32 * this.pixelSize;
        this.height = 32 * this.pixelSize;
        this.spriteSheet = new Image();
        this.spriteLoaded = false;
        this.spriteSheet.onload = () => { this.spriteLoaded = true; };
        this.spriteSheet.src = "https://s3-us-west-2.amazonaws.com/s.cdpn.io/21542/WalkingDemo-BEAR-SHEET.png";
        this.alive = true;
        this.maxHP = 40;
        this.hp = 40;
        this.moving = false;
        this.startPos = null;
        this.targetPos = null;
        this.moveDuration = 0.2;
        this.moveTime = 0;
        this.targetGridX = tileX;
        this.targetGridY = tileY;
        this.direction = "down";
        this.frameCount = 4;
        this.currentFrame = 0;
        this.frameTime = 0;
        this.frameDelay = 0.15;
        this.attackCooldown = 0;
        this.knockback = new Vector2(0, 0);
        this.deathTimer = undefined;
      }
      update(deltaTime) {
       // If the enemy has been struck, decrement the death timer.
    if (this.deathTimer !== undefined) {
      this.deathTimer -= deltaTime;
      if (this.deathTimer <= 0) { 
         if (this.alive) { // Ensure this runs only once
        this.alive = false;
        spawnEnemyExplosionEffect(this.position);
        triggerScreenFlash();
        addSpriteFlash(this.position);
        playSFX("enemyDie"); // üî• Play sound here, only once
        killCount++;
      }
        return; // Skip the rest of the update once dead.
      }  // Decrement flash and vibrate timers
  if (this.damageFlashTimer > 0) {
    this.damageFlashTimer -= deltaTime;
    if (this.damageFlashTimer < 0) this.damageFlashTimer = 0;
  }
  if (this.damageVibrateTimer > 0) {
    this.damageVibrateTimer -= deltaTime;
    if (this.damageVibrateTimer < 0) this.damageVibrateTimer = 0;
  }
    }
        if (this.moving) {
          this.moveTime += deltaTime;
          let t = Math.min(this.moveTime / this.moveDuration, 1);
          this.position = new Vector2(
            this.startPos.x + (this.targetPos.x - this.startPos.x) * t,
            this.startPos.y + (this.targetPos.y - this.startPos.y) * t
          );
          this.frameTime += deltaTime;
          if (this.frameTime >= this.frameDelay) {
            this.currentFrame = (this.currentFrame + 1) % this.frameCount;
            this.frameTime = 0;
          }
          if (t >= 1) {
            this.moving = false;
            this.gridX = this.targetGridX;
            this.gridY = this.targetGridY;
            this.currentFrame = 0;
          }
        } else {
          let targetGridX, targetGridY;
          if (baitBombs.length > 0) {
            let targetBomb = baitBombs[0];
            targetGridX = targetBomb.tileX;
            targetGridY = targetBomb.tileY;
          } else {
            targetGridX = player.gridX;
            targetGridY = player.gridY;
            let dxP = player.gridX - this.gridX, dyP = player.gridY - this.gridY;
            let manhattanP = Math.abs(dxP) + Math.abs(dyP);
            if (manhattanP <= 1 && this.attackCooldown <= 0) {
              this.shoot();
              this.attackCooldown = 1.0;
              return;
            }
          }
          let dx = targetGridX - this.gridX, dy = targetGridY - this.gridY;
          if (Math.abs(dx) + Math.abs(dy) > 0) {
            let direction = Math.abs(dx) >= Math.abs(dy) ? (dx > 0 ? "right" : "left") : (dy > 0 ? "down" : "up");
            this.move(direction);
          }
          if (this.attackCooldown > 0) this.attackCooldown -= deltaTime;
        }
        this.knockback = this.knockback.scale(0.9);
      }
   render(ctx, camera) {
  // Calculate screen position (and add any shake offsets)
  let pos = this.position.add(this.knockback);
  let screenPos = camera.worldToScreen(pos);
  let offsetX = 0, offsetY = 0;
  if (this.damageVibrateTimer > 0) {
    offsetX = (Math.random() * 2 - 1) * 5;
    offsetY = (Math.random() * 2 - 1) * 5;
  }
  screenPos.x += offsetX;
  screenPos.y += offsetY;
  
  // Save the context so any clipping we do here won‚Äôt affect later drawings
  ctx.save();

  // If this enemy is on a water tile, clip to only the top half of its sprite.
  if (
    this.tileMap.tiles[this.gridY] &&
    this.tileMap.tiles[this.gridY][this.gridX] &&
    this.tileMap.tiles[this.gridY][this.gridX].tileType === 1
  ) {
    ctx.beginPath();
    ctx.rect(screenPos.x, screenPos.y, this.width, this.height / 2);
    ctx.clip();
  }
  
  // Draw the enemy sprite (and any red tint for damage)
  if (this.spriteLoaded) {
    let row;
    switch (this.direction) {
      case "down":  row = 0; break;
      case "right": row = 1; break;
      case "up":    row = 2; break;
      case "left":  row = 3; break;
      default:      row = 0;
    }
    let srcX = this.currentFrame * 32;
    let srcY = row * 32;
    ctx.drawImage(
      this.spriteSheet,
      srcX, srcY, 32, 32,
      screenPos.x, screenPos.y, this.width, this.height
    );
    
    if (this.damageFlashTimer > 0) {
      let offCanvas = document.createElement("canvas");
      offCanvas.width = this.width;
      offCanvas.height = this.height;
      let offCtx = offCanvas.getContext("2d");
      offCtx.drawImage(this.spriteSheet, srcX, srcY, 32, 32, 0, 0, this.width, this.height);
      offCtx.globalCompositeOperation = "source-atop";
      offCtx.fillStyle = "rgba(255, 0, 0, 0.5)";
      offCtx.fillRect(0, 0, this.width, this.height);
      ctx.drawImage(offCanvas, screenPos.x, screenPos.y);
    }
  } else {
    ctx.fillStyle = "green";
    ctx.fillRect(screenPos.x, screenPos.y, this.width, this.height);
  }
  
  // Restore the context so that the clip doesn't affect other drawings (like the player)
  ctx.restore();
     
}

  move(direction) {
  if (this.moving) return;
  let newGridX = this.gridX, newGridY = this.gridY;
  if (direction === "up") newGridY -= 1;
  else if (direction === "down") newGridY += 1;
  else if (direction === "left") newGridX -= 1;
  else if (direction === "right") newGridX += 1;
  if (newGridX < 0 || newGridX >= this.tileMap.width ||
      newGridY < 0 || newGridY >= this.tileMap.height) return;
  
  // Get the target tile
  let targetTile = this.tileMap.tiles[newGridY][newGridX];
  if (!isTilePassable(targetTile)) return;
  
  // Set up movement properties
  this.moving = true;
  this.moveTime = 0;
  this.startPos = this.position;
  this.targetPos = this.tileMap.gridToWorld(newGridX, newGridY);
  this.targetGridX = newGridX;
  this.targetGridY = newGridY;
  this.direction = direction;
  this.frameTime = 0;
  this.currentFrame = 0;
  
  // Define a base move duration (for example, 0.2 seconds) and apply multipliers
  // Adjust multipliers as needed:
  const baseMoveDuration = 0.2;
  let speedMultiplier;
  if (targetTile.tileType === 3) {       // mountain: very slow
    speedMultiplier = 2;
  } else if (targetTile.tileType === 1) {  // water: even slower
    speedMultiplier = 3;
  } else if (targetTile.tileType === 2) {  // sand: slower for enemy than player
    speedMultiplier = 1.5;
  } else {                               // normal (grass)
    speedMultiplier = 1;
  }
  
  this.moveDuration = baseMoveDuration * speedMultiplier;
}
      shoot() {
        let startPos = new Vector2(this.position.x + this.width/2, this.position.y + this.height/2);
        let playerCenter = new Vector2(player.position.x + player.width/2, player.position.y + player.height/2);
        let diff = playerCenter.subtract(startPos), norm = diff.normalize();
        let bulletSpeed = 600, velocity = norm.scale(bulletSpeed);
        bullets.push(new Bullet(startPos, velocity, "enemy"));
      }
    }
    
    let screenShakeTime = 0, screenShakeMagnitude = 0, shakeOffset = new Vector2(0,0);
    function resolveCollision(entityA, entityB) {
      let ax = entityA.position.x + entityA.knockback.x,
          ay = entityA.position.y + entityA.knockback.y,
          aw = entityA.width, ah = entityA.height;
      let bx = entityB.position.x + entityB.knockback.x,
          by = entityB.position.y + entityB.knockback.y,
          bw = entityB.width, bh = entityB.height;
      if (ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by) {
        let centerA = new Vector2(ax + aw/2, ay + ah/2);
        let centerB = new Vector2(bx + bw/2, by + bh/2);
        let diff = centerA.subtract(centerB);
        let distance = diff.length();
        if (distance === 0) { diff = new Vector2(1,0); distance = 1; }
        let minDistance = (aw+bw)/4;
        let overlap = minDistance - distance;
        if (overlap > 0) {
          let knock = diff.normalize().scale(overlap*0.5);
          entityA.knockback = entityA.knockback.add(knock);
          entityB.knockback = entityB.knockback.subtract(knock);
        }
      }
    }
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const camera = new Camera(canvas.width, canvas.height);
    const tileMap = new TileMap(60, 60, 64, 32);
    let corners = [
      tileMap.gridToWorld(0,0),
      tileMap.gridToWorld(tileMap.width-1,0),
      tileMap.gridToWorld(0,tileMap.height-1),
      tileMap.gridToWorld(tileMap.width-1, tileMap.height-1)
    ];
    let worldMinX = Math.min(...corners.map(c=>c.x));
    let worldMaxX = Math.max(...corners.map(c=>c.x)) + tileMap.tileWidth;
    let worldMinY = Math.min(...corners.map(c=>c.y));
    let worldMaxY = Math.max(...corners.map(c=>c.y)) + tileMap.tileHeight;
    function updateCamera() {
      let halfWidth = (canvas.width / camera.zoom) / 2;
      let halfHeight = (canvas.height / camera.zoom) / 2;
      let worldWidth = worldMaxX - worldMinX, worldHeight = worldMaxY - worldMinY;
      let targetX = player.position.x, targetY = player.position.y;
      if (worldWidth < canvas.width / camera.zoom) { targetX = worldMinX + worldWidth/2; }
      else { targetX = clamp(player.position.x, worldMinX+halfWidth, worldMaxX-halfWidth); }
      if (worldHeight < canvas.height / camera.zoom) { targetY = worldMinY + worldHeight/2; }
      else { targetY = clamp(player.position.y, worldMinY+halfHeight, worldMaxY-halfHeight); }
      camera.position = new Vector2(targetX, targetY);
    }
    
    let player = new Player(5, 5, tileMap);
    player.strikeMeter = 0;
    const bullets = [], enemies = [];
    let enemySpawnTimer = 0;
    
    function performAutoStrike() {
  let playerCenter = new Vector2(player.position.x + player.width / 2, player.position.y + player.height / 2);
  let effectiveRange = (strikeRangeTiles > 1 && player.strikeMeter >= 10) ? strikeRangeTiles * 50 : 50;
  const offsetDistance = 20;

  let swordThrown = false; // ‚úÖ Track if at least one sword is thrown

  enemies.forEach(enemy => {
    let enemyCenter = new Vector2(enemy.position.x + enemy.width / 2, enemy.position.y + enemy.height / 2);

    if (playerCenter.subtract(enemyCenter).length() < effectiveRange) {
      if (enemy.deathTimer === undefined) {
        enemy.deathTimer = 0.5;
        enemy.damageFlashTimer = 0.3;
        enemy.damageVibrateTimer = 0.3;

        // ‚úÖ Add a new sword effect (this is when the sword is thrown)
        swordEffects.push(new SwordEffect(playerCenter, enemyCenter, 0.5));

        swordThrown = true; // ‚úÖ Mark that at least one sword was thrown
      }

      addSpriteFlash(enemy.position);

      let angle = Math.atan2(enemyCenter.y - playerCenter.y, enemyCenter.x - playerCenter.x);
      let effectX = playerCenter.x + Math.cos(angle) * offsetDistance;
      let effectY = playerCenter.y + Math.sin(angle) * offsetDistance;
      spawnMeleeEffect(effectX, effectY, angle);
    }
  });

  if (swordThrown) {
    playSFX("swingSword"); // ‚úÖ Play sound only if a sword was actually thrown
  }
}
    
    const attackSlot = document.getElementById("attackSlot");
    attackSlot.classList.add("dimmed");
    function updateAttackSlot() {
      if(player.strikeMeter>0) {
        attackSlot.classList.remove("dimmed");
        attackSlot.style.borderColor = "red";
        attackSlot.style.boxShadow = "0 0 10px 3px rgba(255,0,0,0.8)";
      } else {
        attackSlot.classList.add("dimmed");
        attackSlot.style.borderColor = "";
        attackSlot.style.boxShadow = "";
      }
    }
    // Modified dash attack: It no longer depletes the strike meter.
    function executeDashAttack() {
      if(player.strikeMeter > 0) {
        player.startDash(player.direction);
        updateAttackSlot();   showUpgradeAlert("Dash attack executed!");
      }
    }
    
    // Updated event listener: removed meter depletion after dash attack.
    attackSlot.addEventListener("click",()=>{
      if(player.strikeMeter>0){
        executeDashAttack();
      }
    });
    
    function createDashTrail(startPos, endPos) {
      const trailSteps = 10;
      for(let i=0;i<trailSteps;i++){
        let t = i/trailSteps;
        let trailPos = new Vector2(
          startPos.x + (endPos.x - startPos.x)*t,
          startPos.y + (endPos.y - startPos.y)*t
        );
        spawnDashEffect(trailPos);
      }
    }
    
    function spawnDashEffect(position) {
      let effectDuration = 0.3;
      spriteFlashes.push({position, timer: effectDuration, duration: effectDuration});
    }
    
    function spawnShockwave(position) {
      spriteFlashes.push({position, timer: 0.5, duration: 0.5});
    }
    
    function knockbackEnemyToEdge(enemy) {
      let direction = new Vector2(enemy.position.x-player.position.x, enemy.position.y-player.position.y).normalize();
      let knockbackDistance = Math.max(tileMap.width,tileMap.height)*50;
      let finalPos = enemy.position.add(direction.scale(knockbackDistance));
      enemy.position = finalPos; x
      spawnEnemyExplosionEffect(enemy.position);
      killCount++;
    }
    
    function performManualStrikeAt(tapX, tapY) {
      const tileSize = 50;
      const currentMeleeRange = strikeRangeTiles*tileSize;
      for(let enemy of enemies){
        let enemyScreenPos = camera.worldToScreen(enemy.position);
        let enemyRect = {x: enemyScreenPos.x, y: enemyScreenPos.y, width: enemy.width, height: enemy.height};
        if(tapX>=enemyRect.x && tapX<=enemyRect.x+enemyRect.width &&
           tapY>=enemyRect.y && tapY<=enemyRect.y+enemyRect.height){
          let playerCenter = new Vector2(player.position.x+player.width/2, player.position.y+player.height/2);
          let enemyCenter = new Vector2(enemy.position.x+enemy.width/2, enemy.position.y+enemy.height/2);
          if(playerCenter.subtract(enemyCenter).length()<=currentMeleeRange){
            playSFX("attack");         swordEffects.push(new SwordEffect(playerCenter, enemyCenter));
let angle = Math.atan2(enemyCenter.y - playerCenter.y, enemyCenter.x - playerCenter.x);
let effectX = playerCenter.x + Math.cos(angle) * 20;
let effectY = playerCenter.y + Math.sin(angle) * 20;

addSpriteFlash(enemy.position);
spawnMeleeEffect(effectX, effectY, angle);

// Instead of killing immediately, set a death timer (if not already set)
if (enemy.deathTimer === undefined) {
  enemy.deathTimer = 0.5; // delay in seconds before enemy dies
}

// Optionally, store additional info if needed (e.g., for a "dying" state)
// The enemy's update() function should then check if deathTimer <= 0,
// and if so, call spawnEnemyExplosionEffect(enemy.position), mark enemy.alive = false,
// and increment killCount.
return true;

          }
        }
      }
      return false;
    }
    
    let dragStart = null;
    canvas.addEventListener("mousedown", evt => { dragStart = {x: evt.clientX, y: evt.clientY}; });
    canvas.addEventListener("mousemove", evt => { });
    canvas.addEventListener("mouseup", evt => {
      if(!dragStart) return;
      let dx = evt.clientX - dragStart.x;
      let dy = evt.clientY - dragStart.y;
      if(Math.sqrt(dx*dx+dy*dy)>10){
        let direction = Math.abs(dx)>Math.abs(dy) ? (dx>0?"right":"left") : (dy>0?"down":"up");
        if(!player.moving && !player.isDashing) { player.strike(direction); }
      } else { handleTap(evt); }
      dragStart = null;
    });
    
    function handleTap(evt) {
      evt.preventDefault();
      let rect = canvas.getBoundingClientRect();
      let tapX = evt.clientX - rect.left, tapY = evt.clientY - rect.top;
      if(performManualStrikeAt(tapX, tapY)) { triggerHeadbutt(); return; playSFX("attack");}
      let dir = computeDirection(evt.clientX, evt.clientY);
      if(dir && !player.moving && !player.isDashing) { player.move(dir); }
      else {
        let playerScreenPos = camera.worldToScreen(player.position);
        if(tapX>=playerScreenPos.x && tapX<=playerScreenPos.x+player.width &&
           tapY>=playerScreenPos.y && tapY<=playerScreenPos.y+player.height) { triggerHeadbutt(); }
      }
    }
    
    function computeDirection(clientX, clientY) {
      let rect = canvas.getBoundingClientRect();
      let tapX = clientX - rect.left, tapY = clientY - rect.top;
      let worldPos = camera.screenToWorld(new Vector2(tapX, tapY));
      let gridX = Math.floor((worldPos.x/32+worldPos.y/16)/2);
      let gridY = Math.floor((worldPos.y/16 - worldPos.x/32)/2);
      if(gridX===player.gridX && gridY===player.gridY) return null;
      let dx = gridX - player.gridX, dy = gridY - player.gridY;
      let direction;
      if(Math.abs(dx)+Math.abs(dy)===1)
        direction = dx===1?"right": dx===-1?"left": dy===1?"down":"up";
      else
        direction = Math.abs(dx)>=Math.abs(dy) ? (dx>0?"right":"left") : (dy>0?"down":"up");
      return direction;
    }
    
    function rectIntersect(a,b) {
      return a.x < b.x+b.width && a.x+a.width > b.x &&
             a.y < b.y+b.height && a.y+a.height > b.y;
    }
    
    function triggerHeadbutt() {
      let playerScreenPos = camera.worldToScreen(player.position);
      let headbuttDiv = document.getElementById("headbuttEffect");
      headbuttDiv.style.left = (playerScreenPos.x+player.width/2-32)+"px";
      headbuttDiv.style.top = (playerScreenPos.y+player.height/2-32)+"px";
      headbuttDiv.classList.remove("active");
      void headbuttDiv.offsetWidth;
      headbuttDiv.classList.add("active");
      let playerBox = { x: playerScreenPos.x, y: playerScreenPos.y, width: player.width, height: player.height };
      enemies.forEach(enemy=>{    let enemyScreenPos = camera.worldToScreen(enemy.position);
        let enemyBox = { x: enemyScreenPos.x, y: enemyScreenPos.y, width: enemy.width, height: enemy.height };
        if(rectIntersect(playerBox, enemyBox)){
          addSpriteFlash(enemy.position);
          let playerCenter = new Vector2(playerBox.x+playerBox.width/2, playerBox.y+playerBox.height/2);
          let enemyCenter = new Vector2(enemyBox.x+enemyBox.width/2, enemyBox.y+enemyBox.height/2);
          let knockVec = enemyCenter.subtract(playerCenter).normalize().scale(40);
          enemy.knockback = enemy.knockback.add(knockVec);
        }
      });
    }
    
    function deployBomb() {
      if(bombCount>0){
        bombCount--;
        baitBombs.push(new BaitBomb(player.gridX, player.gridY, tileMap));showUpgradeAlert("Bomb deployed!");
        
      }updateInventoryDisplay();
    }
    class BaitBomb {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap;
        this.tileX = tileX;
        this.tileY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.timer = 3.0;
      }
      update(deltaTime) { this.timer -= deltaTime; }
      render(ctx, camera, t) {
        let screenPos = camera.worldToScreen(this.position);
        let pulse = 1+0.2*Math.sin(t*10);
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.scale(pulse, pulse);
        ctx.font = `${this.tileMap.tileWidth/2}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#FFFF00";
        ctx.fillText("üí£", 0, 0);
        ctx.restore();
        ctx.font = "12px sans-serif";
        ctx.fillStyle = "white";
        ctx.fillText(this.timer.toFixed(1), screenPos.x, screenPos.y-5);
      }
    }
    
    const explosivesSlot = document.getElementById("explosivesSlot");
    explosivesSlot.addEventListener("click", evt=>{
      if(bombCount>0){
        deployBomb();
        explosivesSlot.classList.add("active");
        setTimeout(()=>{ explosivesSlot.classList.remove("active"); },200);
      }
    });
    
    function updateExplosivesSlot() {
      const explosivesSlot = document.getElementById("explosivesSlot");
      explosivesSlot.innerHTML = "üí£<div class='counter'>"+bombCount+"</div>";
      if(bombCount>0){
        explosivesSlot.style.opacity = "1";
        explosivesSlot.style.cursor = "pointer";
        explosivesSlot.classList.add("bomb-available");
      } else {
        explosivesSlot.style.opacity = "0.5";
        explosivesSlot.style.cursor = "default";
        explosivesSlot.classList.remove("bomb-available");
      }
    }
    
    function updatePowerupTraySlots() {
      const defenseSlot = document.getElementById("defenseSlot");
      const charmsSlot = document.getElementById("charmsSlot");
   if(defenseBoostActive){
  defenseSlot.classList.remove("dimmed");
  const defRatio = defenseBoostTimer / baseDefenseBoostDuration;
  defenseSlot.style.background = `linear-gradient(to top, blue ${defRatio*100}%, transparent ${defRatio*100}%)`;
  // Add a subtle blue glow:
  defenseSlot.style.boxShadow = `0 0 8px 2px rgba(0, 0, 255, 0.6)`;
  defenseSlot.innerHTML = "üõ°Ô∏è<div class='timer'>"+Math.ceil(defenseBoostTimer)+"s</div>";
} else {
  defenseSlot.classList.add("dimmed");
  defenseSlot.style.background = "";
  defenseSlot.style.boxShadow = "";
  defenseSlot.innerHTML = "üõ°Ô∏è";
}

if(healingCharmActive){
  charmsSlot.classList.remove("dimmed");
  const charmRatio = healingCharmTimer / baseHealingCharmDuration;
  charmsSlot.style.background = `linear-gradient(to top, purple ${charmRatio*100}%, transparent ${charmRatio*100}%)`;
  // Add a subtle purple glow:
  charmsSlot.style.boxShadow = `0 0 8px 2px rgba(128, 0, 128, 0.6)`;
  charmsSlot.innerHTML = "ü™¨<div class='timer'>"+Math.ceil(healingCharmTimer)+"s</div>";
} else {
  charmsSlot.classList.add("dimmed");
  charmsSlot.style.background = "";
  charmsSlot.style.boxShadow = "";
  charmsSlot.innerHTML = "ü™¨";
}

      updateRankDisplay();
    }
    
    function updatePickups() {
      for(let i=pickups.length-1;i>=0;i--){
        let pickup = pickups[i];
        if(player.position.x < pickup.position.x+pickup.size &&
           player.position.x+player.width > pickup.position.x &&
           player.position.y < pickup.position.y+pickup.size &&
           player.position.y+player.height > pickup.position.y){
          if(pickup instanceof BombPickup){showUpgradeAlert("Bomb collected!");
            bombCount++; spawnPickupEffect(pickup.position);
          } else if(pickup instanceof SwordPickup){showUpgradeAlert("Max-Strike collected!");
            autoStrikeTime += autoStrikeBonus;
            if(strikeRangeTiles>1){ player.strikeMeter = strikeMeterCapacity; }
            spawnPickupEffect(pickup.position);
          } else if(pickup instanceof HealthPickup){showUpgradeAlert("Health collected!");
            // Scale healing with player's max HP (e.g., heal 20% of max HP)
            const healAmount = Math.floor(player.maxHP * 0.2);
            player.hp = Math.min(player.hp + healAmount, player.maxHP);
            spawnPickupEffect(pickup.position);
          } else if(pickup instanceof DefenseBoostPickup){showUpgradeAlert("Shield collected!");
            defenseBoostActive = true;
            defenseBoostTimer = baseDefenseBoostDuration;
            spawnPickupEffect(pickup.position);
          } else if(pickup instanceof HealingCharmPickup){showUpgradeAlert("Healing Charm collected!");
            healingCharmActive = true;
            healingCharmTimer = baseHealingCharmDuration;
            spawnPickupEffect(pickup.position);
          }
          pickups.splice(i,1);
        }
      }updateInventoryDisplay();
    }
    
    function updateBaitBombs(deltaTime) {
      for(let i=baitBombs.length-1;i>=0;i--){
        baitBombs[i].update(deltaTime);
        if(baitBombs[i].timer<=0){
          screenShakeTime = 0.5; screenShakeMagnitude = 20;
          spawnExplosionEffect(baitBombs[i].position);playSFX("explosion");
          let bx = baitBombs[i].tileX, by = baitBombs[i].tileY;
          enemies.forEach(enemy=>{
            if(enemy.gridX>=bx-1 && enemy.gridX<=bx+1 &&
               enemy.gridY>=by-1 && enemy.gridY<=by+1 && enemy.alive){
              let blastDir = enemy.position.subtract(baitBombs[i].position).normalize();
              let blastForce = blastDir.scale(200);
              enemy.knockback = enemy.knockback.add(blastForce);
              enemy.alive = false;
            
              spawnEnemyExplosionEffect(enemy.position);
              killCount++;
              triggerScreenFlash();
              addSpriteFlash(enemy.position);
            }
          });
          baitBombs.splice(i,1);
        }
      }
    }
let alertToggle = false;

function showUpgradeAlert(message) {
  // Create the alert element.
  const alertDiv = document.createElement('div');
  alertDiv.className = 'upgrade-alert';
  alertDiv.textContent = message;

  // Temporarily position the alert off-screen so we can measure it.
  alertDiv.style.position = "fixed";
  alertDiv.style.top = "-9999px";
  alertDiv.style.left = "-9999px";
  document.body.appendChild(alertDiv);

  // Get the dimensions of the alert.
  const alertWidth = alertDiv.offsetWidth;
  const alertHeight = alertDiv.offsetHeight;
  
  // Calculate random positions that keep the alert fully within the viewport.
  const maxLeft = window.innerWidth - alertWidth;
  const maxTop = window.innerHeight - alertHeight;
  const randomLeft = Math.floor(Math.random() * maxLeft);
  const randomTop = Math.floor(Math.random() * maxTop);

  // Position the alert.
  alertDiv.style.left = `${randomLeft}px`;
  alertDiv.style.top = `${randomTop}px`;

  // Optionally, reset any other style properties if needed.
  // For example, if you were previously using calc() in CSS,
  // you can now set the fixed pixel values.

  // Remove the alert after 2 seconds.
  setTimeout(() => {
    alertDiv.remove();
  }, 2000);
}
    function updateMaxStrikeTally() {
      const tallyContainer = document.querySelector('#maxStrikeSlot .tally-container');
  const numTiles = Math.min(strikeRangeTiles, 20);  // cap at 20 tiles
      let tallyHTML = "";
      let threshold = strikeMeterCapacity/strikeRangeTiles;
      for(let i=0;i<numTiles;i++){
        if(player.strikeMeter>= (i+1)*threshold)
          tallyHTML += "<div class='tally'></div>";
        else
          tallyHTML += "<div class='tally' style='opacity:0.3;'></div>";
      }
      tallyContainer.innerHTML = tallyHTML;
    }
    
    function updateTrayHUD() {
      const pointsSlot = document.getElementById("pointsSlot");
      const pointsCounter = pointsSlot.querySelector('.counter');
      pointsCounter.textContent = Math.floor(points);
      
      const killsSlot = document.getElementById("killsSlot");
      const killsCounter = killsSlot.querySelector('.counter');
      killsCounter.textContent = killCount;
      
      const hpSlot = document.getElementById("hpSlot");
      const hpCounter = hpSlot.querySelector('.counter');
      hpCounter.textContent = Math.floor(player.hp);
      let hpPercentage = player.hp/player.maxHP;
      hpSlot.style.background = `linear-gradient(to top, rgba(255,0,0,0.7) ${hpPercentage*100}%, transparent ${hpPercentage*100}%)`;
      
      const autoStrikeSlot = document.getElementById("autoStrikeSlot");
      const autoStrikeCounter = autoStrikeSlot.querySelector('.counter');
      autoStrikeCounter.textContent = autoStrikeTime.toFixed(1);
      const autoStrikeIndicator = autoStrikeSlot.querySelector('.indicator');
      autoStrikeIndicator.textContent = autoStrikeTime > 0 ? "‚úÖ" : "‚ùå";
      const ratio = autoStrikeTime / baseAutoStrikeTime;
      autoStrikeSlot.style.background = `linear-gradient(to top, orange ${ratio*100}%, transparent ${ratio*100}%)`;
      // Add a glow effect when auto‚Äëstrike is active
if (autoStrikeTime > 0) {
  autoStrikeSlot.style.boxShadow = "0 0 10px 3px rgba(255,165,0,0.8)";
} else {
  autoStrikeSlot.style.boxShadow = "";
}
      const maxStrikeSlot = document.getElementById("maxStrikeSlot");
      let strikeFraction = player.strikeMeter / strikeMeterCapacity;
      maxStrikeSlot.style.background = `linear-gradient(to top, rgba(255,215,0,0.8) ${strikeFraction*100}%, transparent ${strikeFraction*100}%)`;
      updateMaxStrikeTally();
      // Add a glow effect when the strike meter is active
if (player.strikeMeter > 0) {
  maxStrikeSlot.style.boxShadow = "0 0 10px 3px rgba(255,215,0,0.8)";
} else {
  maxStrikeSlot.style.boxShadow = "";
}
      const defenseSlot = document.getElementById("defenseSlot");
      const charmsSlot = document.getElementById("charmsSlot");
      if(defenseBoostActive){
        defenseSlot.classList.remove("dimmed");
        const defRatio = defenseBoostTimer / baseDefenseBoostDuration;
        defenseSlot.style.background = `linear-gradient(to top, blue ${defRatio*100}%, transparent ${defRatio*100}%)`;
        defenseSlot.innerHTML = "üõ°Ô∏è<div class='timer'>"+Math.ceil(defenseBoostTimer)+"s</div>";
      } else {
        defenseSlot.classList.add("dimmed");
        defenseSlot.style.background = "";
        defenseSlot.innerHTML = "üõ°Ô∏è";
      }
      if(healingCharmActive){
        charmsSlot.classList.remove("dimmed");
        const charmRatio = healingCharmTimer / baseHealingCharmDuration;
        charmsSlot.style.background = `linear-gradient(to top, purple ${charmRatio*100}%, transparent ${charmRatio*100}%)`;
        charmsSlot.innerHTML = "ü™¨<div class='timer'>"+Math.ceil(healingCharmTimer)+"s</div>";
      } else {
        charmsSlot.classList.add("dimmed");
        charmsSlot.style.background = "";
        charmsSlot.innerHTML = "ü™¨";
      }  
      updateRankDisplay();
    }
    
  // Add a flag to indicate if the upgrade menu was triggered by death.
let deathTriggeredMenu = false;

// Modify showUpgradeMenu to accept a flag.
function showUpgradeMenu(triggeredByDeath = false) {
  deathTriggeredMenu = triggeredByDeath;
  // Preserve the current meter values.
  preservedAutoStrikeTime = autoStrikeTime;
  preservedStrikeMeter = player.strikeMeter;
  isUpgradeMenuVisible = true;
  document.getElementById("upgradeMenu").style.display = "flex";
  document.getElementById("pointsDisplay").textContent = Math.floor(points);
  timeScale = 0;
  document.getElementById("upgradeButton").style.display = "none";
}

// Update resumeGame so that resets occur only if triggered by death.
function resumeGame() {
  isUpgradeMenuVisible = false;
  document.getElementById("upgradeMenu").style.display = "none";
  
  // Only reset game elements if the menu was triggered by death.
  if (deathTriggeredMenu) {
    enemies.length = 0;
    bullets.length = 0;
    pickups.length = 0;
    baitBombs.length = 0;
    player.respawn();
    autoStrikeTime = baseAutoStrikeTime;
  }
  
  timeScale = 1.0;
  document.getElementById("upgradeButton").style.display = "block";
}
    document.getElementById("increaseHP").addEventListener("click", ()=>{
      const cost = 50;
      if(points>=cost){
        points -= cost;
        player.maxHP += 20;
        player.hp += 20;
        document.getElementById("pointsDisplay").textContent = Math.floor(points);
 // Show the HP upgrade alert.
    showUpgradeAlert("HP UP!");
      }
    });
    document.getElementById("increaseAutoRun").addEventListener("click", ()=>{
      const cost = 200;
      if(points>=cost){
        points -= cost;
        baseAutoStrikeTime += 10;
        autoStrikeTime += 10;
        autoStrikeBonus += 5;
        document.getElementById("pointsDisplay").textContent = Math.floor(points);
 // Show the upgrade alert.
   showUpgradeAlert("Autostrike time increased!");
      }
    });
    document.getElementById("increaseDash").addEventListener("click", ()=>{
      const cost = 300;
      if(points>=cost && strikeRangeTiles < tileMap.width){
        points -= cost;
        strikeRangeTiles++;
        document.getElementById("pointsDisplay").textContent = Math.floor(points);
showUpgradeAlert("Strike range increased!");
      }
    });
    document.getElementById("increaseStrikeMeter").addEventListener("click", ()=>{
      const cost = 150;
      if(points>=cost){
        points -= cost;
        strikeMeterCapacity += 10;
        document.getElementById("pointsDisplay").textContent = Math.floor(points);
showUpgradeAlert("Strike Endurance increased!");
      }
    });
    document.getElementById("increaseHealingCharmTime").addEventListener("click", ()=>{
      const cost = 250;
      if(points>=cost){
        points -= cost;
        baseHealingCharmDuration += 2;
        baseHealingCharmHeal += 0.5;
        document.getElementById("pointsDisplay").textContent = Math.floor(points);
showUpgradeAlert("Auto-Heal increased!");
      }
    });
    document.getElementById("increaseShieldingTime").addEventListener("click", ()=>{
      const cost = 250;
      if(points>=cost){
        points -= cost;
        baseDefenseBoostDuration += 2;
        baseShieldDamageReduction = Math.min(baseShieldDamageReduction+0.1,0.9);
        document.getElementById("pointsDisplay").textContent = Math.floor(points);
showUpgradeAlert("Shielding increased!");
      }
    });
    document.getElementById("resumeGame").addEventListener("click", ()=>{ resumeGame(); });
    
    // --- Added Keyboard Controls ---
    document.addEventListener("keydown", function(e) {
      if (isUpgradeMenuVisible || e.repeat) return;
      switch(e.code) {
        case "KeyW":
        case "ArrowUp":
          if(!player.moving && !player.isDashing) player.move("up");
          break;
        case "KeyA":
        case "ArrowLeft":
          if(!player.moving && !player.isDashing) player.move("left");
          break;
        case "KeyS":
        case "ArrowDown":
          if(!player.moving && !player.isDashing) player.move("down");
          break;
        case "KeyD":
        case "ArrowRight":
          if(!player.moving && !player.isDashing) player.move("right");
          break;
        case "Space":
          e.preventDefault();
          if(!player.moving && !player.isDashing) player.strike(player.direction);
          break;
        case "KeyB":
          e.preventDefault();
          if(!player.moving && !player.isDashing) deployBomb();
          break;
        case "KeyM":
          e.preventDefault();
          if(!player.moving && !player.isDashing) executeDashAttack();
          break;
      }
    });
    
    let lastTime = performance.now();
    function gameLoop() {
      let currentTime = performance.now();
      let deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      globalTime += deltaTime;
      if (isPageActive) {
      if(!player.isDead && !isUpgradeMenuVisible){
        player.strikeMeter = Math.max(0, player.strikeMeter - goldDecayRate * deltaTime);
      }
      
      let effectiveDelta = deltaTime * timeScale;
      
      if(!player.isDead && !isUpgradeMenuVisible) { points += effectiveDelta * 10; }
      
      if(defenseBoostActive){
        defenseBoostTimer -= effectiveDelta;
        if(defenseBoostTimer<=0) defenseBoostActive = false;
      }
      if(healingCharmActive){
        healingCharmTimer -= effectiveDelta;
        if(healingCharmTimer<=0) healingCharmActive = false;
        else {
          player.hp = Math.min(player.maxHP, player.hp + baseHealingCharmHeal * effectiveDelta);
        }
      }
      
      if(!isUpgradeMenuVisible){
        player.update(effectiveDelta);
        enemies.forEach(enemy=> enemy.update(effectiveDelta));
        bullets.forEach(bullet=> bullet.update(effectiveDelta));
        updateEffects(effectiveDelta);
        updateMeleeEffects(effectiveDelta);
        updateSwordEffects(effectiveDelta);
        updatePickups();
        updateBaitBombs(effectiveDelta);
        
        bullets.forEach(bullet=>{
          if(bullet.owner==="player"){
            enemies.forEach(enemy=>{
              if(bullet.position.x>=enemy.position.x &&
                 bullet.position.x<=enemy.position.x+enemy.width &&
                 bullet.position.y>=enemy.position.y &&
                 bullet.position.y<=enemy.position.y+enemy.height){
                bullet.alive = false;
                let baseKnock = bullet.velocity.normalize().scale(20);
                enemy.knockback = enemy.knockback.add(baseKnock);
                screenShakeTime = 0.2;
                screenShakeMagnitude = 10;
              }
            });
          } else if(bullet.owner==="enemy"){
            if(bullet.position.x>=player.position.x &&
               bullet.position.x<=player.position.x+player.width &&
               bullet.position.y>=player.position.y &&
               bullet.position.y<=player.position.y+player.height){
              bullet.alive = false;
              let damage = 20;
              if(defenseBoostActive){ damage *= (1 - baseShieldDamageReduction); }
              player.hp -= damage;
              player.flashDamage();
              screenShakeTime = 0.2;
              screenShakeMagnitude = 5;
playerDamage: createAudio("punch3.wav"), 

              if(player.hp<=0 && !player.isDead){updateInventoryDisplay();
playSFX("playerDie");                player.isDead = true;
                spawnBloodEffect(player.position);
                slowMotionTimer = 1.0;
                timeScale = 0.2;
                player.knockback = player.knockback.add(new Vector2(0, -50));
                triggerScreenFlash();
              }
            }
          }
        });
        
        for(let i = bullets.length - 1; i>=0; i--){
          if(!bullets[i].alive) bullets.splice(i,1);
        }
        for(let i = enemies.length - 1; i>=0; i--){
          if(!enemies[i].alive) enemies.splice(i,1);
        }
        
        let dynamicEnemySpawnInterval = Math.max(3.0 - (killCount * 0.05), 0.5);
        enemySpawnTimer += effectiveDelta;
        if(enemySpawnTimer >= dynamicEnemySpawnInterval){
          enemySpawnTimer = 0;
          let gridX, gridY;
          // Spawn enemy on an edge, but ensure the tile is passable
          do {
            let edge = Math.floor(Math.random()*4);
            if(edge===0){ gridX = 0; gridY = Math.floor(Math.random()*tileMap.height); }
            else if(edge===1){ gridX = tileMap.width-1; gridY = Math.floor(Math.random()*tileMap.height); }
            else if(edge===2){ gridY = 0; gridX = Math.floor(Math.random()*tileMap.width); }
            else { gridY = tileMap.height-1; gridX = Math.floor(Math.random()*tileMap.width); }
          } while(!isTilePassable(tileMap.tiles[gridY][gridX]));
          enemies.push(new Enemy(gridX, gridY, tileMap));
        }
        
        pickupSpawnTimer += effectiveDelta;
        if(pickupSpawnTimer >= pickupSpawnInterval){
          pickupSpawnTimer = 0;
          let gridX, gridY;
          // Only spawn pickups on passable tiles
          do {
            gridX = Math.floor(Math.random()*tileMap.width);
            gridY = Math.floor(Math.random()*tileMap.height);
          } while(!isTilePassable(tileMap.tiles[gridY][gridX]));
          let rand = Math.random();
          if(rand < 0.2){ pickups.push(new BombPickup(gridX, gridY, tileMap)); }
          else if(rand < 0.4){ pickups.push(new SwordPickup(gridX, gridY, tileMap)); }
          else if(rand < 0.6){ pickups.push(new HealthPickup(gridX, gridY, tileMap)); }
          else if(rand < 0.8){ pickups.push(new DefenseBoostPickup(gridX, gridY, tileMap)); }
          else { pickups.push(new HealingCharmPickup(gridX, gridY, tileMap)); }
        }
        
        enemies.forEach(enemy=> resolveCollision(player, enemy));
        for(let i=0; i<enemies.length; i++){
          for(let j=i+1; j<enemies.length; j++){
            resolveCollision(enemies[i], enemies[j]);
          }
        }
        
        if(!player.isDead && autoStrikeTime>0){
          autoStrikeTime -= deltaTime;
          autoStrikeTimer -= deltaTime;
          if(autoStrikeTimer<=0){
            autoStrikeTimer = autoStrikeInterval;
            performAutoStrike();
          }
          if(autoStrikeTime<0) autoStrikeTime = 0;
        }
        
      if(player.isDead && !isUpgradeMenuVisible){

  slowMotionTimer -= deltaTime;
  if(slowMotionTimer <= 0){showUpgradeAlert("YOU DIED!");
    showUpgradeMenu(true); // Menu triggered by death.
  }
}
        
        updateCamera();
      }
      }
      ctx.fillStyle = "#505050";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      tileMap.render(ctx, camera);
renderSwordEffects(ctx, camera);
      enemies.forEach(enemy=> enemy.render(ctx, camera));
      pickups.forEach(pickup=> pickup.render(ctx, camera, globalTime));
      baitBombs.forEach(bomb=> bomb.render(ctx, camera, globalTime));
      bullets.forEach(bullet=> bullet.render(ctx, camera));
      renderEffects(ctx, camera);
      renderMeleeEffects(ctx, camera);
      player.render(ctx, camera);
      
      if(screenFlashAlpha>0){
        ctx.fillStyle = "rgba(255,0,0,"+screenFlashAlpha+")";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        screenFlashAlpha -= deltaTime*2;
        if(screenFlashAlpha<0) screenFlashAlpha = 0;
      }
      
      for(let i = spriteFlashes.length - 1; i>=0; i--){
        let flash = spriteFlashes[i];
        let playerBox = {x: player.position.x, y: player.position.y, width: player.width, height: player.height};
        if(flash.position.x >= playerBox.x && flash.position.x <= playerBox.x+playerBox.width &&
           flash.position.y >= playerBox.y && flash.position.y <= playerBox.y+playerBox.height){
          flash.timer -= deltaTime;
          if(flash.timer<=0) spriteFlashes.splice(i,1);
          continue;
        }
        let alpha = flash.timer/flash.duration;
        ctx.fillStyle = "rgba(255,0,0,"+alpha+")";
        let flashScreenPos = camera.worldToScreen(flash.position);
        ctx.beginPath();
        ctx.arc(flashScreenPos.x, flashScreenPos.y, 32, 0, Math.PI*2);
        ctx.fill();
        flash.timer -= deltaTime;
        if(flash.timer<=0) spriteFlashes.splice(i,1);
      }
     
const upgradeButton = document.getElementById("upgradeButton");

// Open upgrade menu on mouse click.
upgradeButton.addEventListener("click", function() {
  if (!isUpgradeMenuVisible) {
    showUpgradeMenu(false);
    upgradeButton.style.display = "none";
  }
});

// Also open upgrade menu when Enter or Return is pressed.
document.addEventListener("keydown", function(e) {
  // Check for Enter key (or keyCode 13 for compatibility)
  if ((e.key === "Enter" || e.keyCode === 13) && !isUpgradeMenuVisible) {
    showUpgradeMenu(false);
    upgradeButton.style.display = "none";
  }
});





      updateExplosivesSlot();
      updateAttackSlot();
      updatePowerupTraySlots();
      updateTrayHUD();
      requestAnimationFrame(gameLoop);
    }
    setInterval(updateAttackSlot, 100);
    requestAnimationFrame(gameLoop);

    
 // Define your playlist
  const playlist = [
    "Baggy.mp3",
    "citiphex_untitled.mp3",
    "frontiers.mp3"
  ];

  let currentTrackIndex = 0;
  const backgroundAudio = new Audio();
  backgroundAudio.src = playlist[currentTrackIndex];
  backgroundAudio.volume = 0.5;
  backgroundAudio.loop = false; // We'll handle looping manually

  backgroundAudio.addEventListener("ended", () => {
    currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
    backgroundAudio.src = playlist[currentTrackIndex];
    backgroundAudio.play().catch(err => console.log("Play error:", err));
  });

  // Attempt to start playing on window load (may be blocked by autoplay policies)
  window.addEventListener("load", () => {
    backgroundAudio.play().catch(err => {
      console.log("Auto-play was prevented. Awaiting user interaction...", err);
    });
  });

  // Ensure music starts when the user clicks anywhere
  window.addEventListener("click", () => {
    if (backgroundAudio.paused) {
      backgroundAudio.play().then(() => {
        console.log("Music started on user click.");
      }).catch(err => {
        console.log("Error starting music on click:", err);
      });
    }
  });
  </script>

</body>
</html>
