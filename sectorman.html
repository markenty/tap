<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- Prevent unwanted zooming -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Platformer: Revamped Gravity, Platforms & Feet</title>
  <style>
    /* --- Reset & Full-Screen Setup --- */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; touch-action: manipulation; }
    body {
      background: #666;
      font-family: sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    /* --- Game Boy Shell --- */
    #gameboy {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #a3c1a3;
      overflow: hidden;
    }
    /* --- Screen --- */
    #screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: calc(100vw * 0.75);
      background: #000;
      border-bottom: 8px solid #444;
      overflow: hidden;
    }
    /* --- Level Container --- */
    #game {
      position: absolute;
      top: 0;
      left: 0;
    }
    /* --- Controls Area --- */
    #controls {
      position: absolute;
      bottom: 5%;
      width: 100vw;
      height: 40vh;
    }
    /* --- D-Pad --- */
    #dpad {
      position: absolute;
      left: 5%;
      bottom: 5%;
      width: 150px;
      height: 150px;
    }
    #dpad button {
      position: absolute;
      background: #333;
      border: 3px solid #777;
      border-radius: 10px;
      cursor: pointer;
      touch-action: manipulation;
      font-size: 0;
    }
    #dpad button:active { background: #777; }
    #dpad .up    { top: 0; left: 45px; width: 60px; height: 60px; }
    #dpad .down  { bottom: 0; left: 45px; width: 60px; height: 60px; }
    #dpad .left  { top: 45px; left: 0; width: 60px; height: 60px; }
    #dpad .right { top: 45px; right: 0; width: 60px; height: 60px; }
    /* --- A/B Buttons --- */
    #ab-buttons {
      position: absolute;
      right: 5%;
      bottom: 5%;
      width: 150px;
      height: 150px;
    }
    #ab-buttons button {
      position: absolute;
      background: #333;
      border: 3px solid #777;
      border-radius: 50%;
      cursor: pointer;
      touch-action: manipulation;
      font-size: 0;
    }
    #ab-buttons button:active { background: #777; }
    /* A is for shooting, B for jumping */
    #ab-buttons .A { width: 70px; height: 70px; top: 0; right: 0; }
    #ab-buttons .B { width: 70px; height: 70px; bottom: 0; left: 0; }
    /* --- In-Game Entities --- */
    .entity {
      position: absolute;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    .player-part { background: #0f0; }
    .bullet { background: #fff; }
    .coin {
      background: gold;
      color: black;
      font-size: 14px;
      line-height: 16px;
      text-align: center;
    }
    .tv {
      position: absolute;
      background: #444;
      border: 2px solid #999;
      border-radius: 4px;
    }
    .platform {
      position: absolute;
      background: #555;
    }
  </style>
</head>
<body>
  <div id="gameboy">
    <div id="screen">
      <div id="game"></div>
    </div>
    <div id="controls">
      <div id="dpad">
        <button class="up"></button>
        <button class="down"></button>
        <button class="left"></button>
        <button class="right"></button>
      </div>
      <div id="ab-buttons">
        <button class="A"></button>
        <button class="B"></button>
      </div>
    </div>
  </div>

  <!-- Matter.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    const { Engine, World, Bodies, Body, Constraint, Composite, Events, Vertices } = Matter;
    const engine = Engine.create();
    // Revamped gravity (a bit lower for platformer feel)
    engine.world.gravity.y = 1.5;
    const world = engine.world;
    const game = document.getElementById("game");

    // Level dimensions
    const levelWidth = 3000;
    const gameHeight = document.getElementById("screen").getBoundingClientRect().height;
    game.style.width = levelWidth + "px";
    game.style.height = gameHeight + "px";

    let domEntities = [], platforms = [], tvs = [], coins = [], bullets = [];

    function createDomElement(body, cls, w, h) {
      const el = document.createElement("div");
      el.className = "entity " + cls;
      el.style.width = w + "px";
      el.style.height = h + "px";
      game.appendChild(el);
      body.domElement = el;
      domEntities.push(body);
    }

    // --- Main World Boundaries (ground walls) ---
    // (These are destructible as before.)
    const groundBoundary = Bodies.rectangle(levelWidth/2, gameHeight, levelWidth, 40, { isStatic: true });
    const leftWall = Bodies.rectangle(0, gameHeight/2, 40, gameHeight, { isStatic: true });
    const rightWall = Bodies.rectangle(levelWidth, gameHeight/2, 40, gameHeight, { isStatic: true });
    World.add(world, [groundBoundary, leftWall, rightWall]);

    // --- Build Main Platform with Pitfalls ---
    // The main platform is built along the bottom (y = gameHeight - 40) using segments.
    const mainPlatformY = gameHeight - 40;
    let xPos = 0;
    while (xPos < levelWidth) {
      // Random segment width between 200 and 500 pixels
      const segmentWidth = 200 + Math.random()*300;
      // Random gap width between 50 and 150 pixels
      const gapWidth = 50 + Math.random()*100;
      // Create platform segment if it fits (clamp to levelWidth)
      if (xPos + segmentWidth > levelWidth) break;
      const plat = Bodies.rectangle(xPos + segmentWidth/2, mainPlatformY, segmentWidth, 20, { isStatic: true });
      World.add(world, plat);
      const el = document.createElement("div");
      el.className = "platform";
      el.style.width = segmentWidth + "px";
      el.style.height = "20px";
      el.style.left = (xPos) + "px";
      el.style.top = (mainPlatformY - 10) + "px";
      game.appendChild(el);
      plat.domElement = el;
      platforms.push(plat);
      // Advance xPos: segment then gap
      xPos += segmentWidth + gapWidth;
    }
    // Optional: add a few extra random platforms higher up
    for (let i = 0; i < 8; i++) {
      const w = 100 + Math.random()*100,
            h = 20,
            x = 100 + Math.random()*(levelWidth-200),
            y = 100 + Math.random()*(gameHeight - 200);
      const plat = Bodies.rectangle(x, y, w, h, { isStatic: true });
      World.add(world, plat);
      const el = document.createElement("div");
      el.className = "platform";
      el.style.width = w + "px";
      el.style.height = h + "px";
      el.style.left = (x - w/2) + "px";
      el.style.top = (y - h/2) + "px";
      game.appendChild(el);
      plat.domElement = el;
      platforms.push(plat);
    }

    // --- Utility: Create Half-Circle Foot ---
    // This function returns a Matter body created from vertices approximating a half circle.
    // The shape is defined so that its flat edge is at the bottom.
    function createHalfCircleFoot(x, y, radius) {
      const numPoints = 12;
      let verts = [];
      // Start with the left flat corner
      verts.push({ x: -radius, y: 0 });
      // Generate arc points from angle PI to 0.
      for (let i = 0; i <= numPoints; i++) {
        const angle = Math.PI - (Math.PI * i / numPoints);
        verts.push({ x: radius * Math.cos(angle), y: radius * Math.sin(angle) });
      }
      // Create a body from the vertices.
      // Note: Matter.Bodies.fromVertices centers the body at the computed centroid.
      const foot = Bodies.fromVertices(x, y, [verts], {
        friction: 0.8,
        frictionAir: 0.01,
        restitution: 0,
        render: { fillStyle: "#0f0" }
      }, true);
      return foot;
    }

    // --- Player Setup with Composite Parts ---
    // The player is built with a head, torso, arms and legs.
    // Feet are created using the half-circle shape.
    const player = { jumpCount: 0, facingDirection: 1, isGrounded: false, wallSide: 0 };
    let lastGroundedTime = 0, jumpBufferTimer = 0.5;
    const coyoteTime = 100, jumpBufferTime = 150;
    let jumpKeyActive = false;
    (function createPlayer(x, y) {
      const size = 20;
      // Increase torso air friction for damping.
      const torsoOptions = { friction: 1.0, frictionAir: 0.1, restitution: 0 };
      const defaultOptions = { friction: 0.5, frictionAir: 0.01, restitution: 0 };

      // Head
      const head = Bodies.circle(x, y - 40, size/2, defaultOptions);
      createDomElement(head, "player-part", size, size);
      // Torso
      const torso = Bodies.circle(x, y - 20, size, torsoOptions);
      createDomElement(torso, "player-part", size*2, size*2);

      // Right Arm
      const rightUpperArm = Bodies.circle(x + 30, y - 20, size/2, defaultOptions);
      createDomElement(rightUpperArm, "player-part", size, size);
      const rightHand = Bodies.circle(x + 30, y - 20 + 20, size/2, defaultOptions);
      createDomElement(rightHand, "player-part", size, size);

      // Left Arm
      const leftUpperArm = Bodies.circle(x - 30, y - 20, size/2, defaultOptions);
      createDomElement(leftUpperArm, "player-part", size, size);
      const leftHand = Bodies.circle(x - 30, y - 20 + 20, size/2, defaultOptions);
      createDomElement(leftHand, "player-part", size, size);

      // Right Leg (upper leg remains circular)
      const rightUpperLeg = Bodies.circle(x + 10, y + 10, size/2, defaultOptions);
      createDomElement(rightUpperLeg, "player-part", size, size);
      // Replace right foot with a half-circle foot.
      const rightFoot = createHalfCircleFoot(x + 10, y + 10 + 20, size/2);
      createDomElement(rightFoot, "player-part", size, size);
      
      // Left Leg
      const leftUpperLeg = Bodies.circle(x - 10, y + 10, size/2, defaultOptions);
      createDomElement(leftUpperLeg, "player-part", size, size);
      const leftFoot = createHalfCircleFoot(x - 10, y + 10 + 20, size/2);
      createDomElement(leftFoot, "player-part", size, size);

      World.add(world, [head, torso, rightUpperArm, rightHand, leftUpperArm, leftHand, rightUpperLeg, rightFoot, leftUpperLeg, leftFoot]);

      // Link body parts using constraints.
      function link(a, b, offA, offB) {
        const con = Constraint.create({
          bodyA: a,
          pointA: offA,
          bodyB: b,
          pointB: offB,
          stiffness: 1,
          length: 0.1
        });
        World.add(world, con);
      }
      link(head, torso, { x: 0, y: size/2 }, { x: 0, y: -size });
      link(torso, rightUpperArm, { x: size, y: 0 }, { x: 0, y: 0 });
      link(rightUpperArm, rightHand, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, leftUpperArm, { x: -size, y: 0 }, { x: 0, y: 0 });
      link(leftUpperArm, leftHand, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, rightUpperLeg, { x: 10, y: size }, { x: 0, y: -size/2 });
      link(rightUpperLeg, rightFoot, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, leftUpperLeg, { x: -10, y: size }, { x: 0, y: -size/2 });
      link(leftUpperLeg, leftFoot, { x: 0, y: 0 }, { x: 0, y: -20 });

      player.head = head;
      player.torso = torso;
      player.rightUpperArm = rightUpperArm;
      player.rightHand = rightHand;
      player.leftUpperArm = leftUpperArm;
      player.leftHand = leftHand;
      player.rightUpperLeg = rightUpperLeg;
      player.rightFoot = rightFoot;
      player.leftUpperLeg = leftUpperLeg;
      player.leftFoot = leftFoot;
    })(100, 100);

    // --- Additional Platforms (e.g. TVs, coins) remain unchanged ---
    function createTV(x, y) {
      const tvW = 60, tvH = 40;
      const tv = Bodies.rectangle(x, y, tvW, tvH, { isStatic: true, label: "tv" });
      World.add(world, tv);
      const el = document.createElement("div");
      el.className = "tv";
      el.style.width  = tvW + "px";
      el.style.height = tvH + "px";
      el.style.left   = (x - tvW/2) + "px";
      el.style.top    = (y - tvH/2) + "px";
      game.appendChild(el);
      tv.domElement = el;
      tvs.push(tv);
    }
    for (let i = 0; i < 5; i++) {
      const x = 150 + Math.random()*500;
      const y = 50 + Math.random()*400;
      createTV(x, y);
    }

    function breakTV(tv) {
      World.remove(world, tv);
      if (tv.domElement && tv.domElement.parentNode) {
        tv.domElement.parentNode.removeChild(tv.domElement);
      }
      const index = tvs.indexOf(tv);
      if (index !== -1) { tvs.splice(index, 1); }
      const coinCount = 5;
      for (let i = 0; i < coinCount; i++) {
        const coin = Bodies.circle(tv.position.x, tv.position.y, 10, {
          restitution: 0.8,
          friction: 0.5,
          label: "coin"
        });
        World.add(world, coin);
        createDomElement(coin, "coin", 20, 20);
        coins.push(coin);
        const forceMagnitude = 0.05;
        Body.applyForce(coin, coin.position, {
          x: (Math.random()-0.5)*forceMagnitude,
          y: -Math.random()*forceMagnitude
        });
      }
    }

    // --- Existing Collision for TVs & Bullets ---
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        if ((pair.bodyA.label === "tv" && pair.bodyB.label === "bullet") ||
            (pair.bodyB.label === "tv" && pair.bodyA.label === "bullet")) {
          const tvBody = pair.bodyA.label === "tv" ? pair.bodyA : pair.bodyB;
          breakTV(tvBody);
        }
      });
    });

    // --- Destructible World (unchanged from earlier) ---
    const destructionSpeedThreshold = 20;
    function isPlayerPart(body) {
      return body === player.head || body === player.torso ||
             body === player.rightUpperArm || body === player.rightHand ||
             body === player.leftUpperArm || body === player.leftHand ||
             body === player.rightUpperLeg || body === player.rightFoot ||
             body === player.leftUpperLeg || body === player.leftFoot;
    }
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        let playerPart = null, other = null;
        if (isPlayerPart(pair.bodyA) && pair.bodyB.isStatic) {
          playerPart = pair.bodyA;
          other = pair.bodyB;
        } else if (isPlayerPart(pair.bodyB) && pair.bodyA.isStatic) {
          playerPart = pair.bodyB;
          other = pair.bodyA;
        }
        if (other) {
          const vx = player.torso.velocity.x, vy = player.torso.velocity.y;
          const playerSpeed = Math.hypot(vx, vy);
          if (playerSpeed >= destructionSpeedThreshold) {
            World.remove(world, other);
            if (other.domElement && other.domElement.parentNode) {
              other.domElement.parentNode.removeChild(other.domElement);
            }
            const platIndex = platforms.indexOf(other);
            if (platIndex !== -1) platforms.splice(platIndex, 1);
            const tvIndex = tvs.indexOf(other);
            if (tvIndex !== -1) tvs.splice(tvIndex, 1);
          }
        }
      });
    });

    // --- Shooting Mechanic ---
    function shoot() {
      let dx = 0, dy = 0;
      if (keys["ArrowUp"])    dy = -1;
      if (keys["ArrowDown"])  dy =  1;
      if (keys["ArrowLeft"])  dx = -1;
      if (keys["ArrowRight"]) dx =  1;
      if (dx === 0 && dy === 0) dx = player.facingDirection;
      const mag = Math.hypot(dx, dy);
      dx /= mag; dy /= mag;
      let origin;
      if (player.facingDirection > 0) {
        Body.setPosition(player.rightHand, { x: player.rightUpperArm.position.x + 20, y: player.rightUpperArm.position.y });
        origin = { x: player.rightHand.position.x, y: player.rightHand.position.y };
      } else {
        Body.setPosition(player.leftHand, { x: player.leftUpperArm.position.x - 20, y: player.leftUpperArm.position.y });
        origin = { x: player.leftHand.position.x, y: player.leftHand.position.y };
      }
      shootBullet(origin.x, origin.y, origin.x + dx*100, origin.y + dy*100);
    }
    function shootBullet(x, y, tx, ty) {
      const bullet = Bodies.circle(x, y, 5, { friction: 0, frictionAir: 0.01, label: "bullet" });
      const angle = Math.atan2(ty - y, tx - x);
      const speed = 35;
      Body.setVelocity(bullet, { x: Math.cos(angle)*speed, y: Math.sin(angle)*speed });
      World.add(world, bullet);
      createDomElement(bullet, "bullet", 10, 10);
      bullets.push(bullet);
    }

    // --- Collision Handling for Grounding ---
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        [player.leftFoot, player.rightFoot,
         player.leftUpperLeg, player.rightUpperLeg,
         player.leftHand, player.rightHand].forEach(part => {
          if (pair.bodyA === part || pair.bodyB === part) {
            if (pair.bodyA.isStatic || pair.bodyB.isStatic) {
              player.isGrounded = true;
              lastGroundedTime = Date.now();
              player.jumpCount = 0;
            }
          }
        });
        if (pair.bodyA === leftWall || pair.bodyB === leftWall) { player.wallSide = -1; }
        if (pair.bodyA === rightWall || pair.bodyB === rightWall) { player.wallSide = 1; }
      });
    });
    Events.on(engine, "collisionEnd", function(event) {
      event.pairs.forEach(pair => {
        if (pair.bodyA === player.leftFoot || pair.bodyB === player.leftFoot ||
            pair.bodyA === player.rightFoot || pair.bodyB === player.rightFoot) {
          player.isGrounded = false;
        }
        if (pair.bodyA === leftWall || pair.bodyB === leftWall ||
            pair.bodyA === rightWall || pair.bodyB === rightWall) {
          player.wallSide = 0;
        }
      });
    });

    // --- Input State ---
    let keys = {};
    window.addEventListener("keydown", (e) => { keys[e.code] = true; });
    window.addEventListener("keyup", (e) => { keys[e.code] = false; });

    // --- Smooth Dynamic Camera ---
    function updateCamera() {
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      const vx = player.torso.velocity.x;
      const vy = player.torso.velocity.y;
      const speed = Math.hypot(vx, vy);
      const zoomIn = 1.2;
      const zoomOut = 0.8;
      const maxSpeed = 20;
      const t = Math.min(speed / maxSpeed, 1);
      const zoom = zoomIn*(1-t) + zoomOut*t;
      const visibleWidth = screenWidth/zoom;
      const visibleHeight = screenHeight/zoom;
      let cameraCenterX = player.torso.position.x;
      let cameraCenterY = player.torso.position.y;
      const offsetX = Math.max(0, Math.min(cameraCenterX - visibleWidth/2, levelWidth - visibleWidth));
      const offsetY = Math.max(0, cameraCenterY - visibleHeight/2);
      game.style.transformOrigin = "top left";
      game.style.transform = `scale(${zoom}) translate(-${offsetX}px, -${offsetY}px)`;
    }

    // --- Snap Feet When Grounded ---
    // When the player is grounded (and not in mid-air jump), force the feet to be at fixed offsets relative to the torso.
    function snapFeet() {
      if (player.isGrounded) {
        const torsoPos = player.torso.position;
        // Offsets for left and right feet relative to the torso.
        const leftOffset = { x: -10, y: 20 };
        const rightOffset = { x: 10, y: 20 };
        Body.setPosition(player.leftFoot, { x: torsoPos.x + leftOffset.x, y: torsoPos.y + leftOffset.y });
        Body.setPosition(player.rightFoot, { x: torsoPos.x + rightOffset.x, y: torsoPos.y + rightOffset.y });
        // Also align velocities so they move in unison.
        Body.setVelocity(player.leftFoot, player.torso.velocity);
        Body.setVelocity(player.rightFoot, player.torso.velocity);
        // Optionally reset angles for stability.
        Body.setAngle(player.leftFoot, 0);
        Body.setAngle(player.rightFoot, 0);
      }
    }

    // --- Main Game Loop ---
    function update() {
      Engine.update(engine, 1000/60);
      domEntities.forEach(body => {
        if (body.domElement) {
          body.domElement.style.left = body.position.x + "px";
          body.domElement.style.top = body.position.y + "px";
          body.domElement.style.transform = "translate(-50%, -50%) rotate(" + body.angle + "rad)";
        }
      });

      if (keys["ArrowLeft"]) {
        player.facingDirection = -1;
        Body.applyForce(player.torso, player.torso.position, { x: -0.01, y: 0 });
      }
      if (keys["ArrowRight"]) {
        player.facingDirection = 1;
        Body.applyForce(player.torso, player.torso.position, { x: 0.01, y: 0 });
      }
      if (!keys["ArrowLeft"] && !keys["ArrowRight"]) {
        Body.setVelocity(player.torso, { x: player.torso.velocity.x*0.98, y: player.torso.velocity.y });
      }

      if (keys["KeyB"] || keys["Space"]) {
        if (!jumpKeyActive) {
          jumpBufferTimer = Date.now();
          jumpKeyActive = true;
        }
      } else {
        jumpKeyActive = false;
        if (player.torso.velocity.y < -3) {
          Body.setVelocity(player.torso, { x: player.torso.velocity.x, y: -3 });
        }
      }
      if ((Date.now()-jumpBufferTimer) < jumpBufferTime ||
          (Date.now()-lastGroundedTime) < coyoteTime) {
        if ((keys["KeyB"] || keys["Space"]) && player.jumpCount < 2) {
          if (player.wallSide !== 0) {
            Body.setVelocity(player.torso, { x: player.torso.velocity.x + 5 * -player.wallSide, y: -22 });
          } else {
            Body.setVelocity(player.torso, { x: player.torso.velocity.x, y: -22 });
          }
          player.jumpCount++;
          jumpBufferTimer = 0;
        }
      }

      const correctionFactor = 1.8;
      const angularCorrection = -player.torso.angle*correctionFactor;
      const damping = 0.9;
      Body.setAngularVelocity(player.torso, (player.torso.angularVelocity+angularCorrection)*damping);

      if (player.wallSide !== 0 && player.torso.velocity.y > 3) {
        Body.setVelocity(player.torso, { x: player.torso.velocity.x, y: 3 });
      }

      // Keep head aligned with torso.
      Body.setPosition(player.head, { x: player.torso.position.x, y: player.torso.position.y - 40 });
      Body.setVelocity(player.head, player.torso.velocity);

      // Update camera, then snap feet if grounded.
      updateCamera();
      snapFeet();
      requestAnimationFrame(update);
    }
    update();

    // --- Touch & Button Mappings ---
    const dpad = document.getElementById("dpad");
    dpad.querySelector(".up").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowUp"] = true; });
    dpad.querySelector(".up").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowUp"] = false; });
    dpad.querySelector(".down").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowDown"] = true; });
    dpad.querySelector(".down").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowDown"] = false; });
    dpad.querySelector(".left").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowLeft"] = true; });
    dpad.querySelector(".left").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowLeft"] = false; });
    dpad.querySelector(".right").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowRight"] = true; });
    dpad.querySelector(".right").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowRight"] = false; });
    const abButtons = document.getElementById("ab-buttons");
    abButtons.querySelector(".A").addEventListener("touchstart", (e) => { e.preventDefault(); shoot(); });
    abButtons.querySelector(".B").addEventListener("touchstart", (e) => { e.preventDefault(); keys["Space"] = true; });
    abButtons.querySelector(".B").addEventListener("touchend", (e) => { e.preventDefault(); keys["Space"] = false; });
  </script>
</body>
</html>
