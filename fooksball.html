<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Responsive Top-Down Football</title>
  <style>
    /* Remove any fixed height/width rules from the canvas so we can set them via JS */
    html, body {
      margin: 0; 
      padding: 0; 
      width: 100%;
      height: 100%;
      background: #006400; 
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    /* Canvas is absolutely positioned; JS will resize it dynamically */
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      border: 2px solid #fff;
      background-color: #007f0e;
      box-sizing: border-box;
      display: block;
    }

    /* Simple overlay for scoreboard & controls */
    #uiOverlay {
      position: absolute;
      top: 0; 
      left: 0; 
      right: 0;
      z-index: 9999;
      text-align: center;
      pointer-events: none; /* let clicks pass through except on children */
    }
    #scoreboard, #controls {
      display: inline-block;
      background: rgba(0,0,0,0.5);
      color: #fff;
      padding: 6px 12px;
      margin: 5px;
      border-radius: 8px;
      pointer-events: auto; /* allow clicks on these elements */
    }
    button {
      margin: 0 5px;
      font-size: 16px;
      cursor: pointer;
    }
    #scoreboard span {
      margin: 0 10px;
      font-weight: bold;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="uiOverlay">
  <div id="scoreboard">
    <span id="offenseScore">Offense: 0</span>
    <span id="defenseScore">Defense: 0</span>
    <span id="quarter">Q1</span>
    <span id="gameClock">15:00</span>
    <span id="downDistance">1 &amp; 10</span>
  </div>
  <br>
  <div id="controls">
    <button id="playRun" style="display:none;">Run Play</button>
    <button id="playPass" style="display:none;">Pass Play</button>
  </div>
</div>

<script>
/*
  Responsive version:
  - A "resizeCanvas()" function adjusts canvas width/height on load and resize,
    keeping the field's aspect ratio (~ 530 wide : 1200 tall) but filling
    as much of the window as possible.
  - All field coordinates remain 530 x 1200 in "game logic", so we only
    transform them to screen coordinates for drawing.
*/

/** Field dimensions in "game logic" coords **/
const FIELD_WIDTH = 530;
const FIELD_HEIGHT = 1200;

/** Retrieve canvas & context **/
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

/** Dynamically resize the canvas to fill available space while preserving the 530:1200 ratio **/
function resizeCanvas() {
  const desiredAspect = FIELD_WIDTH / FIELD_HEIGHT; // ~0.4417
  const winWidth = window.innerWidth;
  const winHeight = window.innerHeight;
  const windowAspect = winWidth / winHeight;

  // If the window is relatively wider than the field aspect, height is the limiting factor.
  // Otherwise, width is the limiting factor.
  if (windowAspect > desiredAspect) {
    // Window is wider: match height fully, scale width.
    canvas.height = winHeight;
    canvas.width  = Math.floor(winHeight * desiredAspect);
  } else {
    // Window is taller/narrower: match width fully, scale height.
    canvas.width  = winWidth;
    canvas.height = Math.floor(winWidth / desiredAspect);
  }
  // Re-draw or re-position if needed
  draw(); 
}
window.addEventListener("resize", resizeCanvas);

/** === GAME STATE === **/
let gameState = {
  phase: "pre-snap",   // "pre-snap", "play", "post-play"
  quarter: 1,
  totalQuarters: 4,
  clock: 15 * 60,      // 15:00 in seconds
  offenseScore: 0,
  defenseScore: 0,
  down: 1,
  yardsToFirstDown: 10,

  // Start line of scrimmage somewhere in the lower half
  lineOfScrimmage: 800,
  firstDownMarker: 700, // ~ 10 yards up from LOS
  lastTime: 0,
  playType: null, // "run" or "pass"
};

/** BALL OBJECT **/
let ball = {
  x: 0,
  y: 0,
  possessor: null,
  inFlight: false,
  vx: 0,
  vy: 0,
  update(dt) {
    if (this.possessor) {
      this.x = this.possessor.x;
      this.y = this.possessor.y;
    } else if (this.inFlight) {
      this.x += this.vx * dt;
      this.y += this.vy * dt;
    }
  }
};

/** PLAYER CLASS **/
class Player {
  constructor({ x, y, role, number, team }) {
    this.x = x;
    this.y = y;
    this.role = role;
    this.number = number;
    this.team = team; // "offense" or "defense"

    // Speed in px/sec
    this.speed = 80;
    if (this.role === "WR") this.speed = 100;
    if (this.role === "OL" || this.role==="DL") this.speed = 60;
    if (this.role === "LB") this.speed = 75;
    if (this.role === "CB" || this.role==="S") this.speed = 90;

    this.target = null;   // For run/ user taps
    this.routeFn = null;  // For pass routes
    this.routeTime = 0;
  }

  update(dt) {
    if (gameState.phase !== "play") return;
    if (this.team === "offense") {
      if (ball.possessor === this) {
        // I'm the ball carrier
        if (this.target) {
          moveToward(this, this.target.x, this.target.y, this.speed, dt);
          if (dist(this.x, this.y, this.target.x, this.target.y) < 10) {
            this.target = null;
          }
        } else {
          // Move upfield
          moveToward(this, this.x, 0, this.speed, dt);
        }
      } else if (gameState.playType === "pass" && (this.role === "WR" || this.role==="TE")) {
        // I'm a receiver on a pass route
        if (this.routeFn) {
          this.routeTime += dt;
          const desiredPos = this.routeFn(this, this.routeTime);
          if (desiredPos) {
            moveToward(this, desiredPos.x, desiredPos.y, this.speed, dt);
          }
        }
      }
    } else {
      // Defense
      if (ball.possessor && ball.possessor.team==="offense") {
        let bc = ball.possessor;
        moveToward(this, bc.x, bc.y, this.speed, dt);
      }
    }
  }

  draw(ctx) {
    const scale = getScale();
    const sx = this.x * scale.sx;
    const sy = this.y * scale.sy;

    ctx.beginPath();
    ctx.arc(sx, sy, 12, 0, 2*Math.PI);
    ctx.fillStyle = (this.team==="offense") ? "blue" : "red";
    ctx.fill();
    ctx.strokeStyle = "#fff";
    ctx.stroke();
    ctx.closePath();

    ctx.fillStyle = "#fff";
    ctx.font = "14px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(this.number, sx, sy);
  }
}

/** Utility for moving an object toward target coords at given speed */
function moveToward(obj, tx, ty, speed, dt) {
  let dx = tx - obj.x;
  let dy = ty - obj.y;
  let distVal = Math.sqrt(dx*dx + dy*dy);
  if (distVal < 1) return;
  let step = speed * dt;
  if (step > distVal) step = distVal;
  let nx = dx / distVal;
  let ny = dy / distVal;
  obj.x += nx * step;
  obj.y += ny * step;
}

/** Dist helper */
function dist(ax, ay, bx, by) {
  let dx = bx - ax;
  let dy = by - ay;
  return Math.sqrt(dx*dx + dy*dy);
}

/** We'll store all players here. */
let players = [];

/** I-Formation Offense, 4-3 Defense */
function initFormation() {
  players = [];
  const los = gameState.lineOfScrimmage;
  const midX = FIELD_WIDTH/2;

  // Offense: I-Formation
  // 5 OL
  const OLxStart = midX - 2*30;
  for (let i=0; i<5; i++){
    players.push(new Player({
      x: OLxStart + i*30,
      y: los + 10,
      role: "OL",
      number: 70 + i,
      team: "offense"
    }));
  }
  // First OL is the center (snapper)
  players[0].role = "Snapper";

  // QB behind center
  players.push(new Player({
    x: midX,
    y: los + 60,
    role: "QB",
    number: 12,
    team: "offense"
  }));
  // FB
  players.push(new Player({
    x: midX,
    y: los + 100,
    role: "FB",
    number: 44,
    team: "offense"
  }));
  // RB
  players.push(new Player({
    x: midX,
    y: los + 140,
    role: "RB",
    number: 22,
    team: "offense"
  }));
  // TE (right)
  players.push(new Player({
    x: midX + 80,
    y: los + 10,
    role: "TE",
    number: 87,
    team: "offense"
  }));
  // WR left
  players.push(new Player({
    x: midX - 150,
    y: los,
    role: "WR",
    number: 80,
    team: "offense"
  }));
  // WR right
  players.push(new Player({
    x: midX + 150,
    y: los,
    role: "WR",
    number: 82,
    team: "offense"
  }));

  // Defense (4-3)
  const dLineY = los - 30;
  const dLineXStart = midX - 1.5*30;
  for (let i=0; i<4; i++){
    players.push(new Player({
      x: dLineXStart + i*30,
      y: dLineY,
      role: "DL",
      number: 90 + i,
      team: "defense"
    }));
  }
  // LBs
  const lbY = los - 70;
  const lbXStart = midX - 30;
  for (let i=0; i<3; i++){
    players.push(new Player({
      x: lbXStart + i*30,
      y: lbY,
      role: "LB",
      number: 50 + i,
      team: "defense"
    }));
  }
  // DBs
  const dbY = los - 130;
  players.push(new Player({ x: midX-180, y: dbY, role:"CB", number:20, team:"defense" }));
  players.push(new Player({ x: midX+180, y: dbY, role:"CB", number:21, team:"defense" }));
  players.push(new Player({ x: midX-50,  y: dbY-40, role:"S", number:30, team:"defense" }));
  players.push(new Player({ x: midX+50,  y: dbY-40, role:"S", number:31, team:"defense" }));

  // Ball starts with QB
  let qb = players.find(p => p.role==="QB");
  ball.possessor = qb;
  ball.x = qb.x;
  ball.y = qb.y;
  ball.inFlight = false;
  ball.vx = 0;
  ball.vy = 0;
}

/** Basic pass routes */
function slantLeft(p, t) {
  let sx = p.x0;
  let sy = p.y0;
  // up ~60 px/sec, left ~20 px/sec
  return { x: sx - 20*t, y: sy - 60*t };
}
function slantRight(p, t) {
  let sx = p.x0;
  let sy = p.y0;
  return { x: sx + 20*t, y: sy - 60*t };
}
function goRoute(p, t) {
  // just straight up ~80 px/sec
  let sx = p.x0;
  let sy = p.y0;
  return { x: sx, y: sy - 80*t };
}
function assignPassRoutes() {
  players.forEach(p => {
    if (p.team==="offense" && (p.role==="WR"||p.role==="TE")) {
      p.x0 = p.x; 
      p.y0 = p.y;
      let routeFuncs = [slantLeft, slantRight, goRoute];
      p.routeFn = routeFuncs[Math.floor(Math.random()*routeFuncs.length)];
      p.routeTime = 0;
    }
  });
}

/** Play selection buttons **/
const btnRun = document.getElementById("playRun");
const btnPass = document.getElementById("playPass");
function showPlayButtons(show) {
  btnRun.style.display = show ? "inline-block" : "none";
  btnPass.style.display = show ? "inline-block" : "none";
}
btnRun.addEventListener("click", () => {
  gameState.playType = "run";
  showPlayButtons(false);
});
btnPass.addEventListener("click", () => {
  gameState.playType = "pass";
  showPlayButtons(false);
  assignPassRoutes();
});

/** Snap the ball by tapping the center in pre-snap **/
function startPlay() {
  gameState.phase = "play";
}

/** The main loop with requestAnimationFrame **/
function gameLoop(timestamp) {
  if (!gameState.lastTime) gameState.lastTime = timestamp;
  let dt = (timestamp - gameState.lastTime)/1000;
  gameState.lastTime = timestamp;

  // Update clock if in play
  if (gameState.phase==="play") {
    gameState.clock -= dt;
    if (gameState.clock<0) {
      gameState.clock=0;
      endQuarterOrGame();
    }
  }

  // Update players & ball
  players.forEach(pl => pl.update(dt));
  ball.update(dt);

  // Check tackle & TD
  if (ball.possessor && ball.possessor.team==="offense") {
    checkTackles();
    checkTouchdown();
  }

  draw();
  requestAnimationFrame(gameLoop);
}

/** Tackle check **/
function checkTackles() {
  let bc = ball.possessor;
  players.forEach(d => {
    if (d.team==="defense") {
      if (dist(d.x, d.y, bc.x, bc.y)<18) {
        endPlay("tackle");
      }
    }
  });
}

/** Touchdown check **/
function checkTouchdown() {
  let bc = ball.possessor;
  if (bc.y<100) {
    gameState.offenseScore += 6;
    endPlay("touchdown");
  }
}

/** End quarter or game if clock hits 0 **/
function endQuarterOrGame() {
  if (gameState.quarter<gameState.totalQuarters) {
    gameState.quarter++;
    gameState.clock = 15*60;
  } else {
    // game over scenario
    gameState.clock=0;
  }
}

/** End the play **/
function endPlay(reason) {
  gameState.phase="post-play";
  if (reason==="tackle") {
    useDown();
  }
  setTimeout(()=>{
    prepareNextPlay();
  }, 1500);
}

/** Down logic **/
function useDown() {
  gameState.down++;
  if (gameState.down>4) {
    // turnover
    swapPossession();
  }
}

/** Swap possession **/
function swapPossession() {
  players.forEach(p => {
    p.team = (p.team==="offense") ? "defense":"offense";
  });
  gameState.down=1;
  gameState.yardsToFirstDown=10;
  gameState.lineOfScrimmage=800;
  gameState.firstDownMarker=700;
  initFormation();
}

/** Prepare next play **/
function prepareNextPlay() {
  gameState.phase="pre-snap";
  showPlayButtons(true);
  initFormation();
}

/** DRAW **/
function draw() {
  ctx.clearRect(0,0, canvas.width, canvas.height);
  drawField();
  players.forEach(p => p.draw(ctx));
  drawBall();
  updateScoreboard();
}

/** Draw field & yard lines **/
function drawField() {
  ctx.save();
  const scale = getScale();

  // entire background
  ctx.fillStyle = "#007f0e";
  ctx.fillRect(0,0, canvas.width, canvas.height);

  // end zones
  ctx.fillStyle = "blue";
  ctx.fillRect(0, 0, canvas.width, 100*scale.sy);
  ctx.fillStyle = "red";
  ctx.fillRect(0, 1100*scale.sy, canvas.width, 100*scale.sy);

  // yard lines every 100 px from y=100..1100
  ctx.strokeStyle="#fff";
  ctx.lineWidth=2;
  for (let y=100; y<=1100; y+=100) {
    ctx.beginPath();
    ctx.moveTo(0, y*scale.sy);
    ctx.lineTo(canvas.width, y*scale.sy);
    ctx.stroke();
  }

  // line of scrimmage
  ctx.strokeStyle="#fff";
  ctx.beginPath();
  ctx.moveTo(0, gameState.lineOfScrimmage*scale.sy);
  ctx.lineTo(canvas.width, gameState.lineOfScrimmage*scale.sy);
  ctx.stroke();

  // first down
  ctx.strokeStyle="yellow";
  ctx.beginPath();
  ctx.moveTo(0, gameState.firstDownMarker*scale.sy);
  ctx.lineTo(canvas.width, gameState.firstDownMarker*scale.sy);
  ctx.stroke();

  ctx.restore();
}

/** Draw Ball (Football Emoji) **/
function drawBall() {
  ctx.save();
  let scale = getScale();
  let sx = ball.x * scale.sx;
  let sy = ball.y * scale.sy;
  ctx.font = "24px serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("🏈", sx, sy);
  ctx.restore();
}

/** Scoreboard updates **/
function updateScoreboard() {
  document.getElementById("offenseScore").innerText = "Offense: " + gameState.offenseScore;
  document.getElementById("defenseScore").innerText = "Defense: " + gameState.defenseScore;
  document.getElementById("quarter").innerText = "Q" + gameState.quarter;
  let mm = Math.floor(gameState.clock/60);
  let ss = Math.floor(gameState.clock%60);
  let clockStr = mm + ":" + (ss<10 ? "0"+ss : ss);
  document.getElementById("gameClock").innerText = clockStr;
  document.getElementById("downDistance").innerText = gameState.down + " & " + gameState.yardsToFirstDown;
}

/** Convert FIELD coords => canvas coords scaling */
function getScale() {
  // The canvas' width corresponds to FIELD_WIDTH in logic coords,
  // The canvas' height corresponds to FIELD_HEIGHT in logic coords.
  return {
    sx: canvas.width / FIELD_WIDTH,
    sy: canvas.height / FIELD_HEIGHT
  };
}

/** MOUSE/TAP INPUT **/
canvas.addEventListener("click", (evt) => {
  let rect = canvas.getBoundingClientRect();
  let mx = evt.clientX - rect.left;
  let my = evt.clientY - rect.top;
  let s = getScale();
  let fx = mx / s.sx;
  let fy = my / s.sy;

  let clickedPlayer = findPlayerAt(fx, fy);
  if (clickedPlayer) {
    handlePlayerClick(clickedPlayer);
  } else {
    // If run play is live, user can direct the ball carrier
    if (gameState.phase==="play" && gameState.playType==="run") {
      let bc = ball.possessor;
      if (bc && bc.team==="offense") {
        bc.target = { x: fx, y: fy };
      }
    }
  }
});
function findPlayerAt(x, y) {
  for (let p of players) {
    if (dist(p.x, p.y, x, y) < 15) return p;
  }
  return null;
}

function handlePlayerClick(p) {
  if (gameState.phase==="pre-snap") {
    // Snap the ball
    if (p.role==="Snapper" && p.team==="offense") {
      startPlay();
    }
  } else if (gameState.phase==="play") {
    // If pass play, tapping WR/TE => pass
    if (gameState.playType==="pass" && p.team==="offense" && (p.role==="WR"||p.role==="TE")) {
      attemptPass(p);
    }
  }
}

/** Throw pass from QB to target p **/
function attemptPass(target) {
  let qb = players.find(x => x.role==="QB" && x.team==="offense");
  if (!qb || ball.possessor!==qb) return;
  // Launch pass
  ball.possessor = null;
  ball.inFlight = true;
  const passTime = 0.6;
  let dx = target.x - qb.x;
  let dy = target.y - qb.y;
  ball.vx = dx / passTime;
  ball.vy = dy / passTime;

  setTimeout(()=>{
    // “Catch”
    ball.inFlight=false;
    ball.possessor=target;
    ball.x=target.x;
    ball.y=target.y;
  }, passTime*1000);
}

/** Initialize & start **/
initFormation();
showPlayButtons(true);
resizeCanvas();          // do an initial resize to fit screen
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
