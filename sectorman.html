<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- Prevent zooming on tap -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Gait & Directional Shooting Game Boy Platformer</title>
  <style>
    /* ——— Reset & Full-Screen Setup ——— */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; touch-action: manipulation; }
    body {
      background: #666;
      font-family: sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    /* ——— Full-Screen Game Boy Shell ——— */
    #gameboy {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #a3c1a3;  /* Game Boy body color */
      overflow: hidden;
    }
    /* ——— Screen (Game Canvas) ——— */
    #screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;             /* Full viewport width */
      height: calc(100vw * 0.75); /* 4:3 aspect ratio */
      background: #000;
      border-bottom: 8px solid #444;
      overflow: hidden;
    }
    /* The #game container represents the full level (wider than the screen) */
    #game {
      position: absolute;
      top: 0;
      left: 0;
      /* Its width is defined in JavaScript */
    }
    /* ——— Controls Area ——— */
    #controls {
      position: absolute;
      bottom: 5%;
      width: 100vw;
      height: 40vh;
    }
    /* ——— D-Pad Styling ——— */
    #dpad {
      position: absolute;
      left: 5%;
      bottom: 5%;
      width: 150px;
      height: 150px;
    }
    #dpad button {
      position: absolute;
      background: #333;
      border: 3px solid #777;
      border-radius: 10px;
      cursor: pointer;
      touch-action: manipulation;
      font-size: 0; /* no text labels */
    }
    #dpad button:active { background: #777; }
    /* Oversized D-Pad buttons */
    #dpad .up,
    #dpad .down,
    #dpad .left,
    #dpad .right {
      width: 60px;
      height: 60px;
    }
    /* Evenly space buttons in a cross layout */
    #dpad .up    { top: 0; left: 45px; }
    #dpad .down  { bottom: 0; left: 45px; }
    #dpad .left  { top: 45px; left: 0; }
    #dpad .right { top: 45px; right: 0; }
    
    /* ——— A/B Buttons Styling ——— */
    #ab-buttons {
      position: absolute;
      right: 5%;
      bottom: 5%;
      width: 150px;
      height: 150px;
    }
    #ab-buttons button {
      position: absolute;
      background: #333;
      border: 3px solid #777;
      border-radius: 50%;
      cursor: pointer;
      touch-action: manipulation;
      font-size: 0; /* no text labels */
    }
    #ab-buttons button:active { background: #777; }
    /* Oversized A/B buttons */
    #ab-buttons .A,
    #ab-buttons .B {
      width: 70px;
      height: 70px;
    }
    /* Position: A is shoot (upper right) and B is jump (bottom left) */
    #ab-buttons .A { top: 0; right: 0; }
    #ab-buttons .B { bottom: 0; left: 0; }
    
    /* ——— In-Game Entity Styles ——— */
    .entity {
      position: absolute;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    .player-part { background: #0f0; }
    .bullet { background: #fff; }
    .coin {
      background: gold;
      color: black;
      font-size: 14px;
      line-height: 16px;
      text-align: center;
      border-radius: 0;
    }
    .tv {
      position: absolute;
      background: #444;
      border: 2px solid #999;
      border-radius: 4px;
    }
    .platform {
      position: absolute;
      background: #555;
    }
  </style>
</head>
<body>
  <div id="gameboy">
    <!-- Game Screen -->
    <div id="screen">
      <div id="game"></div>
    </div>
    <!-- Controls -->
    <div id="controls">
      <div id="dpad">
        <button class="up"></button>
        <button class="down"></button>
        <button class="left"></button>
        <button class="right"></button>
      </div>
      <div id="ab-buttons">
        <button class="A"></button>
        <button class="B"></button>
      </div>
    </div>
  </div>

  <!-- Matter.js physics engine -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    // ——— Matter.js Setup ———
    const Engine     = Matter.Engine,
          World      = Matter.World,
          Bodies     = Matter.Bodies,
          Body       = Matter.Body,
          Constraint = Matter.Constraint,
          Events     = Matter.Events;
    
    const engine = Engine.create();
    const world  = engine.world;
    const game   = document.getElementById('game');

    // Level dimensions: level is much wider than the screen.
    const levelWidth = 3000;
    const screenRect = document.getElementById('screen').getBoundingClientRect();
    const screenWidth = screenRect.width;
    const gameHeight = screenRect.height;
    game.style.width = levelWidth + "px";
    game.style.height = gameHeight + "px";

    // Arrays for tracking bodies with associated DOM elements.
    let domEntities = [];
    let platforms   = [];
    let tvs         = [];
    let coins       = [];
    let bullets     = [];

    // Utility: Create a DOM element and link it to a Matter body.
    function createDomElement(body, className, width, height) {
      const el = document.createElement('div');
      el.className = 'entity ' + className;
      el.style.width  = width + 'px';
      el.style.height = height + 'px';
      game.appendChild(el);
      body.domElement = el;
      domEntities.push(body);
    }

    // ——— World Boundaries (Ground & Walls) ———
    const ground = Bodies.rectangle(levelWidth / 2, gameHeight, levelWidth, 40, { isStatic: true });
    const leftWall = Bodies.rectangle(0, gameHeight / 2, 40, gameHeight, { isStatic: true });
    const rightWall = Bodies.rectangle(levelWidth, gameHeight / 2, 40, gameHeight, { isStatic: true });
    World.add(world, [ground, leftWall, rightWall]);

    // ——— Player Setup: Ragdoll with human gait properties ———
    const player = { jumpCount: 0, facingDirection: 1 };
    (function createPlayer(x, y) {
      const size = 20;
      // Each body now has a bit of air resistance for a more grounded feel.
      const options = { friction: 0.5, frictionAir: 0.05, restitution: 0 };
      const head = Bodies.circle(x, y - 40, size / 2, options);
      createDomElement(head, 'player-part', size, size);

      const torso = Bodies.circle(x, y - 20, size, options);
      createDomElement(torso, 'player-part', size * 2, size * 2);

      const leftArm = Bodies.circle(x - 30, y - 20, size / 2, options);
      createDomElement(leftArm, 'player-part', size, size);

      const rightArm = Bodies.circle(x + 30, y - 20, size / 2, options);
      createDomElement(rightArm, 'player-part', size, size);

      const leftLeg = Bodies.circle(x - 10, y + 10, size / 2, options);
      createDomElement(leftLeg, 'player-part', size, size);

      const rightLeg = Bodies.circle(x + 10, y + 10, size / 2, options);
      createDomElement(rightLeg, 'player-part', size, size);

      World.add(world, [head, torso, leftArm, rightArm, leftLeg, rightLeg]);

      function link(bodyA, bodyB, offsetA, offsetB) {
        const con = Constraint.create({
          bodyA,
          pointA: offsetA,
          bodyB,
          pointB: offsetB,
          stiffness: 0.8,
          length: 20
        });
        World.add(world, con);
      }
      link(head, torso, { x: 0, y: size/2 }, { x: 0, y: -size });
      link(torso, leftArm, { x: -size, y: 0 }, { x: 0, y: 0 });
      link(torso, rightArm, { x: size, y: 0 }, { x: 0, y: 0 });
      link(torso, leftLeg, { x: -size/2, y: size }, { x: 0, y: -size/2 });
      link(torso, rightLeg, { x: size/2, y: size }, { x: 0, y: -size/2 });

      player.head     = head;
      player.torso    = torso;
      player.leftLeg  = leftLeg;
      player.rightLeg = rightLeg;
    })(100, 100);

    // ——— Procedural Platforms ———
    function createPlatform(x, y, width, height) {
      const plat = Bodies.rectangle(x, y, width, height, { isStatic: true });
      World.add(world, plat);
      const el = document.createElement('div');
      el.className = 'platform';
      el.style.width  = width + 'px';
      el.style.height = height + 'px';
      el.style.left   = (x - width/2) + 'px';
      el.style.top    = (y - height/2) + 'px';
      game.appendChild(el);
      plat.domElement = el;
      platforms.push(plat);
    }
    for (let i = 0; i < 15; i++) {
      const w = 100 + Math.random() * 100;
      const h = 20;
      const x = 100 + Math.random() * (levelWidth - 200);
      const y = 50 + i * 50;
      createPlatform(x, y, w, h);
    }

    // ——— Shootable TVs ———
    function createTV(x, y) {
      const tvW = 60, tvH = 40;
      const tv = Bodies.rectangle(x, y, tvW, tvH, { isStatic: true, label: 'tv' });
      World.add(world, tv);
      const el = document.createElement('div');
      el.className = 'tv';
      el.style.width  = tvW + 'px';
      el.style.height = tvH + 'px';
      el.style.left   = (x - tvW/2) + 'px';
      el.style.top    = (y - tvH/2) + 'px';
      game.appendChild(el);
      tv.domElement = el;
      tvs.push(tv);
    }
    for (let i = 0; i < 8; i++) {
      const x = 150 + Math.random() * (levelWidth - 300);
      const y = 50 + Math.random() * (gameHeight - 100);
      createTV(x, y);
    }

    // ——— Shooting Mechanic ———
    // The shoot function computes a direction vector based on active d-pad keys.
    let facingDirection = 1; // default: right
    function shoot() {
      let dx = 0, dy = 0;
      if (keys['ArrowUp'])    dy = -1;
      if (keys['ArrowDown'])  dy =  1;
      if (keys['ArrowLeft'])  dx = -1;
      if (keys['ArrowRight']) dx =  1;
      // If no directional input, shoot in facing direction (horizontal)
      if (dx === 0 && dy === 0) {
        dx = facingDirection;
      }
      // Normalize direction vector.
      const mag = Math.sqrt(dx*dx + dy*dy);
      dx /= mag; dy /= mag;
      shootBullet(player.torso.position.x, player.torso.position.y,
                  player.torso.position.x + dx*100,
                  player.torso.position.y + dy*100);
    }
    function shootBullet(x, y, targetX, targetY) {
      const bullet = Bodies.circle(x, y, 5, { friction: 0, frictionAir: 0.01, label: 'bullet' });
      const angle = Math.atan2(targetY - y, targetX - x);
      const speed = 15;
      Body.setVelocity(bullet, { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed });
      World.add(world, bullet);
      createDomElement(bullet, 'bullet', 10, 10);
      bullets.push(bullet);
    }

    // ——— Collision Handling: TV Explosions ———
    Events.on(engine, 'collisionStart', function(event) {
      event.pairs.forEach(pair => {
        const labels = [pair.bodyA.label, pair.bodyB.label];
        if (labels.includes('bullet') && labels.includes('tv')) {
          const tvBody = (pair.bodyA.label === 'tv') ? pair.bodyA : pair.bodyB;
          const bulletBody = (pair.bodyA.label === 'bullet') ? pair.bodyA : pair.bodyB;
          explodeTV(tvBody);
          World.remove(world, bulletBody);
          if (bulletBody.domElement) bulletBody.domElement.remove();
        }
      });
    });
    function explodeTV(tvBody) {
      World.remove(world, tvBody);
      if (tvBody.domElement) tvBody.domElement.remove();
      tvs = tvs.filter(tv => tv !== tvBody);
      const coinCount = 3 + Math.floor(Math.random() * 5);
      for (let i = 0; i < coinCount; i++) {
        const coin = Bodies.circle(tvBody.position.x, tvBody.position.y, 8, { restitution: 0.8, label: 'coin' });
        World.add(world, coin);
        createDomElement(coin, 'coin', 16, 16);
        coin.domElement.textContent = '*';
        coins.push(coin);
      }
    }

    // ——— Player Movement Controls & Human Gait ———
    // keys: ArrowLeft/Right control horizontal movement.
    const keys = {};
    window.addEventListener('keydown', (e) => { keys[e.code] = true; });
    window.addEventListener('keyup', (e) => { keys[e.code] = false; });
    // Also map "KeyB" to jump (for keyboard), in addition to Space.
    // Reset jump count when any leg contacts a static body.
    Events.on(engine, 'collisionStart', function(event) {
      event.pairs.forEach(pair => {
        [player.leftLeg, player.rightLeg].forEach(leg => {
          if (pair.bodyA === leg || pair.bodyB === leg) {
            if (pair.bodyA.isStatic || pair.bodyB.isStatic) {
              player.jumpCount = 0;
            }
          }
        });
      });
    });

    // ——— Camera Update: Clamp to player within level bounds ———
    function updateCamera() {
      const camOffset = Math.max(0, Math.min(player.torso.position.x - screenWidth/2, levelWidth - screenWidth));
      game.style.transform = "translateX(-" + camOffset + "px)";
    }

    // ——— Game Loop ———
    function update() {
      Engine.update(engine, 1000 / 60);

      // Update positions for DOM-linked entities.
      domEntities.forEach(body => {
        if (body.domElement) {
          body.domElement.style.left = body.position.x + "px";
          body.domElement.style.top  = body.position.y + "px";
          body.domElement.style.transform = "translate(-50%, -50%) rotate(" + body.angle + "rad)";
        }
      });

      // Update facing direction based on horizontal input.
      if (keys['ArrowLeft']) {
        facingDirection = -1;
        Body.applyForce(player.torso, player.torso.position, { x: -0.005, y: 0 });
      }
      if (keys['ArrowRight']) {
        facingDirection = 1;
        Body.applyForce(player.torso, player.torso.position, { x: 0.005, y: 0 });
      }
      // If no horizontal input, gradually damp horizontal velocity.
      if (!keys['ArrowLeft'] && !keys['ArrowRight']) {
        Body.setVelocity(player.torso, { x: player.torso.velocity.x * 0.98, y: player.torso.velocity.y });
      }
      // Jump: either Space or (mapped to) B key.
      if ((keys['Space'] || keys['KeyB']) && player.jumpCount < 2) {
        Body.setVelocity(player.torso, { x: player.torso.velocity.x, y: -10 });
        player.jumpCount++;
        keys['Space'] = false;
        keys['KeyB'] = false;
      }
      // Correct torso angle to simulate an upright human stance.
      const angleCorrection = -player.torso.angle * 0.2;
      Body.setAngularVelocity(player.torso, player.torso.angularVelocity + angleCorrection);

      updateCamera();
      requestAnimationFrame(update);
    }
    update();

    // ——— Touch & Button Mappings ———
    // D-Pad: Update directional keys on touch.
    const dpad = document.getElementById('dpad');
    dpad.querySelector('.up').addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys['ArrowUp'] = true;
      setTimeout(() => keys['ArrowUp'] = false, 150);
    });
    dpad.querySelector('.left').addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys['ArrowLeft'] = true;
      setTimeout(() => keys['ArrowLeft'] = false, 150);
    });
    dpad.querySelector('.right').addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys['ArrowRight'] = true;
      setTimeout(() => keys['ArrowRight'] = false, 150);
    });
    dpad.querySelector('.down').addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys['ArrowDown'] = true;
      setTimeout(() => keys['ArrowDown'] = false, 150);
    });
    // A button: Shoot in the computed direction.
    const abButtons = document.getElementById('ab-buttons');
    abButtons.querySelector('.A').addEventListener('touchstart', (e) => {
      e.preventDefault();
      shoot();
    });
    // B button: Jump.
    abButtons.querySelector('.B').addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys['Space'] = true;
      setTimeout(() => keys['Space'] = false, 150);
    });
  </script>
</body>
</html>
