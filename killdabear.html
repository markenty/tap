<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kill-Da-Bear</title>
  <style>
    html, body {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #505050;
      touch-action: none;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      background: #505050;
    }
    /* --- Headbutt Effect Styling --- */
    #headbuttEffect {
      position: absolute;
      pointer-events: none;
      width: 64px;
      height: 64px;
      background: rgba(255,255,255,0.8);
      border-radius: 50%;
      transform: scale(0);
      opacity: 0;
    }
    #headbuttEffect.active {
      animation: headbuttAnim 0.3s forwards;
    }
    @keyframes headbuttAnim {
      0% { transform: scale(0); opacity: 1; }
      50% { transform: scale(1.2) rotate(10deg); opacity: 1; }
      100% { transform: scale(0); opacity: 0; }
    }
    @media (max-width: 600px) {
      #headbuttEffect {
        width: 48px;
        height: 48px;
      }
    }
    /* --- Upgrade Menu Overlay Styling --- */
    #upgradeMenu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    #upgradeMenu .menu-content {
      background: #ffebcd;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
    }
    #upgradeMenu button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #upgradeMenu .menu-content .menu-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin: 20px 0;
    }
 /* --- Tray Styling --- */
    #itemTray {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);  justify-content: center;
      display: flex;
      align-items: center;
      z-index: 20;width: 90%;           /* Use a percentage so it scales with the viewport */
  max-width: 800px;     /* Limit its maximum width */
    }
    #itemTray .tray-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .divider {
      width: 1px;
      background-color: white;
      height: 40px;
      margin: 0 10px;
    }
    .tray-slot {
      position: relative;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid white;
      border-radius: 10px;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      color: white;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .tray-slot.active {
      box-shadow: 0 0 15px 3px rgba(255,255,0,0.9);
      transform: scale(1.1);
    }
    .tray-slot.dimmed {
      opacity: 0.5;
      pointer-events: none;
    }
    /* Overlays for counters and indicators */
    .tray-slot .counter,
    .tray-slot .timer {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 14px;
      color: yellow;
    }
    .tray-slot .indicator {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 14px;
      color: yellow;
    }
    @media (max-width: 600px) {
      #itemTray .tray-slot {
        width: 50px;
        height: 50px;
        font-size: 28px;
      }
      .tray-slot .counter, .tray-slot .timer, .tray-slot .indicator {
        font-size: 12px;
      }
    }
    /* --- Tally Marks for Max Strike Distance (vertical) --- */
#maxStrikeSlot .tally-container {
  position: absolute;
  top: 4px;
  left: 4px;
  right: 4px;
  bottom: 4px;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  gap: 2px;
}
.tally {
  flex: 0 0 auto;
  width: 10px;
  height: 10px;
  background: white;
}


.meter {
  position: absolute;
  bottom: 0;
  left: 0;
  height: 5px;
  background: gray;
  border-radius: 0 0 10px 10px;
}
.shield-meter {
  background-color: blue;
}
.charm-meter {
  background-color: purple;
}
.auto-strike-meter {
  background-color: orange;
}.bomb-available {
  border-color: red;
  box-shadow: 0 0 10px 3px rgba(255, 0, 0, 0.8);
}

  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <!-- Headbutt Effect Overlay -->
  <div id="headbuttEffect"></div>
  
  <!-- Upgrade Menu Overlay -->
  <div id="upgradeMenu">
    <div class="menu-content">
      <h1>Upgrade Menu</h1>
      <p>You have <span id="pointsDisplay"></span> points.</p>
      <div class="menu-buttons">
        <button id="increaseHP">‚ù§Ô∏è Increase Max HP (+20 HP) - Cost: 50</button>
        <button id="increaseAutoRun">‚è± Increase Auto Strike Time (+10s) - Cost: 200</button>
        <button id="increaseDash">‚û°Ô∏è Increase Strike Range (+1 tile) - Cost: 300</button>
        <button id="increaseStrikeMeter">üîã Increase Strike Meter Capacity (+10) - Cost: 150</button>
        <button id="increaseHealingCharmTime">ü™¨ Increase Healing Charm (Duration & Heal) - Cost: 250</button>
        <button id="increaseShieldingTime">üõ°Ô∏è Increase Shielding (Duration & Reduction) - Cost: 250</button>
      </div>
      <button id="resumeGame" style="margin-top: 20px;">‚ñ∂Ô∏è Resume Game</button>
    </div>
  </div>
  
  <!-- Item Tray -->
  <div id="itemTray">
    <div class="tray-group passive">
      <!-- New HUD tray slots -->
      <div class="tray-slot" id="pointsSlot">üí∞<div class="counter">0</div></div>
      <div class="tray-slot" id="killsSlot">üíÄ<div class="counter">0</div></div>
      <!-- Existing icons -->
      
      <div class="tray-slot dimmed" id="defenseSlot">üõ°Ô∏è</div>
      <div class="tray-slot dimmed" id="charmsSlot">ü™¨</div>
      <div class="tray-slot" id="hpSlot">
        ‚ù§Ô∏è
        <div class="counter">100</div>
      </div>
      <div class="tray-slot" id="autoStrikeSlot">
        <!-- Indicator now appears on the left -->
        <div class="indicator">‚úÖ</div>
        ‚öîÔ∏è
        <div class="counter">10</div>
      </div>
      <!-- Max Strike Distance Slot with vertical tally -->
      <div class="tray-slot" id="maxStrikeSlot">
        üî±
        <div class="tally-container"></div>
      </div>
    </div>
    <div class="divider"></div>
    <div class="tray-group active">
      <div class="tray-slot" id="explosivesSlot">üí£<div class="counter">0</div></div>
<div class="tray-slot" id="attackSlot">üëä</div>
    </div>
  </div>
  
  <script>
    "use strict";
    
    const PIXEL_SIZE = 4;
    const goldDecayRate = 5;
    
    let timeScale = 1.0, slowMotionTimer = 0, killCount = 0;
    let bombCount = 0, points = 0;
    let baseAutoStrikeTime = 10;
    let autoStrikeTime = baseAutoStrikeTime;
    let autoStrikeInterval = 0.3, autoStrikeTimer = 0;
    let globalTime = 0;
    let isUpgradeMenuVisible = false;
    let autoStrikeBonus = 10; // initial bonus seconds per sword pickup    // Strike-related (using strikeMeter for current value)
    let strikeRangeTiles = 1;
    let strikeMeterCapacity = 100;
    
    // Power-up state variables
    let defenseBoostActive = false;
    let defenseBoostTimer = 0;
    let healingCharmActive = false;
    let healingCharmTimer = 0;
    // Base durations and effects
    let baseDefenseBoostDuration = 10;  // seconds
    let baseShieldDamageReduction = 0.5;  // 50% damage reduction
    let baseHealingCharmDuration = 10;    // seconds
    let baseHealingCharmHeal = 1;         // HP per second
    
    let screenFlashAlpha = 0;
    let spriteFlashes = [];
    function triggerScreenFlash() { screenFlashAlpha = 0.5; }
    function addSpriteFlash(position) { spriteFlashes.push({ position: position, timer: 0.2, duration: 0.2 }); }
    
    let meleeEffects = [];
    function spawnMeleeEffect(x, y, angle) { meleeEffects.push({ x, y, angle, timer: 0.2, duration: 0.2 }); }
    function renderMeleeEffects(ctx, camera) {
      for (let effect of meleeEffects) {
        let progress = 1 - (effect.timer / effect.duration);
        let screenPos = camera.worldToScreen(new Vector2(effect.x, effect.y));
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(effect.angle);
        ctx.beginPath();
        ctx.arc(0, 0, 40 * progress, Math.PI, Math.PI + 0.8, false);
        ctx.lineWidth = 4;
        ctx.strokeStyle = "white";
        ctx.stroke();
        ctx.restore();
      }
    }
    function updateMeleeEffects(deltaTime) {
      for (let i = meleeEffects.length - 1; i >= 0; i--) {
        meleeEffects[i].timer -= deltaTime;
        if (meleeEffects[i].timer <= 0) meleeEffects.splice(i, 1);
      }
    }
    
    function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }
    
    class Vector2 {
      constructor(x, y) { this.x = x; this.y = y; }
      add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
      subtract(v) { return new Vector2(this.x - v.x, this.y - v.y); }
      scale(s) { return new Vector2(this.x * s, this.y * s); }
      length() { return Math.sqrt(this.x * this.x + this.y * this.y); }
      normalize() { let len = this.length(); return new Vector2(this.x / (len || 1), this.y / (len || 1)); }
    }
    
    class Camera {
      constructor(screenWidth, screenHeight) {
        this.position = new Vector2(0, 0);
        this.zoom = 1.0;
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
      }
      worldToScreen(worldPos) {
        return new Vector2(
          (worldPos.x - this.position.x) * this.zoom + this.screenWidth / 2,
          (worldPos.y - this.position.y) * this.zoom + this.screenHeight / 2
        );
      }
      screenToWorld(screenPos) {
        return new Vector2(
          (screenPos.x - this.screenWidth / 2) / this.zoom + this.position.x,
          (screenPos.y - this.screenHeight / 2) / this.zoom + this.position.y
        );
      }
    }
    
    class Tile {
      constructor(gridX, gridY, tileType, color) { this.gridX = gridX; this.gridY = gridY; this.tileType = tileType; this.color = color; }
    }
    class TileMap {
      constructor(width, height, tileWidth, tileHeight) {
        this.width = width; this.height = height;
        this.tileWidth = tileWidth; this.tileHeight = tileHeight;
        this.tiles = [];
        for (let y = 0; y < height; y++) {
          let row = [];
          for (let x = 0; x < width; x++) { row.push(new Tile(x, y, 0, "#64dd64")); }
          this.tiles.push(row);
        }
      }
      gridToWorld(gridX, gridY) {
        return new Vector2((gridX - gridY) * (this.tileWidth / 2), (gridX + gridY) * (this.tileHeight / 2));
      }
      render(ctx, camera) {
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            let worldPos = this.gridToWorld(x, y);
            let screenPos = camera.worldToScreen(worldPos);
            let halfW = this.tileWidth / 2, halfH = this.tileHeight / 2;
            ctx.beginPath();
            ctx.moveTo(screenPos.x, screenPos.y + halfH);
            ctx.lineTo(screenPos.x + halfW, screenPos.y);
            ctx.lineTo(screenPos.x + this.tileWidth, screenPos.y + halfH);
            ctx.lineTo(screenPos.x + halfW, screenPos.y + this.tileHeight);
            ctx.closePath();
            ctx.fillStyle = this.tiles[y][x].color;
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.stroke();
          }
        }
      }
    }
    
    class Particle {
      constructor(position, velocity, life, color, size, acceleration) {
        this.position = position; this.velocity = velocity;
        this.acceleration = acceleration || new Vector2(0, 0);
        this.life = life; this.maxLife = life; this.color = color; this.size = size;
      }
      update(deltaTime) {
        this.velocity = this.velocity.add(this.acceleration.scale(deltaTime));
        this.position = this.position.add(this.velocity.scale(deltaTime));
        this.life -= deltaTime;
      }
      render(ctx, camera) {
        let alpha = Math.max(this.life / this.maxLife, 0);
        let screenPos = camera.worldToScreen(this.position);
        ctx.fillStyle = this.color.replace("ALPHA", alpha);
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    let effects = [];
    function spawnPickupEffect(position) {
      const count = 10;
      for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = Math.random() * 50 + 50;
        let velocity = new Vector2(Math.cos(angle), Math.sin(angle)).scale(speed);
        let life = Math.random() * 0.5 + 0.5;
        let size = Math.random() * 2 + 2;
        effects.push(new Particle(new Vector2(position.x, position.y), velocity, life, "rgba(255,215,0,ALPHA)", size));
      }
    }
    function spawnBloodEffect(position) {
      const count = 20;
      for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = Math.random() * 100 + 50;
        let velocity = new Vector2(Math.cos(angle), Math.sin(angle)).scale(speed);
        let life = Math.random() * 0.5 + 0.5;
        let size = Math.random() * 1 + 1;
        effects.push(new Particle(new Vector2(position.x, position.y), velocity, life, "rgba(200,0,0,ALPHA)", size));
      }
    }
    function spawnExplosionEffect(position) {
      const count = 30;
      for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = Math.random() * 80 + 40;
        let velocity = new Vector2(Math.cos(angle), Math.sin(angle)).scale(speed);
        let life = Math.random() * 0.5 + 0.5;
        let size = Math.random() * 2 + 2;
        effects.push(new Particle(new Vector2(position.x, position.y), velocity, life, "rgba(255,165,0,ALPHA)", size));
      }
    }
    function spawnEnemyExplosionEffect(position) {
      const count = 50;
      for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = Math.random() * 200 + 100;
        let velocity = new Vector2(Math.cos(angle), Math.sin(angle)).scale(speed);
        let life = Math.random() * 1 + 0.5;
        let size = Math.random() * 3 + 2;
        let color = Math.random() < 0.5 ? "rgba(255,105,180,ALPHA)" : "rgba(255,0,0,ALPHA)";
        let acceleration = new Vector2(0, 300);
        effects.push(new Particle(new Vector2(position.x, position.y), velocity, life, color, size, acceleration));
      }
    }
    function updateEffects(deltaTime) {
      for (let i = effects.length - 1; i >= 0; i--) {
        effects[i].update(deltaTime);
        if (effects[i].life <= 0) effects.splice(i, 1);
      }
    }
    function renderEffects(ctx, camera) {
      for (let eff of effects) { eff.render(ctx, camera); }
    }
    
    // Pickups
    class HealthPickup {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap; 
        this.gridX = tileX; 
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.size = tileMap.tileWidth / 2;
      }
      render(ctx, camera, t) {
        let screenPos = camera.worldToScreen(this.position);
        let floatOffset = Math.sin(t * 2) * 5;
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y + this.size/2 + floatOffset);
        ctx.rotate(t);
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(255,255,255,0.8)";
        ctx.font = `${this.size}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("‚ù§Ô∏è", 0, 0);
        ctx.restore();
      }
    }
    
    class BombPickup {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap; 
        this.gridX = tileX; 
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.size = tileMap.tileWidth / 2;
      }
      render(ctx, camera, t) {
        let screenPos = camera.worldToScreen(this.position);
        let floatOffset = Math.sin(t * 2) * 5;
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y + this.size/2 + floatOffset);
        ctx.rotate(t);
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(255,255,255,0.8)";
        ctx.font = `${this.size}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("üí£", 0, 0);
        ctx.restore();
      }
    }
    
    class SwordPickup {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap; 
        this.gridX = tileX; 
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.size = tileMap.tileWidth / 2;
      }
      render(ctx, camera, t) {
        let screenPos = camera.worldToScreen(this.position);
        let floatOffset = Math.sin(t * 2) * 5;
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y + this.size/2 + floatOffset);
        ctx.rotate(t);
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(255,255,255,0.8)";
        ctx.font = `${this.size}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("‚öîÔ∏è", 0, 0);
        ctx.restore();
      }
    }
    
    // Defensive Boost Pickup (Shield)
    class DefenseBoostPickup {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap; 
        this.gridX = tileX; 
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.size = tileMap.tileWidth / 2;
      }
      render(ctx, camera, t) {
        let screenPos = camera.worldToScreen(this.position);
        let floatOffset = Math.sin(t * 2) * 5;
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y + this.size/2 + floatOffset);
        ctx.rotate(t);
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(255,255,255,0.8)";
        ctx.font = `${this.size}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("üõ°Ô∏è", 0, 0);
        ctx.restore();
      }
    }
    
    // Healing Charm Pickup
    class HealingCharmPickup {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap; 
        this.gridX = tileX; 
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.size = tileMap.tileWidth / 2;
      }
      render(ctx, camera, t) {
        let screenPos = camera.worldToScreen(this.position);
        let floatOffset = Math.sin(t * 2) * 5;
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y + this.size/2 + floatOffset);
        ctx.rotate(t);
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(255,255,255,0.8)";
        ctx.font = `${this.size}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("ü™¨", 0, 0);
        ctx.restore();
      }
    }
    
    let pickups = [], baitBombs = [];
    let pickupSpawnTimer = 0, pickupSpawnInterval = 10.0;
    
    class Bullet {
      constructor(position, velocity, owner) {
        this.position = new Vector2(position.x, position.y);
        this.startPosition = new Vector2(position.x, position.y);
        this.velocity = velocity;
        this.radius = 5;
        this.alive = true;
        this.owner = owner;
        this.maxDistance = Math.sqrt(Math.pow(tileMap.tileWidth / 2, 2) + Math.pow(tileMap.tileHeight / 2, 2));
      }
      update(deltaTime) {
        this.position = this.position.add(this.velocity.scale(deltaTime));
        if (this.position.subtract(this.startPosition).length() >= this.maxDistance)
          this.alive = false;
        if (this.position.x < -50 || this.position.x > canvas.width + 50 ||
            this.position.y < -50 || this.position.y > canvas.height + 50)
          this.alive = false;
      }
      render(ctx, camera) {
        let screenPos = camera.worldToScreen(this.position);
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "yellow";
        ctx.fill();
      }
    }
    
    class Player {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap;
        this.gridX = tileX;
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.pixelSize = PIXEL_SIZE * 0.5;
        this.width = 32 * this.pixelSize;
        this.height = 32 * this.pixelSize;
        this.moving = false;
        this.startPos = null;
        this.targetPos = null;
        this.moveDuration = 0.1;
        this.moveTime = 0;
        this.targetGridX = tileX;
        this.targetGridY = tileY;
        this.direction = "down";
        this.maxHP = 100;
        this.hp = 100;
        this.normalStrikeRange = 50;
        // Use strikeMeter for the current (depleting) meter value
        this.strikeMeter = 0;
        this.maxStrikeMeter = strikeMeterCapacity;
        this.knockback = new Vector2(0, 0);
        this.isDead = false;
        this.spriteSheet = new Image();
        this.spriteLoaded = false;
        this.spriteSheet.onload = () => { this.spriteLoaded = true; };
        this.spriteSheet.src = "https://s3-us-west-2.amazonaws.com/s.cdpn.io/21542/WalkingDemo-SHIRMOND-SHEET.png";
        this.frameCount = 4;
        this.currentFrame = 0;
        this.frameTime = 0;
        this.frameDelay = 0.1;
      }
      update(deltaTime) {
        if (this.moving) {
          this.moveTime += deltaTime;
          let t = Math.min(this.moveTime / this.moveDuration, 1);
          this.position = new Vector2(
            this.startPos.x + (this.targetPos.x - this.startPos.x) * t,
            this.startPos.y + (this.targetPos.y - this.startPos.y) * t
          );
          this.frameTime += deltaTime;
          if (this.frameTime >= this.frameDelay) {
            this.currentFrame = (this.currentFrame + 1) % this.frameCount;
            this.frameTime = 0;
          }
          if (t >= 1) {
            this.moving = false;
            this.gridX = this.targetGridX;
            this.gridY = this.targetGridY;
            this.currentFrame = 0;
          }
        } else {
          this.currentFrame = 0;
        }
        this.knockback = this.knockback.scale(0.9);
      }
      render(ctx, camera) {
        let pos = this.position.add(this.knockback);
        let screenPos = camera.worldToScreen(pos);
        if (this.spriteLoaded) {
          let row = 0;
          switch (this.direction) {
            case "down": row = 0; break;
            case "right": row = 1; break;
            case "up": row = 2; break;
            case "left": row = 3; break;
            default: row = 0;
          }
          let srcX = this.currentFrame * 32, srcY = row * 32;
          ctx.drawImage(this.spriteSheet, srcX, srcY, 32, 32, screenPos.x, screenPos.y, this.width, this.height);
        } else {
          ctx.fillStyle = "red";
          ctx.fillRect(screenPos.x, screenPos.y, this.width, this.height);
        }
      }
      move(direction) {
        if (this.moving) return;
        let distance = 1;
        let newGridX = this.gridX, newGridY = this.gridY;
        if (direction === "up") newGridY -= distance;
        else if (direction === "down") newGridY += distance;
        else if (direction === "left") newGridX -= distance;
        else if (direction === "right") newGridX += distance;
        newGridX = Math.max(0, Math.min(newGridX, this.tileMap.width - 1));
        newGridY = Math.max(0, Math.min(newGridY, this.tileMap.height - 1));
        if (this.tileMap.tiles[newGridY][newGridX].tileType !== 0) return;
        this.moving = true;
        this.moveTime = 0;
        this.startPos = this.position;
        this.targetPos = this.tileMap.gridToWorld(newGridX, newGridY);
        this.targetGridX = newGridX;
        this.targetGridY = newGridY;
        this.direction = direction;
        this.frameTime = 0;
        this.currentFrame = 0;
      }
      shoot() {
        let startPos = new Vector2(this.position.x + this.width / 2, this.position.y + this.height / 2);
        let directionVector;
        switch (this.direction) {
          case "up": directionVector = new Vector2(0, -1); break;
          case "down": directionVector = new Vector2(0, 1); break;
          case "left": directionVector = new Vector2(-1, 0); break;
          case "right": directionVector = new Vector2(1, 0); break;
          default: directionVector = new Vector2(0, -1);
        }
        let bulletSpeed = 600, velocity = directionVector.scale(bulletSpeed);
        bullets.push(new Bullet(new Vector2(this.position.x + this.width / 2, this.position.y + this.height / 2), velocity, "player"));
      }
      shootAt(target) {
        let startPos = new Vector2(this.position.x + this.width / 2, this.position.y + this.height / 2);
        let diff = target.subtract(startPos), norm = diff.normalize();
        let bulletSpeed = 600, velocity = norm.scale(bulletSpeed);
        bullets.push(new Bullet(startPos, velocity, "player"));
      }
      respawn() {
        this.gridX = 5;
        this.gridY = 5;
        this.position = this.tileMap.gridToWorld(this.gridX, this.gridY);
        this.hp = this.maxHP;
        this.isDead = false;
      }
      strike(direction) {
        let strikeRange;
        if (strikeRangeTiles <= 1) {
          strikeRange = this.normalStrikeRange;
        } else {
          // Use the current strikeMeter for depletion.
          if (this.strikeMeter >= 10) {
            strikeRange = strikeRangeTiles * 50;
            this.strikeMeter -= 10;
          } else {
            strikeRange = this.normalStrikeRange;
          }
        }
        let offset;
        switch(direction) {
          case "up": offset = new Vector2(0, -strikeRange); break;
          case "down": offset = new Vector2(0, strikeRange); break;
          case "left": offset = new Vector2(-strikeRange, 0); break;
          case "right": offset = new Vector2(strikeRange, 0); break;
          default: offset = new Vector2(0, -strikeRange);
        }
        let playerCenter = new Vector2(this.position.x + this.width / 2, this.position.y + this.height / 2);
        let strikeCenter = playerCenter.add(offset);
        triggerHeadbutt();
        enemies.forEach(enemy => {
          let enemyCenter = new Vector2(enemy.position.x + enemy.width / 2, enemy.position.y + enemy.height / 2);
          if (enemyCenter.subtract(strikeCenter).length() <= strikeRange) {
            addSpriteFlash(enemy.position);
            enemy.alive = false;
            spawnEnemyExplosionEffect(enemy.position);
            killCount++;
            let angle = Math.atan2(enemyCenter.y - strikeCenter.y, enemyCenter.x - strikeCenter.x);
            let effectX = strikeCenter.x + Math.cos(angle) * 20;
            let effectY = strikeCenter.y + Math.sin(angle) * 20;
            spawnMeleeEffect(effectX, effectY, angle);
          }
        });
      }
    }
    
    class Enemy {
      constructor(tileX, tileY, tileMap) {
        this.tileMap = tileMap;
        this.gridX = tileX;
        this.gridY = tileY;
        this.position = tileMap.gridToWorld(tileX, tileY);
        this.pixelSize = PIXEL_SIZE * 0.5;
        this.width = 32 * this.pixelSize;
        this.height = 32 * this.pixelSize;
        this.spriteSheet = new Image();
        this.spriteLoaded = false;
        this.spriteSheet.onload = () => { this.spriteLoaded = true; };
        this.spriteSheet.src = "https://s3-us-west-2.amazonaws.com/s.cdpn.io/21542/WalkingDemo-BEAR-SHEET.png";
        this.alive = true;
        this.maxHP = 40;
        this.hp = 40;
        this.moving = false;
        this.startPos = null;
        this.targetPos = null;
        this.moveDuration = 0.2;
        this.moveTime = 0;
        this.targetGridX = tileX;
        this.targetGridY = tileY;
        this.direction = "down";
        this.frameCount = 4;
        this.currentFrame = 0;
        this.frameTime = 0;
        this.frameDelay = 0.15;
        this.attackCooldown = 0;
        this.knockback = new Vector2(0, 0);
      }
      update(deltaTime) {
        if (this.moving) {
          this.moveTime += deltaTime;
          let t = Math.min(this.moveTime / this.moveDuration, 1);
          this.position = new Vector2(
            this.startPos.x + (this.targetPos.x - this.startPos.x) * t,
            this.startPos.y + (this.targetPos.y - this.startPos.y) * t
          );
          this.frameTime += deltaTime;
          if (this.frameTime >= this.frameDelay) {
            this.currentFrame = (this.currentFrame + 1) % this.frameCount;
            this.frameTime = 0;
          }
          if (t >= 1) {
            this.moving = false;
            this.gridX = this.targetGridX;
            this.gridY = this.targetGridY;
            this.currentFrame = 0;
          }
        } else {
          let targetGridX, targetGridY;
          if (baitBombs.length > 0) {
            let targetBomb = baitBombs[0];
            targetGridX = targetBomb.tileX;
            targetGridY = targetBomb.tileY;
          } else {
            targetGridX = player.gridX;
            targetGridY = player.gridY;
            let dxP = player.gridX - this.gridX, dyP = player.gridY - this.gridY;
            let manhattanP = Math.abs(dxP) + Math.abs(dyP);
            if (manhattanP <= 1 && this.attackCooldown <= 0) {
              this.shoot();
              this.attackCooldown = 1.0;
              return;
            }
          }
          let dx = targetGridX - this.gridX, dy = targetGridY - this.gridY;
          if (Math.abs(dx) + Math.abs(dy) > 0) {
            let direction = Math.abs(dx) >= Math.abs(dy) ? (dx > 0 ? "right" : "left") : (dy > 0 ? "down" : "up");
            this.move(direction);
          }
          if (this.attackCooldown > 0) this.attackCooldown -= deltaTime;
        }
        this.knockback = this.knockback.scale(0.9);
      }
      render(ctx, camera) {
        let pos = this.position.add(this.knockback);
        let screenPos = camera.worldToScreen(pos);
        if (this.spriteLoaded) {
          let row = 0;
          switch (this.direction) {
            case "down": row = 0; break;
            case "right": row = 1; break;
            case "up": row = 2; break;
            case "left": row = 3; break;
            default: row = 0;
          }
          let srcX = this.currentFrame * 32, srcY = row * 32;
          ctx.drawImage(this.spriteSheet, srcX, srcY, 32, 32, screenPos.x, screenPos.y, this.width, this.height);
        } else {
          ctx.fillStyle = "green";
          ctx.fillRect(screenPos.x, screenPos.y, this.width, this.height);
        }
      }
      move(direction) {
        if (this.moving) return;
        let newGridX = this.gridX, newGridY = this.gridY;
        if (direction === "up") newGridY -= 1;
        else if (direction === "down") newGridY += 1;
        else if (direction === "left") newGridX -= 1;
        else if (direction === "right") newGridX += 1;
        if (newGridX < 0 || newGridX >= this.tileMap.width ||
            newGridY < 0 || newGridY >= this.tileMap.height) return;
        if (this.tileMap.tiles[newGridY][newGridX].tileType !== 0) return;
        this.moving = true;
        this.moveTime = 0;
        this.startPos = this.position;
        this.targetPos = this.tileMap.gridToWorld(newGridX, newGridY);
        this.targetGridX = newGridX;
        this.targetGridY = newGridY;
        this.direction = direction;
        this.frameTime = 0;
        this.currentFrame = 0;
      }
      shoot() {
        let startPos = new Vector2(this.position.x + this.width / 2, this.position.y + this.height / 2);
        let playerCenter = new Vector2(player.position.x + player.width / 2, player.position.y + player.height / 2);
        let diff = playerCenter.subtract(startPos), norm = diff.normalize();
        let bulletSpeed = 600, velocity = norm.scale(bulletSpeed);
        bullets.push(new Bullet(startPos, velocity, "enemy"));
      }
    }
    
    let screenShakeTime = 0, screenShakeMagnitude = 0, shakeOffset = new Vector2(0, 0);
    function resolveCollision(entityA, entityB) {
      let ax = entityA.position.x + entityA.knockback.x,
          ay = entityA.position.y + entityA.knockback.y,
          aw = entityA.width, ah = entityA.height;
      let bx = entityB.position.x + entityB.knockback.x,
          by = entityB.position.y + entityB.knockback.y,
          bw = entityB.width, bh = entityB.height;
      if (ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by) {
        let centerA = new Vector2(ax + aw / 2, ay + ah / 2);
        let centerB = new Vector2(bx + bw / 2, by + bh / 2);
        let diff = centerA.subtract(centerB);
        let distance = diff.length();
        if (distance === 0) { diff = new Vector2(1, 0); distance = 1; }
        let minDistance = (aw + bw) / 4;
        let overlap = minDistance - distance;
        if (overlap > 0) {
          let knock = diff.normalize().scale(overlap * 0.5);
          entityA.knockback = entityA.knockback.add(knock);
          entityB.knockback = entityB.knockback.subtract(knock);
        }
      }
    }
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const camera = new Camera(canvas.width, canvas.height);
    const tileMap = new TileMap(20, 20, 64, 32);
    let corners = [
      tileMap.gridToWorld(0, 0),
      tileMap.gridToWorld(tileMap.width - 1, 0),
      tileMap.gridToWorld(0, tileMap.height - 1),
      tileMap.gridToWorld(tileMap.width - 1, tileMap.height - 1)
    ];
    let worldMinX = Math.min(...corners.map(c => c.x));
    let worldMaxX = Math.max(...corners.map(c => c.x)) + tileMap.tileWidth;
    let worldMinY = Math.min(...corners.map(c => c.y));
    let worldMaxY = Math.max(...corners.map(c => c.y)) + tileMap.tileHeight;
    function updateCamera() {
      let halfWidth = (canvas.width / camera.zoom) / 2;
      let halfHeight = (canvas.height / camera.zoom) / 2;
      let worldWidth = worldMaxX - worldMinX, worldHeight = worldMaxY - worldMinY;
      let targetX = player.position.x, targetY = player.position.y;
      if (worldWidth < canvas.width / camera.zoom) { targetX = worldMinX + worldWidth / 2; }
      else { targetX = clamp(player.position.x, worldMinX + halfWidth, worldMaxX - halfWidth); }
      if (worldHeight < canvas.height / camera.zoom) { targetY = worldMinY + worldHeight / 2; }
      else { targetY = clamp(player.position.y, worldMinY + halfHeight, worldMaxY - halfHeight); }
      camera.position = new Vector2(targetX, targetY);
    }
    
    let player = new Player(5, 5, tileMap);
    // Initialize current strike meter to 0.
    player.strikeMeter = 0;
    
    const bullets = [], enemies = [];
    let enemySpawnTimer = 0;
    
    function performAutoStrike() {
      let playerCenter = new Vector2(player.position.x + player.width / 2, player.position.y + player.height / 2);
      // Use current strikeMeter for checking available meter
      let effectiveRange = (strikeRangeTiles > 1 && player.strikeMeter >= 10) ? strikeRangeTiles * 50 : 50;
      const offsetDistance = 20;
      enemies.forEach(enemy => {
        let enemyCenter = new Vector2(enemy.position.x + enemy.width / 2, enemy.position.y + enemy.height / 2);
        if (playerCenter.subtract(enemyCenter).length() < effectiveRange) {
          triggerScreenFlash();
          addSpriteFlash(enemy.position);
          enemy.alive = false;
          spawnEnemyExplosionEffect(enemy.position);
          killCount++;
          let angle = Math.atan2(enemyCenter.y - playerCenter.y, enemyCenter.x - playerCenter.x);
          let effectX = playerCenter.x + Math.cos(angle) * offsetDistance;
          let effectY = playerCenter.y + Math.sin(angle) * offsetDistance;
          spawnMeleeEffect(effectX, effectY, angle);
        }
      });
    }
        const attackSlot = document.getElementById("attackSlot");
    attackSlot.classList.add("dimmed"); // Start dimmed
    
    function updateAttackSlot() {
      if (player.strikeMeter > 0) {
        attackSlot.classList.remove("dimmed");
        attackSlot.style.borderColor = "red";
        attackSlot.style.boxShadow = "0 0 10px 3px rgba(255, 0, 0, 0.8)";
      } else {
        attackSlot.classList.add("dimmed");
        attackSlot.style.borderColor = "";
        attackSlot.style.boxShadow = "";
      }
    }
    
    attackSlot.addEventListener("click", () => {
      if (player.strikeMeter > 0) {
        executeDashAttack();
        player.strikeMeter = 0; // Deplete the strike meter
        updateAttackSlot();
      }
    });
    
   function executeDashAttack() {
  const dashDistance = strikeRangeTiles * 50; // Use max strike distance
  let dashVector;

  switch (player.direction) {
    case "up": dashVector = new Vector2(0, -dashDistance); break;
    case "down": dashVector = new Vector2(0, dashDistance); break;
    case "left": dashVector = new Vector2(-dashDistance, 0); break;
    case "right": dashVector = new Vector2(dashDistance, 0); break;
    default: return;
  }

  let dashEndPos = player.position.add(dashVector);
  createDashTrail(player.position, dashEndPos); // Generate trail effect
  player.position = dashEndPos; // Move the player instantly
  triggerScreenFlash();
  spawnMeleeEffect(player.position.x, player.position.y, 0);

  enemies.forEach(enemy => {
    let enemyCenter = new Vector2(enemy.position.x + enemy.width / 2, enemy.position.y + enemy.height / 2);
    let playerCenter = new Vector2(player.position.x + player.width / 2, player.position.y + player.height / 2);
    if (enemyCenter.subtract(playerCenter).length() < dashDistance) {
      enemy.alive = false;
      spawnEnemyExplosionEffect(enemy.position);
      killCount++;
    }
  });

  // **Fix: Immediately Update Attack Slot**
  player.strikeMeter = 0; // Deplete the strike meter
  updateAttackSlot();  // No more delay
}

    
    function createDashTrail(startPos, endPos) {
      let trailSteps = 10;
      for (let i = 0; i < trailSteps; i++) {
        let t = i / trailSteps;
        let trailPos = new Vector2(
          startPos.x + (endPos.x - startPos.x) * t,
          startPos.y + (endPos.y - startPos.y) * t
        );
        spawnDashEffect(trailPos);
      }
    }
    
    function spawnDashEffect(position) {
      let effectDuration = 0.3;
      spriteFlashes.push({ position: position, timer: effectDuration, duration: effectDuration });
    }
   function performManualStrikeAt(tapX, tapY) {
  // Define the current melee range in pixels based on the player's strike range level.
  const tileSize = 50; // each tile is 50px
  // currentMeleeRange is computed as strikeRangeTiles * tileSize.
  const currentMeleeRange = strikeRangeTiles * tileSize;
  // Determine if this is a critical melee hit (only when strikeRangeTiles equals 4)
  const isCritical = (strikeRangeTiles === 4);

  // Loop over each enemy to see if the tap is on it.
  for (let enemy of enemies) {
    // Get enemy's on-screen bounding box
    let enemyScreenPos = camera.worldToScreen(enemy.position);
    let enemyRect = {
      x: enemyScreenPos.x,
      y: enemyScreenPos.y,
      width: enemy.width,
      height: enemy.height
    };

    // Check if the tap is inside the enemy's box.
    if (tapX >= enemyRect.x && tapX <= enemyRect.x + enemyRect.width &&
        tapY >= enemyRect.y && tapY <= enemyRect.y + enemyRect.height) {
      // Get centers in world coordinates.
      let playerCenter = new Vector2(
        player.position.x + player.width / 2,
        player.position.y + player.height / 2
      );
      let enemyCenter = new Vector2(
        enemy.position.x + enemy.width / 2,
        enemy.position.y + enemy.height / 2
      );

      // Check if enemy is within the current melee range.
      if (playerCenter.subtract(enemyCenter).length() <= currentMeleeRange) {
        // Hit registered! If it's a critical hit, you can add special effects.
        triggerScreenFlash();
        addSpriteFlash(enemy.position);
        enemy.alive = false;
        spawnEnemyExplosionEffect(enemy.position);
        killCount++;

        // Spawn a melee effect. If critical, you might change its parameters.
        let angle = Math.atan2(
          enemyCenter.y - playerCenter.y,
          enemyCenter.x - playerCenter.x
        );
        let effectX = playerCenter.x + Math.cos(angle) * 20;
        let effectY = playerCenter.y + Math.sin(angle) * 20;
        // For a critical hit, you could modify the effect (for example, larger radius)
        if (isCritical) {
          // Optionally, you might add an extra effect or bonus here.
          spawnMeleeEffect(effectX, effectY, angle);
          // Example: increment kill count extra, play a different sound, etc.
        } else {
          spawnMeleeEffect(effectX, effectY, angle);
        }
        return true;
      }
    }
  }
  return false;
}

    
    let dragStart = null;
    canvas.addEventListener("mousedown", (evt) => { dragStart = { x: evt.clientX, y: evt.clientY }; });
    canvas.addEventListener("mousemove", (evt) => { });
    canvas.addEventListener("mouseup", (evt) => {
      if (!dragStart) return;
      let dx = evt.clientX - dragStart.x;
      let dy = evt.clientY - dragStart.y;
      if (Math.sqrt(dx * dx + dy * dy) > 10) {
        let direction = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? "right" : "left") : (dy > 0 ? "down" : "up");
        if (!player.moving) { player.strike(direction); }
      } else { handleTap(evt); }
      dragStart = null;
    });
    
    function handleTap(evt) {
      evt.preventDefault();
      let rect = canvas.getBoundingClientRect();
      let tapX = evt.clientX - rect.left, tapY = evt.clientY - rect.top;
      if (performManualStrikeAt(tapX, tapY)) { triggerHeadbutt(); return; }
      let dir = computeDirection(evt.clientX, evt.clientY);
      if (dir && !player.moving) { player.move(dir); }
      else {
        let playerScreenPos = camera.worldToScreen(player.position);
        if (tapX >= playerScreenPos.x && tapX <= playerScreenPos.x + player.width &&
            tapY >= playerScreenPos.y && tapY <= playerScreenPos.y + player.height) { triggerHeadbutt(); }
      }
    }
    
    function computeDirection(clientX, clientY) {
      let rect = canvas.getBoundingClientRect();
      let tapX = clientX - rect.left, tapY = clientY - rect.top;
      let worldPos = camera.screenToWorld(new Vector2(tapX, tapY));
      let gridX = Math.floor((worldPos.x / 32 + worldPos.y / 16) / 2);
      let gridY = Math.floor((worldPos.y / 16 - worldPos.x / 32) / 2);
      if (gridX === player.gridX && gridY === player.gridY) return null;
      let dx = gridX - player.gridX, dy = gridY - player.gridY;
      let direction;
      if (Math.abs(dx) + Math.abs(dy) === 1) { 
        direction = dx === 1 ? "right" : dx === -1 ? "left" : dy === 1 ? "down" : "up"; 
      } else { 
        direction = Math.abs(dx) >= Math.abs(dy) ? (dx > 0 ? "right" : "left") : (dy > 0 ? "down" : "up"); 
      }
      return direction;
    }
    
    function rectIntersect(a, b) {
      return a.x < b.x + b.width && a.x + a.width > b.x &&
             a.y < b.y + b.height && a.y + a.height > b.y;
    }
    
    function triggerHeadbutt() {
      let playerScreenPos = camera.worldToScreen(player.position);
      let headbuttDiv = document.getElementById("headbuttEffect");
      headbuttDiv.style.left = (playerScreenPos.x + player.width / 2 - 32) + "px";
      headbuttDiv.style.top = (playerScreenPos.y + player.height / 2 - 32) + "px";
      headbuttDiv.classList.remove("active");
      void headbuttDiv.offsetWidth;
      headbuttDiv.classList.add("active");
      let playerBox = { x: playerScreenPos.x, y: playerScreenPos.y, width: player.width, height: player.height };
      enemies.forEach((enemy) => {
        let enemyScreenPos = camera.worldToScreen(enemy.position);
        let enemyBox = { x: enemyScreenPos.x, y: enemyScreenPos.y, width: enemy.width, height: enemy.height };
        if (rectIntersect(playerBox, enemyBox)) {
          addSpriteFlash(enemy.position);
          let playerCenter = new Vector2(playerBox.x + playerBox.width / 2, playerBox.y + playerBox.height / 2);
          let enemyCenter = new Vector2(enemyBox.x + enemyBox.width / 2, enemyBox.y + enemyBox.height / 2);
          let knockVec = enemyCenter.subtract(playerCenter).normalize().scale(40);
          enemy.knockback = enemy.knockback.add(knockVec);
        }
      });
    }
    
    // Bomb deployment triggered by tapping the bomb tile
    function deployBomb() {
      if (bombCount > 0) {
        bombCount--;
        baitBombs.push(new BaitBomb(player.gridX, player.gridY, tileMap));
      }
    }
    class BaitBomb {
  constructor(tileX, tileY, tileMap) {
    this.tileMap = tileMap;
    this.tileX = tileX;
    this.tileY = tileY;
    this.position = tileMap.gridToWorld(tileX, tileY);
    this.timer = 3.0; // Bomb explodes after 3 seconds
  }
  update(deltaTime) {
    this.timer -= deltaTime;
  }
  render(ctx, camera, t) {
    let screenPos = camera.worldToScreen(this.position);
    // Optional: add some pulsing effect
    let pulse = 1 + 0.2 * Math.sin(t * 10);
    ctx.save();
    ctx.translate(screenPos.x, screenPos.y);
    ctx.scale(pulse, pulse);
    ctx.font = `${this.tileMap.tileWidth / 2}px sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#FFFF00";
    ctx.fillText("üí£", 0, 0);
    ctx.restore();
    // Draw timer text
    ctx.font = "12px sans-serif";
    ctx.fillStyle = "white";
    ctx.fillText(this.timer.toFixed(1), screenPos.x, screenPos.y - 5);
  }
}

    // Tapping the bomb tile (explosives slot) deploys a bomb
    const explosivesSlot = document.getElementById("explosivesSlot");
    explosivesSlot.addEventListener("click", (evt) => {
      if (bombCount > 0) {
        deployBomb();
        explosivesSlot.classList.add("active");
        setTimeout(() => { explosivesSlot.classList.remove("active"); }, 200);
      }
    });
    
    // Update bomb tile to show bomb count overlay
   function updateExplosivesSlot() {
  const explosivesSlot = document.getElementById("explosivesSlot");
  explosivesSlot.innerHTML = "üí£<div class='counter'>" + bombCount + "</div>";
  if (bombCount > 0) {
    explosivesSlot.style.opacity = "1";
    explosivesSlot.style.cursor = "pointer";
    explosivesSlot.classList.add("bomb-available");
  } else {
    explosivesSlot.style.opacity = "0.5";
    explosivesSlot.style.cursor = "default";
    explosivesSlot.classList.remove("bomb-available");
  }
}

    
    // Update power-up tray slots for shield and healing charm
function updatePowerupTraySlots() {
  const defenseSlot = document.getElementById("defenseSlot");
  const charmsSlot = document.getElementById("charmsSlot");

  if (defenseBoostActive) {
    const ratio = defenseBoostTimer / baseDefenseBoostDuration;
    // A blue gradient that fills from bottom up (draining from the top)
    defenseSlot.style.background = `linear-gradient(to top, blue ${ratio * 100}%, transparent ${ratio * 100}%)`;
    defenseSlot.innerHTML = "üõ°Ô∏è<div class='timer'>" + Math.ceil(defenseBoostTimer) + "s</div>";
  } else {
    defenseSlot.style.background = "";
    defenseSlot.innerHTML = "üõ°Ô∏è";
  }

  if (healingCharmActive) {
    const ratio = healingCharmTimer / baseHealingCharmDuration;
    // A purple gradient that fills from bottom up
    charmsSlot.style.background = `linear-gradient(to top, purple ${ratio * 100}%, transparent ${ratio * 100}%)`;
    charmsSlot.innerHTML = "ü™¨<div class='timer'>" + Math.ceil(healingCharmTimer) + "s</div>";
  } else {
    charmsSlot.style.background = "";
    charmsSlot.innerHTML = "ü™¨";
  }
}


    function updatePickups() {
      for (let i = pickups.length - 1; i >= 0; i--) {
        let pickup = pickups[i];
        if (player.position.x < pickup.position.x + pickup.size &&
            player.position.x + player.width > pickup.position.x &&
            player.position.y < pickup.position.y + pickup.size &&
            player.position.y + player.height > pickup.position.y) {
          if (pickup instanceof BombPickup) {
            bombCount++;
            spawnPickupEffect(pickup.position);
          } else if (pickup instanceof SwordPickup) {  autoStrikeTime += autoStrikeBonus; // add bonus seconds from pickup
            if (strikeRangeTiles > 1) {
              // Use strikeMeter here instead of maxStrikeMeter
              player.strikeMeter = strikeMeterCapacity;
            
            }
            spawnPickupEffect(pickup.position);
          } else if (pickup instanceof HealthPickup) {
            player.hp = Math.min(player.hp + 20, player.maxHP);
            spawnPickupEffect(pickup.position);
          } else if (pickup instanceof DefenseBoostPickup) {
            defenseBoostActive = true;
            defenseBoostTimer = baseDefenseBoostDuration;
            spawnPickupEffect(pickup.position);
          } else if (pickup instanceof HealingCharmPickup) {
            healingCharmActive = true;
            healingCharmTimer = baseHealingCharmDuration;
            spawnPickupEffect(pickup.position);
          }
          pickups.splice(i, 1);
        }
      }
    }
    
    function updateBaitBombs(deltaTime) {
      for (let i = baitBombs.length - 1; i >= 0; i--) {
        baitBombs[i].update(deltaTime);
        if (baitBombs[i].timer <= 0) {
          screenShakeTime = 0.5;
          screenShakeMagnitude = 20;
          spawnExplosionEffect(baitBombs[i].position);
          let bx = baitBombs[i].tileX, by = baitBombs[i].tileY;
          enemies.forEach((enemy) => {
            if (enemy.gridX >= bx - 1 && enemy.gridX <= bx + 1 &&
                enemy.gridY >= by - 1 && enemy.gridY <= by + 1) {
              if (enemy.alive) {
                let blastDir = enemy.position.subtract(baitBombs[i].position).normalize();
                let blastForce = blastDir.scale(200);
                enemy.knockback = enemy.knockback.add(blastForce);
                enemy.alive = false;
                spawnEnemyExplosionEffect(enemy.position);
                killCount++;
                triggerScreenFlash();
                addSpriteFlash(enemy.position);
              }
            }
          });
          baitBombs.splice(i, 1);
        }
      }
    }
function updateMaxStrikeTally() {
  const tallyContainer = document.querySelector('#maxStrikeSlot .tally-container');
  const numTiles = strikeRangeTiles; // number of tallies to display
  let tallyHTML = "";
  let threshold = strikeMeterCapacity / strikeRangeTiles;
  for (let i = 0; i < numTiles; i++) {
    if (player.strikeMeter >= (i + 1) * threshold) {
      tallyHTML += "<div class='tally'></div>";
    } else {
      tallyHTML += "<div class='tally' style='opacity:0.3;'></div>";
    }
  }
  tallyContainer.innerHTML = tallyHTML;
}


function updateTrayHUD() {
  // Points and Kills remain the same
  const pointsSlot = document.getElementById("pointsSlot");
  const pointsCounter = pointsSlot.querySelector('.counter');
  pointsCounter.textContent = Math.floor(points);
  
  const killsSlot = document.getElementById("killsSlot");
  const killsCounter = killsSlot.querySelector('.counter');
  killsCounter.textContent = killCount;
  
  // HP slot: using a linear gradient like before
  const hpSlot = document.getElementById("hpSlot");
  const hpCounter = hpSlot.querySelector('.counter');
  hpCounter.textContent = Math.floor(player.hp);
  let hpPercentage = player.hp / player.maxHP;
  hpSlot.style.background = `linear-gradient(to top, rgba(255,0,0,0.7) ${hpPercentage * 100}%, transparent ${hpPercentage * 100}%)`;
  
  // Auto-Strike slot: update its background fully with an orange gradient
  const autoStrikeSlot = document.getElementById("autoStrikeSlot");
  const autoStrikeCounter = autoStrikeSlot.querySelector('.counter');
  autoStrikeCounter.textContent = autoStrikeTime.toFixed(1);
  const autoStrikeIndicator = autoStrikeSlot.querySelector('.indicator');
  autoStrikeIndicator.textContent = autoStrikeTime > 0 ? "‚úÖ" : "‚ùå";
  
  const ratio = autoStrikeTime / baseAutoStrikeTime;
  autoStrikeSlot.style.background = `linear-gradient(to top, orange ${ratio * 100}%, transparent ${ratio * 100}%)`;

  // Max Strike slot remains unchanged (using its gradient background)
  const maxStrikeSlot = document.getElementById("maxStrikeSlot");
  let strikeFraction = player.strikeMeter / strikeMeterCapacity;
  maxStrikeSlot.style.background = `linear-gradient(to top, rgba(255,215,0,0.8) ${strikeFraction * 100}%, transparent ${strikeFraction * 100}%)`;
  updateMaxStrikeTally();
  
  
 // Update Power-Up Tray (Shield and Charm)
  const defenseSlot = document.getElementById("defenseSlot");
  const charmsSlot = document.getElementById("charmsSlot");
  
  if (defenseBoostActive) {
    defenseSlot.classList.remove("dimmed");  // remove dimmed when active
    const defRatio = defenseBoostTimer / baseDefenseBoostDuration;
    defenseSlot.style.background = `linear-gradient(to top, blue ${defRatio * 100}%, transparent ${defRatio * 100}%)`;
    defenseSlot.innerHTML = "üõ°Ô∏è<div class='timer'>" + Math.ceil(defenseBoostTimer) + "s</div>";
  } else {
    defenseSlot.classList.add("dimmed");  // add dimmed when not active
    defenseSlot.style.background = "";
    defenseSlot.innerHTML = "üõ°Ô∏è";
  }
  
  if (healingCharmActive) {
    charmsSlot.classList.remove("dimmed");  // remove dimmed when active
    const charmRatio = healingCharmTimer / baseHealingCharmDuration;
    charmsSlot.style.background = `linear-gradient(to top, purple ${charmRatio * 100}%, transparent ${charmRatio * 100}%)`;
    charmsSlot.innerHTML = "ü™¨<div class='timer'>" + Math.ceil(healingCharmTimer) + "s</div>";
  } else {
    charmsSlot.classList.add("dimmed");  // add dimmed when not active
    charmsSlot.style.background = "";
    charmsSlot.innerHTML = "ü™¨";
  }
}

    function showUpgradeMenu() {
      isUpgradeMenuVisible = true;
      document.getElementById("upgradeMenu").style.display = "flex";
      document.getElementById("pointsDisplay").textContent = Math.floor(points);
      timeScale = 0;
    }
    function resumeGame() {
      isUpgradeMenuVisible = false;
      document.getElementById("upgradeMenu").style.display = "none";
      enemies.length = 0;
      bullets.length = 0;
      pickups.length = 0;
      baitBombs.length = 0;
      player.respawn();
      autoStrikeTime = baseAutoStrikeTime;
      timeScale = 1.0;
    }
    
    // Upgrade buttons
    document.getElementById("increaseHP").addEventListener("click", () => {
      const cost = 50;
      if (points >= cost) {
        points -= cost;
        player.maxHP += 20;
        player.hp += 20;
        document.getElementById("pointsDisplay").textContent = Math.floor(points);
      }
    });
document.getElementById("increaseAutoRun").addEventListener("click", () => {
  const cost = 200;
  if (points >= cost) {
    points -= cost;
    baseAutoStrikeTime += 10;  // Increase base auto-strike time
    autoStrikeTime += 10;       // Increase current auto-strike timer
    autoStrikeBonus += 5;       // Increase bonus seconds per sword pickup
    document.getElementById("pointsDisplay").textContent = Math.floor(points);
  }
});
    document.getElementById("increaseDash").addEventListener("click", () => {
      const cost = 300;
      if (points >= cost && strikeRangeTiles < tileMap.width) {
        points -= cost;
        strikeRangeTiles++;
        document.getElementById("pointsDisplay").textContent = Math.floor(points);
      }
    });
    document.getElementById("increaseStrikeMeter").addEventListener("click", () => {
      const cost = 150;
      if (points >= cost) {
        points -= cost;
        strikeMeterCapacity += 10;
        document.getElementById("pointsDisplay").textContent = Math.floor(points);
      }
    });
    document.getElementById("increaseHealingCharmTime").addEventListener("click", () => {
      const cost = 250;
      if (points >= cost) {
        points -= cost;
        baseHealingCharmDuration += 2;
        baseHealingCharmHeal += 0.5;
        document.getElementById("pointsDisplay").textContent = Math.floor(points);
      }
    });
    document.getElementById("increaseShieldingTime").addEventListener("click", () => {
      const cost = 250;
      if (points >= cost) {
        points -= cost;
        baseDefenseBoostDuration += 2;
        baseShieldDamageReduction = Math.min(baseShieldDamageReduction + 0.1, 0.9);
        document.getElementById("pointsDisplay").textContent = Math.floor(points);
      }
    });
    document.getElementById("resumeGame").addEventListener("click", () => { resumeGame(); });
    
    let lastTime = performance.now();
    function gameLoop() {
      let currentTime = performance.now();
      let deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      globalTime += deltaTime;
      
      // Deplete strike meter over time using the current meter.
      if (!player.isDead && !isUpgradeMenuVisible) {
        player.strikeMeter = Math.max(0, player.strikeMeter - goldDecayRate * deltaTime);
      }
      
      let effectiveDelta = deltaTime * timeScale;
      
      if (!player.isDead && !isUpgradeMenuVisible) { points += effectiveDelta * 10; }
      
      // Update power-ups
      if (defenseBoostActive) {
        defenseBoostTimer -= effectiveDelta;
        if (defenseBoostTimer <= 0) defenseBoostActive = false;
      }
      if (healingCharmActive) {
        healingCharmTimer -= effectiveDelta;
        if (healingCharmTimer <= 0) healingCharmActive = false;
        else {
          // Auto-heal player while charm is active
          player.hp = Math.min(player.maxHP, player.hp + baseHealingCharmHeal * effectiveDelta);
        }
      }
      
      if (!isUpgradeMenuVisible) {
        player.update(effectiveDelta);
        enemies.forEach(enemy => enemy.update(effectiveDelta));
        bullets.forEach(bullet => bullet.update(effectiveDelta));
        updateEffects(effectiveDelta);
        updateMeleeEffects(effectiveDelta);
        updatePickups();
        updateBaitBombs(effectiveDelta);
        
        bullets.forEach(bullet => {
          if (bullet.owner === "player") {
            enemies.forEach(enemy => {
              if (bullet.position.x >= enemy.position.x &&
                  bullet.position.x <= enemy.position.x + enemy.width &&
                  bullet.position.y >= enemy.position.y &&
                  bullet.position.y <= enemy.position.y + enemy.height) {
                bullet.alive = false;
                let baseKnock = bullet.velocity.normalize().scale(20);
                enemy.knockback = enemy.knockback.add(baseKnock);
                screenShakeTime = 0.2;
                screenShakeMagnitude = 10;
              }
            });
          } else if (bullet.owner === "enemy") {
            if (bullet.position.x >= player.position.x &&
                bullet.position.x <= player.position.x + player.width &&
                bullet.position.y >= player.position.y &&
                bullet.position.y <= player.position.y + player.height) {
              bullet.alive = false;
              let damage = 20;
              if (defenseBoostActive) {
                damage *= (1 - baseShieldDamageReduction);
              }
              player.hp -= damage;
              screenShakeTime = 0.2;
              screenShakeMagnitude = 5;
              if (player.hp <= 0 && !player.isDead) {
                player.isDead = true;
                spawnBloodEffect(player.position);
                slowMotionTimer = 1.0;
                timeScale = 0.2;
                player.knockback = player.knockback.add(new Vector2(0, -50));
                triggerScreenFlash();
              }
            }
          }
        });
        
        for (let i = bullets.length - 1; i >= 0; i--) {
          if (!bullets[i].alive) bullets.splice(i, 1);
        }
        for (let i = enemies.length - 1; i >= 0; i--) {
          if (!enemies[i].alive) enemies.splice(i, 1);
        }
        
        let dynamicEnemySpawnInterval = Math.max(3.0 - (killCount * 0.05), 0.5);
        enemySpawnTimer += effectiveDelta;
        if (enemySpawnTimer >= dynamicEnemySpawnInterval) {
          enemySpawnTimer = 0;
          let edge = Math.floor(Math.random() * 4);
          let gridX, gridY;
          if (edge === 0) { gridX = 0; gridY = Math.floor(Math.random() * tileMap.height); }
          else if (edge === 1) { gridX = tileMap.width - 1; gridY = Math.floor(Math.random() * tileMap.height); }
          else if (edge === 2) { gridY = 0; gridX = Math.floor(Math.random() * tileMap.width); }
          else { gridY = tileMap.height - 1; gridX = Math.floor(Math.random() * tileMap.width); }
          enemies.push(new Enemy(gridX, gridY, tileMap));
        }
        
        pickupSpawnTimer += effectiveDelta;
        if (pickupSpawnTimer >= pickupSpawnInterval) {
  pickupSpawnTimer = 0;
  let gridX = Math.floor(Math.random() * tileMap.width);
  let gridY = Math.floor(Math.random() * tileMap.height);
  // Randomly choose one of the five pickup types:
  let rand = Math.random();
  if (rand < 0.2) { 
    pickups.push(new BombPickup(gridX, gridY, tileMap));
  } else if (rand < 0.4) {
    pickups.push(new SwordPickup(gridX, gridY, tileMap));
  } else if (rand < 0.6) {
    pickups.push(new HealthPickup(gridX, gridY, tileMap));
  } else if (rand < 0.8) {
    pickups.push(new DefenseBoostPickup(gridX, gridY, tileMap));
  } else {
    pickups.push(new HealingCharmPickup(gridX, gridY, tileMap));
  }
}

        
        enemies.forEach(enemy => resolveCollision(player, enemy));
        for (let i = 0; i < enemies.length; i++) {
          for (let j = i + 1; j < enemies.length; j++) {
            resolveCollision(enemies[i], enemies[j]);
          }
        }
        
        if (!player.isDead && autoStrikeTime > 0) {
          autoStrikeTime -= deltaTime;
          autoStrikeTimer -= deltaTime;
          if (autoStrikeTimer <= 0) {
            autoStrikeTimer = autoStrikeInterval;
            performAutoStrike();
          }
          if (autoStrikeTime < 0) autoStrikeTime = 0;
        }
        
        if (player.isDead && !isUpgradeMenuVisible) {
          slowMotionTimer -= deltaTime;
          if (slowMotionTimer <= 0) { showUpgradeMenu(); }
        }
        
        updateCamera();
      }
      
      ctx.fillStyle = "#505050";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      tileMap.render(ctx, camera);
      enemies.forEach(enemy => enemy.render(ctx, camera));
      pickups.forEach(pickup => pickup.render(ctx, camera, globalTime));
      baitBombs.forEach(bomb => bomb.render(ctx, camera, globalTime));
      bullets.forEach(bullet => bullet.render(ctx, camera));
      renderEffects(ctx, camera);
      renderMeleeEffects(ctx, camera);
      player.render(ctx, camera);
  
      
      if (screenFlashAlpha > 0) {
        ctx.fillStyle = "rgba(255,0,0," + screenFlashAlpha + ")";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        screenFlashAlpha -= deltaTime * 2;
        if (screenFlashAlpha < 0) screenFlashAlpha = 0;
      }
      
      for (let i = spriteFlashes.length - 1; i >= 0; i--) {
        let flash = spriteFlashes[i];
        let playerBox = { x: player.position.x, y: player.position.y, width: player.width, height: player.height };
        if (flash.position.x >= playerBox.x && flash.position.x <= playerBox.x + playerBox.width &&
            flash.position.y >= playerBox.y && flash.position.y <= playerBox.y + playerBox.height) {
          flash.timer -= deltaTime;
          if (flash.timer <= 0) spriteFlashes.splice(i, 1);
          continue;
        }
        let alpha = flash.timer / flash.duration;
        ctx.fillStyle = "rgba(255,0,0," + alpha + ")";
        let flashScreenPos = camera.worldToScreen(flash.position);
        ctx.beginPath();
        ctx.arc(flashScreenPos.x, flashScreenPos.y, 32, 0, Math.PI * 2);
        ctx.fill();
        flash.timer -= deltaTime;
        if (flash.timer <= 0) spriteFlashes.splice(i, 1);
      }
      
      updateExplosivesSlot();updateAttackSlot();
      updatePowerupTraySlots();
        updateTrayHUD();
      requestAnimationFrame(gameLoop);
    }  // Update tray HUD icons
  setInterval(updateAttackSlot, 100);
    requestAnimationFrame(gameLoop);
    
  </script>
</body>
</html>
