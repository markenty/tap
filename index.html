
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shooter Game with Levels</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #111, #444);
            color: white;
            font-family: sans-serif;
        }
        #gameCanvas {
            display: block;
            margin: 0;
            background: #000;
            
        }
        #ui {
            position: absolute;
            top: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            font-size: 18px;
        }
        #ui div {
            margin: 0 10px;
        }
        #ui {
    position: fixed; /* Ensure it stays on top */
    top: 0;
    width: 100%;
    z-index: 10; /* Keep it above the canvas */
    display: flex;
    justify-content: space-between;
    padding: 10px;
    box-sizing: border-box;
    font-size: 18px;
}
    </style>
</head>
<body>
    <div id="ui">
        <div id="score">Score: 0</div>
        <div id="level">Level: 1</div>
        <div id="lives">Lives: 3</div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script>
        class GameEntity {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.active = true;
            }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }
class ParallaxBackground {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.stars = [];
                this.createStars();
            }
            createStars() {
                for (let i = 0; i < 100; i++) {
                    this.stars.push({
                        x: Math.random() * this.width,
                        y: Math.random() * this.height,
                        speed: Math.random() * 2 + 1
                    });
                }
            }
            update() {
                this.stars.forEach(star => {
                    star.x -= star.speed;
                    if (star.x < 0) {
                        star.x = this.width;
                        star.y = Math.random() * this.height;
                        star.speed = Math.random() * 2 + 1;
                    }
                });
            }
            draw(ctx) {
                ctx.fillStyle = "white";
                this.stars.forEach(star => {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }
        class Player extends GameEntity {
            constructor(x, y, width, height, color) {
                super(x, y, width, height, color);
                this.speed = 5;
                this.bullets = [];
            }
            draw(ctx) {
    const centerX = this.x + this.width / 2;
    const centerY = this.y + this.height / 2;
    const radius = this.width / 2;

    // Outer glow effect
    ctx.shadowBlur = 20;
    ctx.shadowColor = "cyan";

    // Outer hexagon
    ctx.fillStyle = "blue";
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();

    // Inner core (circle)
    ctx.shadowBlur = 0;
    ctx.fillStyle = "cyan";
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius / 3, 0, Math.PI * 2);
    ctx.fill();
}
            move(dx, dy, canvasWidth, canvasHeight) {
                this.x = Math.max(0, Math.min(canvasWidth - this.width, this.x + dx));
                this.y = Math.max(0, Math.min(canvasHeight - this.height, this.y + dy));
            }
            shoot(targetX, targetY) {
                const angle = Math.atan2(targetY - (this.y + this.height / 2), targetX - (this.x + this.width / 2));
                const speed = 8;
                
                this.bullets.push(new Bullet(
                    this.x + this.width / 2 - 2.5,
                    this.y + this.height / 2 - 2.5,
                    5,
                    5,
                    "yellow",
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed
                ));
                 console.log('\u0007');
                 if (navigator.vibrate) {
        navigator.vibrate(50); // 50ms vibration
    }
              
            }
        }

        class Bullet extends GameEntity {
            constructor(x, y, width, height, color, dx, dy) {
                super(x, y, width, height, color);
                this.dx = dx;
                this.dy = dy;
            }
            draw(ctx) {
    const centerX = this.x + this.width / 2;
    const centerY = this.y + this.height / 2;
    const radius = this.width / 2;

    // Outer glow
    ctx.shadowBlur = 10;
    ctx.shadowColor = "lime";

    // Orb design
    ctx.fillStyle = "green";
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fill();

    // Inner core
    ctx.shadowBlur = 1;
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius / 2, 0, Math.PI * 2);
    ctx.fill();
}
            update(canvasWidth, canvasHeight) {
                this.x += this.dx;
                this.y += this.dy;
                if (this.x < 0 || this.x > canvasWidth || this.y < 0 || this.y > canvasHeight) {
                    this.active = false;
                }
            }
        }

        class Enemy extends GameEntity {
            constructor(x, y, width, height, color, speed) {
                super(x, y, width, height, color);
                this.speed = speed;
            }
            update(playerX, playerY) {
                const angle = Math.atan2(playerY - this.y, playerX - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
            }
            draw(ctx) {
    const centerX = this.x + this.width / 2;
    const centerY = this.y + this.height / 2;
    const outerRadius = this.width / 2;
    const innerRadius = outerRadius * 0.6;
    const teeth = 8;

    // Gear design
    ctx.fillStyle = "red";
    ctx.shadowBlur = 15;
    ctx.shadowColor = "magenta";
    ctx.beginPath();
    for (let i = 0; i < teeth * 2; i++) {
        const angle = (Math.PI / teeth) * i;
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
}
        }

        class Game {spawnOneUp() {
    const x = Math.random() * (this.canvas.width - 20);
    const y = -20; // Spawn above the screen
    const oneUp = new OneUp(x, y, 20, 20, "green");
    this.oneUps.push(oneUp);
}
        
        registerTouchEvents() {
    let isDragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    this.canvas.addEventListener("touchstart", (e) => {
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        const touchX = touch.clientX - rect.left;
        const touchY = touch.clientY - rect.top;

        if (
            touchX >= this.player.x &&
            touchX <= this.player.x + this.player.width &&
            touchY >= this.player.y &&
            touchY <= this.player.y + this.player.height
        ) {
            isDragging = true;
            dragOffsetX = touchX - this.player.x;
            dragOffsetY = touchY - this.player.y;
        }
    });

    this.canvas.addEventListener("touchmove", (e) => {
        if (isDragging) {
            const touch = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            this.player.x = Math.max(0, Math.min(this.canvas.width - this.player.width, touchX - dragOffsetX));
            this.player.y = Math.max(0, Math.min(this.canvas.height - this.player.height, touchY - dragOffsetY));
        }
    });

    this.canvas.addEventListener("touchend", () => {
        isDragging = false;
    });
}

            constructor() {
                this.canvas = document.getElementById("gameCanvas");
                this.ctx = this.canvas.getContext("2d");
                this.player = null;
                this.enemies = [];
                this.spawnRate = 2000;
                this.score = 0;
                this.level = 1;
                this.lives = 10;
                this.keys = {};
                this.enemiesDefeated = 0;
                this.loop = this.loop.bind(this);
                this.oneUps = [];
				this.oneUpSpawnRate = 10000;

                window.addEventListener("resize", this.resizeCanvas.bind(this));
                this.resizeCanvas();
this.flashes = [];
                
                this.mouseX = 0;
                this.mouseY = 0;
                this.registerMouseEvents();
                
            }

            start() {
                this.background = new ParallaxBackground(this.canvas.width, this.canvas.height);
                this.player = new Player(
                    this.canvas.width / 2 - 25,
                    this.canvas.height / 2 - 25,
                    50,
                    50,
                    "lime"
                );

                window.addEventListener("keydown", (e) => this.keys[e.key] = true);
                window.addEventListener("keyup", (e) => this.keys[e.key] = false);
                this.registerMouseEvents();
    this.registerTouchEvents(); // Add this line
// Spawn enemies and 1-Up items
    this.spawnEnemies();
    setInterval(() => this.spawnOneUp(), this.oneUpSpawnRate);
                this.spawnEnemies();
                requestAnimationFrame(this.loop);
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                if (this.player) {
                    this.player.x = Math.min(this.player.x, this.canvas.width - this.player.width);
                    this.player.y = Math.min(this.player.y, this.canvas.height - this.player.height);
                }
            }

          registerMouseEvents() {
    const handleFire = (x, y) => {
        this.player.shoot(x, y);
    };

    this.canvas.addEventListener("mousemove", (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.mouseX = e.clientX - rect.left;
        this.mouseY = e.clientY - rect.top;
    });

    this.canvas.addEventListener("click", (e) => {
        const rect = this.canvas.getBoundingClientRect();
        const targetX = e.clientX - rect.left;
        const targetY = e.clientY - rect.top;
        handleFire(targetX, targetY);
    });

    this.canvas.addEventListener("touchstart", (e) => {
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        const targetX = touch.clientX - rect.left;
        const targetY = touch.clientY - rect.top;
        handleFire(targetX, targetY);
    });
}

            spawnEnemies() {
                setInterval(() => {
                    const enemy = new Enemy(
                        Math.random() * this.canvas.width,
                        Math.random() < 0.5 ? 0 : this.canvas.height,
                        40,
                        40,
                        "red",
                        Math.random() * 1.5 + this.level * 0.5
                    );
                    this.enemies.push(enemy);
                }, this.spawnRate);
            }

            checkCollisions() {
            this.oneUps.forEach((oneUp) => {
    if (
        oneUp.x < this.player.x + this.player.width &&
        oneUp.x + oneUp.width > this.player.x &&
        oneUp.y < this.player.y + this.player.height &&
        oneUp.y + oneUp.height > this.player.y
    ) {
        oneUp.active = false; // Remove the "1-Up"
        this.lives++; // Add a life
    }
});
                this.player.bullets.forEach((bullet) => {
                    this.enemies.forEach((enemy) => {
                        if (
                            bullet.x < enemy.x + enemy.width &&
                            bullet.x + bullet.width > enemy.x &&
                            bullet.y < enemy.y + enemy.height &&
                            bullet.y + bullet.height > enemy.y
                        ) {
                            bullet.active = false;
                            enemy.active = false;
                            this.score += 10;
                            this.enemiesDefeated += 1;
                    triggerScreenShake();  // Trigger vibration
                if (navigator.vibrate) {
                    navigator.vibrate(100); // Vibrate for 100ms
                }
                            // Add a simple flash effect at the enemy's position
    this.flashes.push({
        x: enemy.x + enemy.width / 2,
        y: enemy.y + enemy.height / 2,
        size: 40, // Size of the flash
        duration: 10 // Number of frames to show
    });
                        }
                    });
                });
            }

            updateEntities() {
                this.player.bullets = this.player.bullets.filter((b) => b.active);
                this.player.bullets.forEach((b) => b.update(this.canvas.width, this.canvas.height));
                
                this.oneUps = this.oneUps.filter((o) => o.active);
    			this.oneUps.forEach((o) => o.update(this.canvas.width, this.canvas.height));
                
				this.flashes = this.flashes.filter((flash) => flash.duration > 0);
				this.flashes.forEach((flash) => flash.duration--);
                
                this.enemies = this.enemies.filter((e) => e.active);
                this.enemies.forEach((e) => {
                    e.update(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2);
                    if (
                        e.x < this.player.x + this.player.width &&
                        e.x + e.width > this.player.x &&
                        e.y < this.player.y + this.player.height &&
                        e.y + e.height > this.player.y
                    ) {
                        e.active = false;
                        this.lives--;  triggerScreenShake();  // Trigger vibration
                if (navigator.vibrate) {
                    navigator.vibrate(100); // Vibrate for 100ms
                }                           this.flashes.push({
            x: this.player.x + this.player.width / 2,
            y: this.player.y + this.player.height / 2,
            size: 50, // Size of the flash
            duration: 15 // Number of frames to show
        });
                        if (this.lives <= 0) this.endGame();
                    }
                });

                if (this.enemiesDefeated >= 10) {
                    this.levelUp();
                }
            }

            levelUp() {
                this.level++;
                this.enemiesDefeated = 0;
                this.spawnRate = Math.max(500, this.spawnRate - 200);
            }

            endGame() {
                alert(`Game Over! Final Score: ${this.score}`);
                window.location.reload();
            }

            drawEntities() {
            	this.oneUps.forEach((o) => o.draw(this.ctx));
                this.player.draw(this.ctx);
                this.player.bullets.forEach((b) => b.draw(this.ctx));
                this.enemies.forEach((e) => e.draw(this.ctx));
                this.flashes.forEach((flash) => {
    this.ctx.fillStyle = `rgba(255, 255, 0, ${flash.duration / 10})`; // Yellow flash that fades
    this.ctx.beginPath();
    this.ctx.arc(flash.x, flash.y, flash.size * (flash.duration / 10), 0, Math.PI * 2);
    this.ctx.fill();
});

            }

            updateUI() {
                document.getElementById("score").textContent = `Score: ${this.score}`;
                document.getElementById("level").textContent = `Level: ${this.level}`;
                document.getElementById("lives").textContent = `Lives: ${this.lives}`;
            }

            loop() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

             const dx = 
    (this.keys["ArrowLeft"] || this.keys["a"] ? -this.player.speed : 0) +
    (this.keys["ArrowRight"] || this.keys["d"] ? this.player.speed : 0);
const dy = 
    (this.keys["ArrowUp"] || this.keys["w"] ? -this.player.speed : 0) +
    (this.keys["ArrowDown"] || this.keys["s"] ? this.player.speed : 0);

                this.player.move(dx, dy, this.canvas.width, this.canvas.height);
                this.updateEntities();
                this.checkCollisions();

                this.drawEntities();
                this.updateUI();

                requestAnimationFrame(this.loop);
            }
        }

        const game = new Game();
        game.start();

     function triggerScreenShake() {
    const canvas = document.getElementById("gameCanvas");
    const intensity = 5; // Shake intensity
    const duration = 200; // Shake duration in milliseconds
    const startTime = performance.now();

    function shake() {
        const elapsed = performance.now() - startTime;
        if (elapsed < duration) {
            const offsetX = (Math.random() - 0.5) * intensity;
            const offsetY = (Math.random() - 0.5) * intensity;

            // Only apply transform to canvas
            const transformValue = `translate(${offsetX}px, ${offsetY}px)`;
            canvas.style.transform = transformValue;

            requestAnimationFrame(shake);
        } else {
            // Reset canvas position
            canvas.style.transform = "";
        }
    }
    shake();
}
      
    </script>
    <script>
    class GamepadController {
        constructor(player, canvas) {
            this.player = player;
            this.canvas = canvas;
            this.gamepadIndex = null;
            this.initGamepadEvents();
        }

        initGamepadEvents() {
            // Detect when a gamepad connects
            window.addEventListener("gamepadconnected", (event) => {
                this.gamepadIndex = event.gamepad.index;
                console.log("Gamepad connected:", event.gamepad);
            });

            // Detect when a gamepad disconnects
            window.addEventListener("gamepaddisconnected", (event) => {
                if (this.gamepadIndex === event.gamepad.index) {
                    this.gamepadIndex = null;
                    console.log("Gamepad disconnected:", event.gamepad);
                }
            });
        }

        pollInput() {
            if (this.gamepadIndex === null) return; // No gamepad connected

            const gamepad = navigator.getGamepads()[this.gamepadIndex];
            if (!gamepad) return;

            const axes = gamepad.axes;
            const buttons = gamepad.buttons;

            // Player movement using left stick (axes 0 and 1)
            const dx = axes[0] * this.player.speed;
            const dy = axes[1] * this.player.speed;
            this.player.move(dx, dy, this.canvas.width, this.canvas.height);

            // Shooting direction using right stick (axes 2 and 3)
            const aimX = axes[2];
            const aimY = axes[3];
            if (Math.abs(aimX) > 0.2 || Math.abs(aimY) > 0.2) { // Deadzone
                const targetX = this.player.x + this.player.width / 2 + aimX * 100;
                const targetY = this.player.y + this.player.height / 2 + aimY * 100;
                this.player.shoot(targetX, targetY);
            }

            // Button actions
            if (buttons[0].pressed) {
                console.log("Button A pressed (Shoot)");
            }

            if (buttons[1].pressed) {
                console.log("Button B pressed (Special)");
            }
        }
    }

    // Integrate gamepad into the Game class
    const originalStart = Game.prototype.start;
    Game.prototype.start = function () {
        originalStart.call(this);
        this.gamepadController = new GamepadController(this.player, this.canvas);
    };

    const originalLoop = Game.prototype.loop;
    Game.prototype.loop = function () {
        originalLoop.call(this);
        if (this.gamepadController) {
            this.gamepadController.pollInput();
        }
    };
    
    // 1up
    
    
    class OneUp extends GameEntity {
    constructor(x, y, width, height, color) {
        super(x, y, width, height, color);
        this.speed = 1; // Optional: Add a slight movement effect
    }

    update(canvasWidth, canvasHeight) {
        this.y += this.speed;
        if (this.y > canvasHeight) {
            this.active = false; // Remove "1-Up" if it goes off-screen
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "white";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText("+1", this.x + this.width / 2, this.y + this.height / 2 + 4);
    }
}


</script>

</html>
